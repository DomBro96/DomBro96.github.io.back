<!DOCTYPE html>
<html>
    <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" >
    <title>
        
        栈及栈的应用 · Dom Blog
        
    </title>
    <link rel="icon" href= http://p0bl99g4r.bkt.clouddn.com/ti.JPG>
    <!-- TODO: 在font-face加载完毕后改变字体  -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/webfont/1.6.28/webfontloader.js"></script>
    <!-- 提前加载place holder  -->
    <style type="text/css">
        @font-face {
            font-family: 'Oswald-Regular';
            src: url(/font/Oswald-Regular.ttf);
        }
    </style>
    <style type="text/css">
        .site-intro-placeholder {
            position: absolute;
            z-index: -2;
            top: 0;
            left: 0px;
            width: calc(100% + 300px);
            height: 100%;
            background: repeating-linear-gradient(-45deg, #444 0, #444 80px, #333 80px, #333 160px);
            background-position: center center;
            transform: translate3d(-226px, 0, 0);
            animation: gradient-move 2.5s ease-out 0s 1;
        }
        @keyframes gradient-move {
        0% {
            transform: translate3d(-226px, 0, 0);
        }
        100% {
            transform: translate3d(0, 0, 0);
        }
    }
</style>
    <link rel="stylesheet" href = /css/style.css?v=20171020 />
    <script src="//cdn.staticfile.org/jquery/3.2.1/jquery.min.js" defer></script>
    
    <script src="/scripts/main.js" defer></script>
    <!-- 百度统计  -->
    
    <!-- 谷歌统计  -->
    
</head>
    
        <body class="post-body">
    
    
<header class="header">

    <div class="header-sidebar-menu">&#xe775;</div>
    <!-- post页的toggle banner  -->
    
    <div class="banner">
            <div class="blog-title">
                <a href="/" >DomBro Studio</a>
            </div>
            <div class="post-title">
                <a href="#" class="post-name">栈及栈的应用</a>
            </div>
    </div>
    
    <a class="home-link" href=/>DomBro Studio</a>
</header>
    <div class="wrapper">
        <div class="site-intro">
    
    <!-- 主页  -->
    
    
    <!-- 404页  -->
            
    <div class="site-intro-img" style="background-image: url(http://p0bl99g4r.bkt.clouddn.com/dog1.JPG)"></div>
    <div class="site-intro-placeholder"></div>
    <div class="site-intro-meta">
        <!-- 标题  -->
        <h1 class="intro-title">
            <!-- 主页  -->
            
            栈及栈的应用
            <!-- 404 -->
            
        </h1>
        <!-- 副标题 -->
        <p class="intro-subtitle">
            <!-- 主页副标题  -->
            
            
            <!-- 404 -->
            
        </p>
        <!-- 文章页meta -->
        
            <!-- 文章页标签  -->
            
                <div class= post-intro-tags >
    
        <a class="post-tag" href="javascript:void(0);" data-href = 数据结构 Data Structures>数据结构 Data Structures</a>
    
</div>
            
            <div class="post-intro-meta">
                <span class="post-intro-calander iconfont-archer">&#xe676;</span>
                <span class="post-intro-time">2017/12/21</span>
            </div>
        
    </div>
</div>
        <img class="loading" src="/assets/loading.svg" style="display: block; margin: 6rem auto 0 auto; width: 6rem; height: 6rem;" />
        <script>
            var browser = {
                    versions: function () {
                        var u = window.navigator.userAgent;
                        return {
                            userAgent: u,
                            trident: u.indexOf('Trident') > -1, //IE内核
                            presto: u.indexOf('Presto') > -1, //opera内核
                            webKit: u.indexOf('AppleWebKit') > -1, //苹果、谷歌内核
                            gecko: u.indexOf('Gecko') > -1 && u.indexOf('KHTML') == -1, //火狐内核
                            mobile: !!u.match(/AppleWebKit.*Mobile.*/), //是否为移动终端
                            ios: !!u.match(/\(i[^;]+;( U;)? CPU.+Mac OS X/), //ios终端
                            android: u.indexOf('Android') > -1 || u.indexOf('Linux') > -1, //android终端或者uc浏览器
                            iPhone: u.indexOf('iPhone') > -1 || u.indexOf('Mac') > -1, //是否为iPhone或者安卓QQ浏览器
                            iPad: u.indexOf('iPad') > -1, //是否为iPad
                            webApp: u.indexOf('Safari') == -1, //是否为web应用程序，没有头部与底部
                            weixin: u.indexOf('MicroMessenger') == -1, //是否为微信浏览器
                            uc: u.indexOf('UCBrowser') > -1 //是否为android下的UC浏览器
                        };
                    }()
                }

            function fontLoaded(){
                console.log('font loaded');
                if (document.getElementsByClassName('site-intro-meta')) {
                    document.getElementsByClassName('intro-title')[0].classList.add('intro-fade-in');
                    document.getElementsByClassName('intro-subtitle')[0].classList.add('intro-fade-in');
                    var postIntroTags = document.getElementsByClassName('post-intro-tags')[0],
                        postIntroMeat = document.getElementsByClassName('post-intro-meta')[0];
                        if (postIntroTags) {
                            postIntroTags.classList.add('post-fade-in');
                        }
                        if (postIntroMeat) {
                            postIntroMeat.classList.add('post-fade-in');
                        }
                    }
                }
                
            console.log("userAgent:" + browser.versions.userAgent);
            // UC不支持跨域，所以直接显示
            if (browser.versions.uc) {
                console.log("UCBrowser");
                fontLoaded();
            } else {
                WebFont.load({
                    custom: {
                        families: ['Oswald-Regular']
                    },
                    loading: function () {  //所有字体开始加载
                        // console.log('loading');
                    },
                    active: function () {  //所有字体已渲染
                        fontLoaded();
                    },
                    inactive: function () { //字体预加载失败，无效字体或浏览器不支持加载
                        console.log('inactive: timeout');
                        fontLoaded();
                    },
                    timeout: 7000 // Set the timeout to two seconds
                });
            }
        </script>
        <div class="container container-unloaded">
            <main class="main post-page">
    <article class="article-entry">
        <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>数据结构是一个程序员的内功，只有内功基础打牢了，才可以决定你是否可以练就上乘的武功。今天来说一说栈结构。</p>
<h2 id="What"><a href="#What" class="headerlink" title="What"></a>What</h2><p>啥是栈(stack)结构？关于栈结构听过最多的就是后入先出的结构(LIFO,last in first out)。别说你不知道啊！</p>
<ul>
<li>栈的特点</li>
</ul>
<p>1.首先栈你要知道栈是一个表(线性结构)，因此任何实现表的方法都能实现栈。<br>2.栈是限制插入和删除只能在一个位置进行的表，该位置是表的末端，叫做栈顶(top)。<br>3.对栈的基本操作有push（进栈）和 pop（出栈），前者相当于插入，后者则是删除最后插入的元素。<br>4.由于第二点和第三点中说的，栈只在栈顶进行操作，所以出栈和入栈都是常数时间的操作。</p>
<h2 id="How"><a href="#How" class="headerlink" title="How"></a>How</h2><p>根据栈的特点中的第一条，栈是一个表，任何实现表的方法都能实现栈。那就分别用数组和链表的方式实现一下栈。</p>
<h3 id="栈的数组实现"><a href="#栈的数组实现" class="headerlink" title="栈的数组实现"></a>栈的数组实现</h3><p>由于栈<strong>只操作栈顶元素</strong>，如果用顺序存储的数组实现,又考虑后入先出的原则，很自然就会想到利用数组中最后一个元素的索引（这里叫他topOfStack） ！比如push操作，我们可以先让topOfStack++，然后再把push的元素赋值给数组的topOfStack索引。</p>
<p><img src="http://p0bl99g4r.bkt.clouddn.com/ds_arrstack.PNG" alt=""> </p>
<p>很好理解吧？因为栈这个结构本身就是一个很基础的结构呀！下面是具体的代码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">public class ArrayStack&lt;AnyType&gt; &#123;</span><br><span class="line"></span><br><span class="line">    //默认规模</span><br><span class="line">    private static final int DEFAULT_CAPACITY = 10;</span><br><span class="line">    //用数组实现栈</span><br><span class="line">    private AnyType[] theArray;</span><br><span class="line">    //记录栈的规模</span><br><span class="line">    private int theSize;</span><br><span class="line">    //记录栈顶元素位置</span><br><span class="line">    private int top0fStack;</span><br><span class="line">    //通过构造方法完成初始化</span><br><span class="line">    public ArrayStack()&#123;</span><br><span class="line">        doClear();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 入栈操作</span><br><span class="line">     * 1.栈顶元素索引 ++，并指向插入元素</span><br><span class="line">     * 2.栈规模 ++</span><br><span class="line">     */</span><br><span class="line">    public void push(AnyType item)&#123;</span><br><span class="line">        //判断栈是否已满</span><br><span class="line">        if(theSize == theArray.length)&#123;</span><br><span class="line">            ensureCapacity(theSize*2+1);</span><br><span class="line">        &#125;</span><br><span class="line">        top0fStack++;</span><br><span class="line">        theArray[top0fStack] = item;</span><br><span class="line">        theSize++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public AnyType peek()&#123;</span><br><span class="line">        if (size() == 0)&#123;</span><br><span class="line">            throw new EmptyStackException();</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            return theArray[theSize-1];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int size() &#123;</span><br><span class="line">        return theSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 出栈操作</span><br><span class="line">     * 1.栈规模 --</span><br><span class="line">     * 2.返回当前栈顶元素，栈顶元素索引--</span><br><span class="line">     */</span><br><span class="line">    public AnyType pop()&#123;</span><br><span class="line">        theSize--;</span><br><span class="line">        return theArray[top0fStack--];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    private void doClear()&#123;</span><br><span class="line">        theSize = 0;</span><br><span class="line">        top0fStack = -1;</span><br><span class="line">        ensureCapacity(DEFAULT_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //扩充栈规模</span><br><span class="line">    public void ensureCapacity(int newCapacity)&#123;</span><br><span class="line"></span><br><span class="line">        if (theSize &gt; newCapacity)</span><br><span class="line">            return;</span><br><span class="line">        //判断theArray有没有被初始化</span><br><span class="line">        if (theArray != null)&#123;</span><br><span class="line">            AnyType[] oldItems = theArray;</span><br><span class="line">            theArray = (AnyType[]) new Object[newCapacity];</span><br><span class="line">            for (int i = 0; i &lt; theSize; i++)&#123;</span><br><span class="line">                theArray[i] = oldItems[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            theArray = (AnyType[]) new Object[newCapacity];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean isEmpty()&#123;</span><br><span class="line">        return theSize == 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有意思的是，你会发现我在pop（出栈）操作时，并没有将栈顶元素删除掉而是利用了 topOfStack(栈顶元素在数组中的索引) 减一，让使用者无法访问刚刚出栈的元素，这是一种<strong>逻辑上的删除</strong>。</p>
<h3 id="栈的链表实现"><a href="#栈的链表实现" class="headerlink" title="栈的链表实现"></a>栈的链表实现</h3><p>用链表实现栈的好处是，我们不用担心数组越界，数组是否已满等等，要考虑后入先出，我们就要依赖于 topOfStack 节点的引用(注意，这里是节点！！)，首先topOfStack 节点的数据域被初始化为null,当进行push操作时 topOfStack 的后继为新插入的节点，而新插入节点的前驱则为当前 topOfStack ，最后将 topOfStack 引用指向刚刚插入的节点。什么？你蒙了？看图呀！</p>
<p><img src="http://p0bl99g4r.bkt.clouddn.com/ds_linstack.PNG" alt=""></p>
<p>也就是说topOfStack就是指向栈顶的引用！下面使代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 用链表实现的栈</span><br><span class="line"> */</span><br><span class="line">public class LinkedStack&lt;AnyType&gt; &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //栈规模</span><br><span class="line">    private int theSize;</span><br><span class="line"></span><br><span class="line">    //栈顶结点</span><br><span class="line">    private Node&lt;AnyType&gt; topOfStack;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     *入栈操作：</span><br><span class="line">     * 1.将栈顶结点作为插入节点的前驱</span><br><span class="line">     * 2.栈顶结点变为新插入节点</span><br><span class="line">     * 3.栈规模加一</span><br><span class="line">     */</span><br><span class="line">    public void push(AnyType item)&#123;</span><br><span class="line">        Node&lt;AnyType&gt; newNode = new Node&lt;AnyType&gt;(item,topOfStack);</span><br><span class="line">        topOfStack.next = newNode;</span><br><span class="line">        topOfStack = topOfStack.next;</span><br><span class="line">        theSize++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public AnyType peek()&#123;</span><br><span class="line">        return topOfStack.data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 出栈操作:</span><br><span class="line">     * 1.返回当前栈顶结点的数据域</span><br><span class="line">     * 2.栈顶结点的前驱作为栈顶结点</span><br><span class="line">     * 3.栈规模减一</span><br><span class="line">     *</span><br><span class="line">     */</span><br><span class="line">    public AnyType pop()&#123;</span><br><span class="line"></span><br><span class="line">        Node&lt;AnyType&gt; oldTop;</span><br><span class="line">        if (theSize &lt;= 0)&#123;</span><br><span class="line">            throw new IllegalStateException();</span><br><span class="line">        &#125;</span><br><span class="line">        oldTop = topOfStack;</span><br><span class="line">        topOfStack = topOfStack.prev;</span><br><span class="line">        theSize--;</span><br><span class="line">        return oldTop.data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public LinkedStack()&#123;</span><br><span class="line">        doClear();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 对栈进行初始化</span><br><span class="line">     */</span><br><span class="line">    private void doClear()&#123;</span><br><span class="line">        topOfStack = new Node&lt;AnyType&gt;(null,null);</span><br><span class="line">        theSize = 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    private static class Node&lt;AntType&gt;&#123;</span><br><span class="line"></span><br><span class="line">        public AntType data ;</span><br><span class="line">        public Node&lt;AntType&gt; next;</span><br><span class="line">        public Node&lt;AntType&gt; prev;</span><br><span class="line"></span><br><span class="line">        public Node(AntType data,Node&lt;AntType&gt; prev)&#123;</span><br><span class="line">            this.data = data;</span><br><span class="line">            this.prev = prev;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean isEmpty()&#123;</span><br><span class="line">        return theSize &lt;= 0;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总的来说无论用数组实现还使用链表实现都是各有优缺点的，比如用数组实现你就要考虑数组长度问题，而用链表如果你指针(引用)知识学的很屎，则容易出现大的bug ！但是一般来说使用数组方式实现是更流行的。</p>
<h2 id="When"><a href="#When" class="headerlink" title="When"></a>When</h2><p>是英雄总要有用武之地，栈是一个在计算机科学中很常用也很实用的数据结构。下面来介绍几个简单的应用。</p>
<h3 id="符号平衡"><a href="#符号平衡" class="headerlink" title="符号平衡"></a>符号平衡</h3><p>如果你是一个 Java 或 C++ 等程序员(不包括Python)，如果不用 IDEA 或 Eclipse　等IDE 让你在记事本上(或者是 vim 等编辑器，无所谓啦)写程序，你可能很不习惯，因为这些家伙都不能自动为你补齐 { &lt; ( [ 括号的 右半部分，而且也不会提示你没有输入右半部分的括号。那你有没有好奇那些编辑器是咋做到的，其实很简单！就是利用咱们的栈结构！因为在编程语言中右括号一定会匹配离该右括号最近的左括号，而最近的左括号一定是最后输入的。<br>遵循以下几点：<br>1.给定一段字符串，当遇到 左括号 { &lt; ( [ 时入栈。<br>2.当遇到右括号 ] ) &gt; } 时出栈，判断出栈符号与右括号是否匹配。<br>3.当字符串读取完毕，但是栈中还有左括号时，说明存在未输入的右括号。</p>
<p>下面是代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">  * 栈的平衡符号应用</span><br><span class="line">  * 1.若遇到 [,&#123;,(,&lt; 入栈</span><br><span class="line">  * 2.若遇到 ].&#125;,),&gt; 出栈</span><br><span class="line">  */</span><br><span class="line">public static void bracketCheck(String input)&#123;</span><br><span class="line">   ArrayStack&lt;Character&gt; stack = new ArrayStack();</span><br><span class="line"></span><br><span class="line">   for (int i = 0;i &lt; input.length();i++)&#123;</span><br><span class="line">      char inChar =  input.charAt(i);</span><br><span class="line">      switch (inChar)&#123;</span><br><span class="line">         case &apos;[&apos;:</span><br><span class="line">         case &apos;&#123;&apos;:</span><br><span class="line">         case &apos;(&apos;:</span><br><span class="line">         case &apos;&lt;&apos;:</span><br><span class="line">           stack.push(inChar);</span><br><span class="line">           break;</span><br><span class="line"></span><br><span class="line">         case &apos;]&apos;:</span><br><span class="line">         case &apos;&#125;&apos;:</span><br><span class="line">         case &apos;)&apos;:</span><br><span class="line">         case &apos;&gt;&apos;:</span><br><span class="line">           if (! stack.isEmpty())&#123;</span><br><span class="line">           char popChar = stack.pop();</span><br><span class="line">           if ((popChar == &apos;[&apos; &amp;&amp; inChar != &apos;]&apos;) || (popChar == &apos;&#123;&apos; &amp;&amp; inChar != &apos;&#125;&apos;) || (popChar == &apos;(&apos; &amp;&amp; inChar != &apos;)&apos;)|| (popChar == &apos;&lt;&apos; &amp;&amp; inChar != &apos;&gt;&apos;))&#123;</span><br><span class="line">             throw new RuntimeException(&quot;请确保有与&quot;+inChar+&quot;对应字符&quot;);</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;else &#123;</span><br><span class="line">               throw new RuntimeException(&quot;你并没输入左侧符号&quot;);</span><br><span class="line">             &#125;</span><br><span class="line">              break;</span><br><span class="line"></span><br><span class="line">            default:</span><br><span class="line">              break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (!stack.isEmpty())&#123;</span><br><span class="line">          throw new RuntimeException(&quot;你并没输入右侧符号&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="后缀表达式求值"><a href="#后缀表达式求值" class="headerlink" title="后缀表达式求值"></a>后缀表达式求值</h3><p>我们的计算机是很笨的，他只会从左往右去读，比如让他计算 1*3+4+2 它会算出结果是 9 但是 1+3+4*2 他一定给你算一个 16 。怎么办呢？聪明的计算机设计人员设计了一种后缀表达式 1+3+4*2  就变成 13+42*+ 。啥？你看不懂？后缀表达式就是把原本在两个数字中间的运算符号放置在<strong>要计算的两个数字后面</strong>。<strong>计算后缀表达式最简单的做法就是使用栈，并且不需要知道任何优先规则</strong>！</p>
<p>遵循以下几点：<br>1.当遇到一个数字进栈；<br>2.遇到第一个操作符时，该运算符就作用于栈中弹出的两个数上，再将所得结果压入栈中。</p>
<p>下面是代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * 后缀表达式求值</span><br><span class="line">     * 1.将数字依次压入栈中</span><br><span class="line">     * 2.当遇到操作符时将栈中两个数字出栈，将两数字与操作符的结果再次压入栈中</span><br><span class="line">     * 3.后缀表达式的好处是不用知道任何优先规则</span><br><span class="line">     * 4.按照规定位与位之间用 &quot; &quot; 相隔</span><br><span class="line">     */</span><br><span class="line">    public static int postFix(String input)&#123;</span><br><span class="line">        ArrayStack&lt;Integer&gt; stack = new ArrayStack();</span><br><span class="line">        String[] postFix =  input.split(&quot; &quot;);</span><br><span class="line">        for (int i = 0;i &lt; postFix.length; i++)&#123;</span><br><span class="line">            String card = postFix[i];</span><br><span class="line">            int topOfStack ;</span><br><span class="line">            int nextOfStack;</span><br><span class="line">            int result;</span><br><span class="line">            if (card.matches(&quot;[0-9]+&quot;))&#123;</span><br><span class="line">                 int number = Integer.parseInt(card);</span><br><span class="line">                 stack.push(number);</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                switch (card)&#123;</span><br><span class="line">                    case &quot;+&quot;:</span><br><span class="line">                        topOfStack = stack.pop();</span><br><span class="line">                        nextOfStack = stack.pop();</span><br><span class="line">                        result = topOfStack + nextOfStack;</span><br><span class="line">                        stack.push(result);</span><br><span class="line">                        break;</span><br><span class="line">                    case &quot;-&quot;:</span><br><span class="line">                        topOfStack = stack.pop();</span><br><span class="line">                        nextOfStack = stack.pop();</span><br><span class="line">                        result = nextOfStack - topOfStack  ;</span><br><span class="line">                        stack.push(result);</span><br><span class="line">                        break;</span><br><span class="line">                    case &quot;*&quot;:</span><br><span class="line">                        topOfStack = stack.pop();</span><br><span class="line">                        nextOfStack = stack.pop();</span><br><span class="line">                        result = nextOfStack * topOfStack  ;</span><br><span class="line">                        stack.push(result);</span><br><span class="line">                        break;</span><br><span class="line">                    case &quot;/&quot;:</span><br><span class="line">                        topOfStack = stack.pop();</span><br><span class="line">                        nextOfStack = stack.pop();</span><br><span class="line">                        result = nextOfStack / topOfStack  ;</span><br><span class="line">                        stack.push(result);</span><br><span class="line">                        break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return stack.pop();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="中缀表达式转后缀表达式"><a href="#中缀表达式转后缀表达式" class="headerlink" title="中缀表达式转后缀表达式"></a>中缀表达式转后缀表达式</h3><p>上面介绍了后缀表达式求值，可是要怎样将正常的中缀表达式转为后缀表达式呢？仅考虑中缀表达式中的符号有 + - * / () 。还要考虑这几个符号的运算优先级，咋办？用栈！<br>遵循以下几点：<br>1.当遇到数字直接输出。<br>2.遇到 ( 入栈。<br>3.遇到 +或- ：判断栈顶是否为*或/ ，若是则将 * 或 /出栈并输出，并将 +或 -入栈<br>4.遇到*或/ ：直接入栈。<br>5.遇到 ) : 将栈中一直到 ( 的字符出栈并输出，( 出栈并不输出。<br>6.读取字符串之后，将栈中字符出栈并输出。</p>
<p>下面是代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">    * 通过中缀表达式得到后缀表达式</span><br><span class="line">    * 1.使用栈放入操作符</span><br><span class="line">    * 2.操作符仅允许使用 + - * / ()</span><br><span class="line">    * 3.优先级  () 大于 * / 大于 + -</span><br><span class="line">    * 4.当 遇到优先级 更高的操作符时，当遇到数字便全部出栈</span><br><span class="line">    * 5.当 栈中有 ( 时，除非遇到 ) 否则 ( 不出栈</span><br><span class="line">    * 6.按照规定位与位之间用 &quot; &quot; 相隔</span><br><span class="line">    */</span><br><span class="line">   public static String getPostFix(String input)&#123;</span><br><span class="line">       ArrayStack&lt;String&gt; opStack = new ArrayStack&lt;&gt;();</span><br><span class="line"></span><br><span class="line">       String[] preFixArray = input.split(&quot; &quot;);</span><br><span class="line">       String suffix = &quot;&quot;;</span><br><span class="line">       for (int i = 0; i &lt; preFixArray.length; i++)&#123;</span><br><span class="line">           String current = preFixArray[i];</span><br><span class="line">           String temp ;</span><br><span class="line">           switch (current)&#123;</span><br><span class="line">               //遇到 ( 则入栈</span><br><span class="line">               case &quot;(&quot;:</span><br><span class="line">                   opStack.push(current);</span><br><span class="line">                   break;</span><br><span class="line">               case &quot;+&quot;:</span><br><span class="line">               case &quot;-&quot;:</span><br><span class="line">                   while (!opStack.isEmpty())&#123;</span><br><span class="line">                       temp = opStack.pop();</span><br><span class="line">                       //如果是栈顶是 ( 则直接将当前字符串入栈,不进行操作</span><br><span class="line">                       if (temp.equals(&quot;(&quot;))&#123;</span><br><span class="line">                           opStack.push(&quot;(&quot;);</span><br><span class="line">                           break;</span><br><span class="line">                       &#125;else &#123;</span><br><span class="line">                           suffix += &quot; &quot;+temp;</span><br><span class="line">                       &#125;</span><br><span class="line"></span><br><span class="line">                   &#125;</span><br><span class="line">                   opStack.push(current);</span><br><span class="line">                   suffix += &quot; &quot;;</span><br><span class="line">                   break;</span><br><span class="line">               case &quot;*&quot;:</span><br><span class="line">               case &quot;/&quot;:</span><br><span class="line">                   while (!opStack.isEmpty())&#123;</span><br><span class="line">                       temp = opStack.pop();</span><br><span class="line">                       if (temp.equals(&quot;(&quot;) || temp.equals(&quot;+&quot;) || temp.equals(&quot;-&quot;))&#123;</span><br><span class="line">                           opStack.push(temp);</span><br><span class="line">                           break;</span><br><span class="line">                       &#125;else &#123;</span><br><span class="line">                            suffix += &quot; &quot; + temp;</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">                   opStack.push(current);</span><br><span class="line">                   suffix += &quot; &quot;;</span><br><span class="line">                   break;</span><br><span class="line">               case &quot;)&quot;:</span><br><span class="line">                   while (!opStack.isEmpty())&#123;</span><br><span class="line">                       temp = opStack.pop();</span><br><span class="line">                       if (temp.equals(&quot;(&quot;))&#123;</span><br><span class="line">                           break;</span><br><span class="line">                       &#125;else &#123;</span><br><span class="line">                           suffix += &quot; &quot;+temp ;</span><br><span class="line"></span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">                   break;</span><br><span class="line">               default :</span><br><span class="line">                       suffix += current;</span><br><span class="line">                       break;</span><br><span class="line">            &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       while (!opStack.isEmpty())&#123;</span><br><span class="line">           suffix += &quot; &quot;+ opStack.pop();</span><br><span class="line">       &#125;</span><br><span class="line">       System.out.println();</span><br><span class="line"></span><br><span class="line">       return suffix;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>
<p>这就是栈的几个应用，你说他简单但是他却很重要。你会发现栈的应用一般都是用在要保存某种状态时的场景，比如网页浏览记录、回退等等。</p>

    </article>
    <!-- 前后页  -->
    <ul class="post-pager">
        
            <li class="next">
                <a href= "/2017/12/29/二叉搜索树/" title= 二叉搜索树 >
                    <span>Next Post</span>
                    <span>二叉搜索树</span>
                </a>
            </li>
        
        
            <li class="previous">
                <a href= "/2017/12/12/高级bash/" title= 高级bash >
                    <span>Previous Post</span>
                    <span>高级bash</span>
                </a>
            </li>
        
    </ul>
    <!-- 评论插件 -->
    <!-- 来必力City版安装代码 -->

<!-- City版安装代码已完成 -->
    
    
<div id="container"></div>
<link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css">
<script src="https://imsun.github.io/gitment/dist/gitment.browser.js"></script>
<script>
    var gitment = new Gitment({
        // id: "栈及栈的应用", // 可选。默认为 location.href
        owner: 'DomBro96',
        repo: 'DomBro96.github.io',
        oauth: {
            client_id: '4a6fa6686f2dd417ed61',
            client_secret: 'cc1f043ee266bc750c481d6a24a98188a185e2eb',
        },
    })
    gitment.render('container')

</script>

    <!--PC版-->

    <!--PC版-->


    
</main>
            <!-- profile -->
            
        </div>
        <footer class="footer footer-unloaded">
    <!-- social  -->
    
    <div class="social">
        
    
        
            
                <a href="mailto:460716809@qq.com" class="iconfont-archer email" title=email ></a>
            
        
    
        
            
                <a href="https://github.com/DomBro96" class="iconfont-archer github" target="_blank" title="github"></a>
            
        
    
        
            
                <a href="https://twitter.com/Bro_Doom" class="iconfont-archer twitter" target="_blank" title="twitter"></a>
            
        
    
        
            
                <a href="https://www.instagram.com/dombro7277/" class="iconfont-archer instagram" target="_blank" title="instagram"></a>
            
        
    
        
            
                <a href="https://leetcode.com/dombro96/" class="iconfont-archer others" target="_blank" title="others"></a>
            
        
    

    </div>
    
    <!-- powered by Hexo  -->
    <div class="copyright">
        <span id="hexo-power">Powered by <a href="https://hexo.io/" target="_blank">Hexo</a></span><span class="iconfont-archer power">&#xe635;</span><span id="theme-info">Theme <a href="https://github.com/fi3ework/hexo-theme-archer" target="_blank">archer</a></span>
    </div>
    <!-- 不蒜子  -->
    
    <div class="busuanzi-container">
        <span id="busuanzi_container_site_pv">Welcome, No. <span id="busuanzi_value_site_pv"></span> visitor.
        </span>
    </div>
    
</footer>
    </div>
    <!-- toc -->
    
    <div class="toc-wrapper">
        <div class="toc-catalog">
            <span class="iconfont-archer catalog-icon">&#xe613;</span><span>CATALOG</span>
        </div>
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#前言"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#What"><span class="toc-number">2.</span> <span class="toc-text">What</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#How"><span class="toc-number">3.</span> <span class="toc-text">How</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#栈的数组实现"><span class="toc-number">3.1.</span> <span class="toc-text">栈的数组实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#栈的链表实现"><span class="toc-number">3.2.</span> <span class="toc-text">栈的链表实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#When"><span class="toc-number">4.</span> <span class="toc-text">When</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#符号平衡"><span class="toc-number">4.1.</span> <span class="toc-text">符号平衡</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#后缀表达式求值"><span class="toc-number">4.2.</span> <span class="toc-text">后缀表达式求值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#中缀表达式转后缀表达式"><span class="toc-number">4.3.</span> <span class="toc-text">中缀表达式转后缀表达式</span></a></li></ol></li></ol>
    </div>
    
    <div class="back-top">&#xe639;</div>
    <div class="sidebar">
    <div class="sidebar-header sidebar-header-show-archive">
        <div class="sidebar-category">
            <span class="sidebar-archive-link"><span class="iconfont-archer">&#xe67d;</span>Archive</span>
            <span class="sidebar-tags-link"><span class="iconfont-archer">&#xe610;</span>Tag</span>
        </div>
    </div>
    <div class="sidebar-content sidebar-content-show-archive">
          <div class="sidebar-archive">
    <!-- 在ejs中将archive按照时间排序 -->
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    <div class="total-archive"> Total : 20 </div>
    
    <div class="post-archive">
    
    
    
    
    <div class="archive-year"> 2018 </div>
    <ul class="year-list">
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">03/11</span><a class="archive-post-title" href= "/2018/03/11/线程/" >线程</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">01/26</span><a class="archive-post-title" href= "/2018/01/26/散列/" >散列</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">01/01</span><a class="archive-post-title" href= "/2018/01/01/happy-new-year/" >别了，2017</a>
        </li>
    
    
    
    
    
        </ul>
    
    <div class="archive-year"> 2017 </div>
    <ul class="year-list">
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">12/29</span><a class="archive-post-title" href= "/2017/12/29/二叉搜索树/" >二叉搜索树</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">12/21</span><a class="archive-post-title" href= "/2017/12/21/栈及栈的应用/" >栈及栈的应用</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">12/12</span><a class="archive-post-title" href= "/2017/12/12/高级bash/" >高级bash</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">12/11</span><a class="archive-post-title" href= "/2017/12/11/Java优雅的处理异常/" >Java优雅的处理异常</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">12/11</span><a class="archive-post-title" href= "/2017/12/11/文件与文件系统的压缩与打包/" >文件与文件系统的压缩与打包</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">12/11</span><a class="archive-post-title" href= "/2017/12/11/vim编辑器/" >vim编辑器</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">12/11</span><a class="archive-post-title" href= "/2017/12/11/Linux文件与文件系统的打包/" >Linux文件与文件系统的打包</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">12/11</span><a class="archive-post-title" href= "/2017/12/11/Java工厂设计模式/" >Java工厂设计模式</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">12/11</span><a class="archive-post-title" href= "/2017/12/11/浅谈token/" >浅谈token</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">12/11</span><a class="archive-post-title" href= "/2017/12/11/磁盘与Linux分区/" >磁盘与Linux分区</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">12/11</span><a class="archive-post-title" href= "/2017/12/11/初识bash/" >初识bash</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">12/11</span><a class="archive-post-title" href= "/2017/12/11/Linux的文件权限与目录配置/" >Linux的文件权限与目录配置</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">12/10</span><a class="archive-post-title" href= "/2017/12/10/文件系统管理/" >文件系统管理</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">12/10</span><a class="archive-post-title" href= "/2017/12/10/Linux文件与目录管理/" >Linux文件与目录管理</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">12/06</span><a class="archive-post-title" href= "/2017/12/06/动态规划-Floyed算法/" >动态规划-Floyed算法</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">12/04</span><a class="archive-post-title" href= "/2017/12/04/堆排序-HeapSort/" >堆排序-HeapSort</a>
        </li>
    
    
    
    
    
        </ul>
    
    <div class="archive-year"> Invalid date </div>
    <ul class="year-list">
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">Invalid date</span><a class="archive-post-title" href= "/2017/12/01/hello-world/" >世界你好</a>
        </li>
    
    </div>
  </div>
        <div class="sidebar-tags">
    <div class="sidebar-tags-name">
    
        <span class="sidebar-tag-name"><a href= "#">JavaSE</a></span>
    
        <span class="sidebar-tag-name"><a href= "#">设计模式</a></span>
    
        <span class="sidebar-tag-name"><a href= "#">Linux</a></span>
    
        <span class="sidebar-tag-name"><a href= "#">casual writing</a></span>
    
        <span class="sidebar-tag-name"><a href= "#">hello world</a></span>
    
        <span class="sidebar-tag-name"><a href= "#">数据结构 Data Structures</a></span>
    
        <span class="sidebar-tag-name"><a href= "#">算法algorithm</a></span>
    
        <span class="sidebar-tag-name"><a href= "#">JavaWeb</a></span>
    
    </div>
    <div class="tag-load-fail" style="display: none; color: #ccc; font-size: 0.6rem;">
    缺失模块。<br/>
    1、请确保node版本大于6.2<br/>
    2、在博客根目录（注意不是archer根目录）执行以下命令：<br/>
    <span style="color: #f75357; font-size: 1rem; line-height: 2rem;">npm i hexo-generator-json-content --save</span><br/>
    3、在根目录_config.yml里添加配置：
    <pre style="color: #888; font-size: 0.6rem;">
jsonContent:
  meta: false
  pages: false
  posts:
    title: true
    date: true
    path: true
    text: false
    raw: false
    content: false
    slug: false
    updated: false
    comments: false
    link: false
    permalink: false
    excerpt: false
    categories: false
    tags: true</pre>
    </div> 
    <div class="sidebar-tag-list"></div>
</div>
    </div>
</div> 
    <script>
    var jsInfo = {
        root: '/'
    }
</script>
    <!-- 不蒜子  -->
    
    <script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    
    <!-- CNZZ统计  -->
    
    </div>
    </body>
</html>


