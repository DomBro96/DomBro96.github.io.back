<!DOCTYPE html>
<html>
    <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" >
    <title>
        
        Spring核心AOP · Dom Blog
        
    </title>
    <link rel="icon" href= http://p0bl99g4r.bkt.clouddn.com/ti.JPG>
    <!-- TODO: 在font-face加载完毕后改变字体  -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/webfont/1.6.28/webfontloader.js"></script>
    <!-- 提前加载place holder  -->
    <style type="text/css">
        @font-face {
            font-family: 'Oswald-Regular';
            src: url(/font/Oswald-Regular.ttf);
        }
    </style>
    <style type="text/css">
        .site-intro-placeholder {
            position: absolute;
            z-index: -2;
            top: 0;
            left: 0px;
            width: calc(100% + 300px);
            height: 100%;
            background: repeating-linear-gradient(-45deg, #444 0, #444 80px, #333 80px, #333 160px);
            background-position: center center;
            transform: translate3d(-226px, 0, 0);
            animation: gradient-move 2.5s ease-out 0s 1;
        }
        @keyframes gradient-move {
        0% {
            transform: translate3d(-226px, 0, 0);
        }
        100% {
            transform: translate3d(0, 0, 0);
        }
    }
</style>
    <link rel="stylesheet" href = /css/style.css?v=20171020 />
    <script src="//cdn.staticfile.org/jquery/3.2.1/jquery.min.js" defer></script>
    
    <script src="/scripts/main.js" defer></script>
    <!-- 百度统计  -->
    
    <!-- 谷歌统计  -->
    
</head>
    
        <body class="post-body">
    
    
<header class="header">

    <div class="header-sidebar-menu">&#xe775;</div>
    <!-- post页的toggle banner  -->
    
    <div class="banner">
            <div class="blog-title">
                <a href="/" >DomBro Studio</a>
            </div>
            <div class="post-title">
                <a href="#" class="post-name">Spring核心AOP</a>
            </div>
    </div>
    
    <a class="home-link" href=/>DomBro Studio</a>
</header>
    <div class="wrapper">
        <div class="site-intro">
    
    <!-- 主页  -->
    
    
    <!-- 404页  -->
            
    <div class="site-intro-img" style="background-image: url(http://p0bl99g4r.bkt.clouddn.com/dog1.JPG)"></div>
    <div class="site-intro-placeholder"></div>
    <div class="site-intro-meta">
        <!-- 标题  -->
        <h1 class="intro-title">
            <!-- 主页  -->
            
            Spring核心AOP
            <!-- 404 -->
            
        </h1>
        <!-- 副标题 -->
        <p class="intro-subtitle">
            <!-- 主页副标题  -->
            
            
            <!-- 404 -->
            
        </p>
        <!-- 文章页meta -->
        
            <!-- 文章页标签  -->
            
                <div class= post-intro-tags >
    
        <a class="post-tag" href="javascript:void(0);" data-href = Spring技术内幕>Spring技术内幕</a>
    
</div>
            
            <div class="post-intro-meta">
                <span class="post-intro-calander iconfont-archer">&#xe676;</span>
                <span class="post-intro-time">2018/04/21</span>
            </div>
        
    </div>
</div>
        <img class="loading" src="/assets/loading.svg" style="display: block; margin: 6rem auto 0 auto; width: 6rem; height: 6rem;" />
        <script>
            var browser = {
                    versions: function () {
                        var u = window.navigator.userAgent;
                        return {
                            userAgent: u,
                            trident: u.indexOf('Trident') > -1, //IE内核
                            presto: u.indexOf('Presto') > -1, //opera内核
                            webKit: u.indexOf('AppleWebKit') > -1, //苹果、谷歌内核
                            gecko: u.indexOf('Gecko') > -1 && u.indexOf('KHTML') == -1, //火狐内核
                            mobile: !!u.match(/AppleWebKit.*Mobile.*/), //是否为移动终端
                            ios: !!u.match(/\(i[^;]+;( U;)? CPU.+Mac OS X/), //ios终端
                            android: u.indexOf('Android') > -1 || u.indexOf('Linux') > -1, //android终端或者uc浏览器
                            iPhone: u.indexOf('iPhone') > -1 || u.indexOf('Mac') > -1, //是否为iPhone或者安卓QQ浏览器
                            iPad: u.indexOf('iPad') > -1, //是否为iPad
                            webApp: u.indexOf('Safari') == -1, //是否为web应用程序，没有头部与底部
                            weixin: u.indexOf('MicroMessenger') == -1, //是否为微信浏览器
                            uc: u.indexOf('UCBrowser') > -1 //是否为android下的UC浏览器
                        };
                    }()
                }

            function fontLoaded(){
                console.log('font loaded');
                if (document.getElementsByClassName('site-intro-meta')) {
                    document.getElementsByClassName('intro-title')[0].classList.add('intro-fade-in');
                    document.getElementsByClassName('intro-subtitle')[0].classList.add('intro-fade-in');
                    var postIntroTags = document.getElementsByClassName('post-intro-tags')[0],
                        postIntroMeat = document.getElementsByClassName('post-intro-meta')[0];
                        if (postIntroTags) {
                            postIntroTags.classList.add('post-fade-in');
                        }
                        if (postIntroMeat) {
                            postIntroMeat.classList.add('post-fade-in');
                        }
                    }
                }
                
            console.log("userAgent:" + browser.versions.userAgent);
            // UC不支持跨域，所以直接显示
            if (browser.versions.uc) {
                console.log("UCBrowser");
                fontLoaded();
            } else {
                WebFont.load({
                    custom: {
                        families: ['Oswald-Regular']
                    },
                    loading: function () {  //所有字体开始加载
                        // console.log('loading');
                    },
                    active: function () {  //所有字体已渲染
                        fontLoaded();
                    },
                    inactive: function () { //字体预加载失败，无效字体或浏览器不支持加载
                        console.log('inactive: timeout');
                        fontLoaded();
                    },
                    timeout: 7000 // Set the timeout to two seconds
                });
            }
        </script>
        <div class="container container-unloaded">
            <main class="main post-page">
    <article class="article-entry">
        <h2 id="Spring的核心-——-AOP"><a href="#Spring的核心-——-AOP" class="headerlink" title="Spring的核心 —— AOP"></a>Spring的核心 —— AOP</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>最近在撸《Spring技术内幕》 这本书(很赞的一本 Spring 源码级别的书)，用作者的话来说 AOP 和 IOC 属于 Spring的核心 部分。但是要明确的是，无论是 IoC 还是 AOP 都只是 Spring 给出众多功能的一种，并不能说 Spring 是单纯的 IoC 或 AOP 框架。今天要说的 AOP 从底层介绍 Spring AOP 在底层是如何基本实现的，看过后会发现 Spring 的作者们真的是太牛逼了。我可能不会按照作者的思路来，通过这本书加上我的理解解开 Spring AOP 那 <del>性感</del> 神秘的面纱。然后，墙裂建议看这篇笔记的人一定不要错过最后的总结。</p>
<h3 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h3><h4 id="啥是-AOP"><a href="#啥是-AOP" class="headerlink" title="啥是 AOP"></a>啥是 AOP</h4><p>在进入 Spring AOP 之前，你得知道 AOP 这玩意儿 不是 Spring 的专利。人家自己是一个专有名词 —— Aspect Oriented Programming 即面向切面编程。md,不是要面向对象编程吗？咋又面向切面编程了？啥叫切面？ 没错，这两个问题是我在开始学 Spring 的时候的问题。</p>
<ul>
<li>面向切面 &amp; AOP 要做什么</li>
</ul>
<p>先抛出一个<strong>个人结论</strong>(注意个人这两个字): 面向切面，就是面向方法。 为什么这么说？得从 AOP 要达到的目的说起。假设有一个场景，你对数据表进行 CRUD 操作，当然这四个操作在不同的方法中。你希望将记录下每次 CRUD 的执行过程及结果，并将其放入日志文件中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/****代码清单 1 向表中插入记录并记录到日志的伪码***/</span><br><span class="line">public void createStudent(Student student)&#123;</span><br><span class="line">       //1.在数据表中插入 student 这条记录</span><br><span class="line">           insert(student);</span><br><span class="line">       //2.将操作结果放入日志中</span><br><span class="line">           intoLog();</span><br><span class="line">   &#125;</span><br><span class="line">仅以插入为例子，RUD 操作省略...</span><br></pre></td></tr></table></figure>
<p>如代码清单1中，将操作结果记录到日志并不是 createStudent 这个方法业务范围，也就是说 intoLog 与业务无关，上述代码太不规范耦合性较大。自然而然想到将 intoLog  操作抽离出来，在每次执行 createStudent() 方法之后，在调用 intoLog 方法，这样就做到了解耦又使代码整洁。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">/****代码清单 2 将 记录到日志操作抽离出来***/</span><br><span class="line">public void createStudent(Student student)&#123;</span><br><span class="line">           insert(student);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">//记录到日志的方法</span><br><span class="line">public viod intoLog()&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//该方法表示上层的调用</span><br><span class="line">public void  doService(Student stu)&#123;</span><br><span class="line">StudentService service = new StudentServiceImp();</span><br><span class="line">LogService log = new LogService();</span><br><span class="line">//在插入后记录到日志中去</span><br><span class="line">service.createStudent(stu);</span><br><span class="line">log.intoLog();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>乍一看这好像也没啥问题，可是这只是一个添加操作，还是要手动的把操作记录到日志中去。如果有更多对标的操作，那岂不是每个操作之后都要手动调用记录日志的方法？ <strong>嫌麻烦是人类进步的阶梯， 要是有一种方式可以达到 调动插入方法 后就自动将结果记录到日志中的效果，岂不快哉？</strong>  换句话说，关注点在 <strong>方法</strong> 上，所要达到的效果也是建立在方法上。<strong>这是面向方法编程</strong> ！</p>
<ul>
<li>对一些名词的解释</li>
</ul>
<p>至于为什么要叫面向切面编程，小孩没娘，说来话长。我们知道 Java 方法的调用到执行记录在 Java 运行时数据区的虚拟机栈中(具体来说是栈帧)，可以抽象的把方法的调用看成是一长串的线性结构。所以当对虚拟机栈中某个方法(无论执行前还是执行后)做一些操作，就好像在这个线性结构上的某个节点(栈帧)横着切了过去！<strong>这就是面向切面编程这个名字的由来，至于这个方法我们叫他横切关注点又叫目标方法，对这个方法做的操作我们叫他对方法的切面增强。持有这个方法的对象我们叫他目标对象。</strong></p>
<h4 id="AOP-实现的核心动态代理"><a href="#AOP-实现的核心动态代理" class="headerlink" title="AOP 实现的核心动态代理"></a>AOP 实现的核心动态代理</h4><p>上面我们知道了 AOP 要做的是对某个横切关注点的增强(翻译成中文就是对目标对象的某方法执行前后做一些操作)，要强调的是我们不是增强可不一定是在方法执行后，也可以是方法执行前，甚至是在方法出异常的情况下都可以对目标对象的方法增强。下面来说一下 AOP 的实现。</p>
<ul>
<li>AOP 的实现</li>
</ul>
<p>那么 AOP 要怎样实现呢？在调用目标方法前后要完成对该方法的增强,很难不让人想到代理模式的动态代理。说白了动态代理不就是在 invoke 方法中对 被代理对象的代理方法进行一个回调吗？还是以记录日志为例子，只要在代理对象的 invoke 方法回调目标方法之后记录至日志就好啦！</p>
<ul>
<li>Java动态代理</li>
</ul>
<p>复习一下　Java 动态代理，毕竟这是 AOP 的核心。Java 代理又分为静态代理和动态代理，两者的思路都是在代理对象的方法中回调被代理对象的方法，这里就不讲静态代理了。动态代理的代理类需要实现 InvocationHandler 的 invoke 方法 。而被代理类则要实现一个接口，这样代理类对象就不必知道代理对象方法的具体实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/***代码清单3 一个动态代理类***/</span><br><span class="line">public class MyProxy implements InvocationHandler &#123;</span><br><span class="line"></span><br><span class="line">    Object target;</span><br><span class="line"></span><br><span class="line">    public Object blind(Object object)&#123;</span><br><span class="line">        //给出被代理对象实例</span><br><span class="line">        target = object;</span><br><span class="line">        //返回一个代理类对象</span><br><span class="line">        return Proxy.newProxyInstance(target.getClass().getClassLoader(),target.getClass().getInterfaces(),this);</span><br><span class="line">    &#125;</span><br><span class="line">//每次调用被代理对象的方法，都会调用 代理对象的 invoke 方法</span><br><span class="line">    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line">        Object returnResult = method.invoke(target,args);</span><br><span class="line">        return returnResult;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Java动态代理 实现的 AOP</li>
</ul>
<p>在代码清单3 的动态代理类的 invoke 方法中，我们可以在执行目标方法前后插入对目标方法的增强。还是以 记录日志为例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">/***代码清单4 动态代理类实现 AOP ***/</span><br><span class="line">public class CreateStudentProxy implements InvocationHandler &#123;</span><br><span class="line"></span><br><span class="line">    Object target;</span><br><span class="line"></span><br><span class="line">    public Object blind(Object object)&#123;</span><br><span class="line"></span><br><span class="line">        target = object;</span><br><span class="line">        return Proxy.newProxyInstance(target.getClass().getClassLoader(),target.getClass().getInterfaces(),this);</span><br><span class="line">    &#125;</span><br><span class="line">//每次调用被代理对象的方法，都会调用 代理对象的 invoke 方法</span><br><span class="line">    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line">        Object returnResult = method.invoke(target,args);</span><br><span class="line">        //在这里调用 intoLog 方法，实现后置增强</span><br><span class="line">        intoLog();</span><br><span class="line">        return returnResult;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//我们假设 createStudent 方法是 StudentServiceImp 实现的 StudentService 方法。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">  StudentServiceImp serviceImp = new StudentServiceImp();</span><br><span class="line">  CreateStudentProxy proxy= new CreateStudentProxy();</span><br><span class="line">  StudentService service = (StudentService)proxy.blind(serviceImp);</span><br><span class="line">  //这会执行 代理类 中的 invoke 方法</span><br><span class="line">  service.createStudent(student);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过代码清单4 这是一个很简单的例子，我们大概其了解了 AOP 增强的原理，就是通过代理对象的 invoke 方法中的回调。其实这个原理还是很好懂得，现在可以揣测到 Spring 也一定是用到代理技术实现 AOP 的。 或许你会说，这也没看见代码量少了啊，反而多写了好多代码。图样图森破！使用代理实现面向切面编程充分做到了解耦，不必担心方法的增强写在方法中这种不规范的写法，也不必每次都手动调用增强方法，只要使用代理的接口调用目标方法就可以了，充分解决了提出的问题! 如果真的要挑毛病，也只能是动态代理使用反射会慢一点点。</p>
<h3 id="Spring-AOP"><a href="#Spring-AOP" class="headerlink" title="Spring AOP"></a>Spring AOP</h3><p>简单了解了 AOP 原理，终于来到了 Spring AOP 。看过这部分，你会发现。哇！写出 Spring AOP 的人，太牛逼了！怎么会有如此精巧的设计方式，简直到了到了代码和设计艺术水平。我一辈子都写不出来这种代码。</p>
<h4 id="通知-切点-通知器"><a href="#通知-切点-通知器" class="headerlink" title="通知 切点 通知器"></a>通知 切点 通知器</h4><p>通知 Advice 、切点 PointCut 、通知器 Advisor 他们既是名词又是 Spring AOP 的三个重要对象。决定了 AOP  切入什么、怎样切入 和 在哪切入 的问题。一起来看一下。</p>
<h5 id="通知-Advice"><a href="#通知-Advice" class="headerlink" title="通知 Advice"></a>通知 Advice</h5><p>那么通知是干啥的呢？通知定义了在连接点中做些什么，为 切面增强织 入提供接口。(连接点就是我们上面说的方法也即横切关注点。Spring 中的一些名词可能会不太一致，但我们不在这里纠结) 也就是说 Advice 定义了切入内容以及怎样切入。</p>
<p><em>注：要说明一点的是 Advice 不是 Spring 中定义的接口，而是 AOP 联盟定义的。不明觉厉。当然这里也只当个了解就行了。</em></p>
<ul>
<li>切入什么 &amp; 如何切入</li>
</ul>
<p>从 Advice 的定义，可以看出我们可以在 Advice 中定义切面的增强。例如，可以把上面举的记录日志操作定义到 Advice 中。 至于如何定义到 Advice 这就涉及到了 如何切入的问题。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/***代码清单5 Advice 接口****/</span><br><span class="line">public interface Advice &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们看到 Advice 接口空空如也，啥都没有。没关系 Spring 通过扩展 Advice ，给出了更多的通知类型，供使用者选择。比如我们熟悉的前置通知，后置通知，环绕通知，异常通知… 底层原理都是实现了这些具体的通知的方法而已。</p>
<p><img src="http://p0bl99g4r.bkt.clouddn.com/spring_aop_advice.PNG" alt=""></p>
<p><em>图 1 Advice 类继承关系</em></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/***代码清单6 常见的几种具体通知***/</span><br><span class="line">//前置通知</span><br><span class="line">public interface MethodBeforeAdvice extends BeforeAdvice &#123;</span><br><span class="line">   //我们看到 Method 参数，就是连接点</span><br><span class="line">    void before(Method var1, Object[] var2, Object var3) throws Throwable;</span><br><span class="line">&#125;</span><br><span class="line">//后置通知</span><br><span class="line">public interface AfterReturningAdvice extends AfterAdvice &#123;</span><br><span class="line">    void afterReturning(Object var1, Method var2, Object[] var3, Object var4) throws Throwable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以根据通知的名称和方法名 就可以得出 如何切入 这个问题，例如 MethodBeforeAdvice 中的 before　方法，就是以前置通知的方式切入，至于切入什么据要看你在 before 中定义的操作了。</p>
<h4 id="切点-关注点-Pointcut"><a href="#切点-关注点-Pointcut" class="headerlink" title="切点(关注点) Pointcut"></a>切点(关注点) Pointcut</h4><p>Pointcut 决定了 Advice 通知应该作用于那个连接点，也就是作用于哪个方法。也就是 在哪切入这个问题。注意的是，我在刚开始的时候以为 Pointcut 只可能是一个方法，其实不然。Pointcut 定义的是需要增强方法的集合，这些集合的选取按照一定规则生成。例如，通过正则表达式或者编程式声明 切入点的时候我们有时候会让一个 通知 增强不止一个 方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/***代码清单7 Pointcut 切点****/</span><br><span class="line">public interface Pointcut &#123;</span><br><span class="line">    Pointcut TRUE = TruePointcut.INSTANCE;</span><br><span class="line"></span><br><span class="line">    ClassFilter getClassFilter();</span><br><span class="line"></span><br><span class="line">    MethodMatcher getMethodMatcher();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们看到 pointcut 需要返回一个 MethodMather 对象。 Pointcut 就是通过这个 MethodMather 来判断当前连接点是否匹配的。也就是是说有这个 MethodMather 来判断是否要对当前调用的方法应用配置好的 Advice 通知。<br>Pointcut 也有很多子类伙子接口，比较常见的是使用 正则表达式 切点 JdkRegexpMethodPointcut,该切点通过匹配正则表达式来匹配连接点; 以及 NameMatchMethodPointcut ，他通过 切点的方法</p>
<h4 id="通知器-Advisor"><a href="#通知器-Advisor" class="headerlink" title="通知器 Advisor"></a>通知器 Advisor</h4><p>事实上，我们通过 通知 和 切点 这这俩 在表面上看起来已经 AOP 的必要条件就已经满足了。那么就需要另一个对象 通知器 Advisor 将这二者结合起来。 通过这个通知器，可以定义应该使用那个通知并在那个关注点使用它。体现了 Spring 良好的封装性。Advisor 为 使用 IoC 容器配置 AOP 应用，提供了便利( 设置 bean property 就可以了)。<br>Advisor 是一个接口，默认的 Advisor 是 DefaultPointcutAdvisor 。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">/***代码清单8 默认的 Advisor ***/</span><br><span class="line">public class DefaultPointcutAdvisor extends AbstractGenericPointcutAdvisor implements Serializable &#123;</span><br><span class="line">    private Pointcut pointcut;</span><br><span class="line">    //注意，这里的关注点用单例模式获取</span><br><span class="line">    public DefaultPointcutAdvisor() &#123;</span><br><span class="line">        this.pointcut = Pointcut.TRUE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public DefaultPointcutAdvisor(Advice advice) &#123;</span><br><span class="line">        this(Pointcut.TRUE, advice);</span><br><span class="line">    &#125;</span><br><span class="line">    //初始化 Pointcut 和 Advice</span><br><span class="line">    public DefaultPointcutAdvisor(Pointcut pointcut, Advice advice) &#123;</span><br><span class="line">        this.pointcut = Pointcut.TRUE;</span><br><span class="line">        this.pointcut = pointcut;</span><br><span class="line">        this.setAdvice(advice);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setPointcut(Pointcut pointcut) &#123;</span><br><span class="line">        this.pointcut = pointcut != null ? pointcut : Pointcut.TRUE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Pointcut getPointcut() &#123;</span><br><span class="line">        return this.pointcut;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return this.getClass().getName() + &quot;: pointcut [&quot; + this.getPointcut() + &quot;]; advice [&quot; + this.getAdvice() + &quot;]&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Spring-AOP-设计与实现"><a href="#Spring-AOP-设计与实现" class="headerlink" title="Spring AOP 设计与实现"></a>Spring AOP 设计与实现</h4><p>现在我们知道了 Spring 是通过 Advisor 通知器 对关注点进行切面增强的。然而知道这个还远远不够，Advisor 只是给了一个大概的轮廓。Spring AOP 要做到的效果是调用目标对象的关注点方法，就会将对应的增强效果显示出来 ，显然，为了解决这个问题 Spring AOP 同样是靠动态代理实现的。这里可以猜测一下下:</p>
<p><href id="q1">猜测 1 : 由于 Advisor 可以知道关注点和通知，那么 Spring　AOP 的 代理类的 代理方法一定会使用到 Advisor 。</href></p>
<h5 id="Spring-AOP-的设计分析"><a href="#Spring-AOP-的设计分析" class="headerlink" title="Spring AOP 的设计分析"></a>Spring AOP 的设计分析</h5><p>在介绍 AOP 的时候介绍到实现 AOP 的核心是动态代理，即通过 代理类 实现切面的织入。同样 Spring 也是如此，Spring 的核心技术就是 JDK动态代理。</p>
<blockquote>
<p>以动态代理技术为基础，设计出一系列 AOP 的横切实现，比如 前置通知、返回通知，异常通知等。同时 Spring 还提供一些列的 Pointcut 来匹配切入点。 ——《Spring技术内幕》</p>
</blockquote>
<p>使用 Spring　AOP 是一件简单的事，只需要配置相关的 Bean 定义即可。然而为了让 Spring AOP 起作用，需要完成一系列的步骤。比如 为目标对象建立 代理，启动代理对象的拦截器完成横切面(增强切入点) 的织入。</p>
<h5 id="Spring-AOP-的-重点研究对象-ProxyFactoryBean"><a href="#Spring-AOP-的-重点研究对象-ProxyFactoryBean" class="headerlink" title="Spring AOP 的 重点研究对象 ProxyFactoryBean"></a>Spring AOP 的 重点研究对象 ProxyFactoryBean</h5><ul>
<li>Spring AOP 的应用类</li>
</ul>
<p>Spring AOP 为我们准备了三个 AOP 的应用类，分别是 AspectJProxyFactory、ProxyFactoryBean、ProxyFactory 。对于使用 Spring AOP 的应用，以上三个类都提供了对 AOP 功能的封装。区别在于 AspectJProxyFactory 集成了 Spring 和 AspectJ 的作用；ProxyFactoryBean 可以在 IoC 容器中完成声明式配置 AOP 功能，而使用 ProxyFactory 则需要编程式的使用 AOP 功能。 <strong>明眼人一看就知道，那肯定是结合了 IoC 和 AOP 的 ProxyFactoryBean 更有研究的价值</strong>！</p>
<p><img src="http://p0bl99g4r.bkt.clouddn.com/spring_aop_proxyfactorybean.PNG" alt=""></p>
<p><em>图2 ProxyFactoryBean 的类继承关系</em></p>
<p>在 图2 中，有几个要注意的类</p>
<p>1.ProxyConfig 是一个数据基类，这个基类为 ProxyFactoryBean 提供了配置属性。<br>2.AdvisedSupport 的实现中，封装了 AOP 对通知的和通知器的相关操作。</p>
<ul>
<li>配置 ProxyFactoryBean</li>
</ul>
<p>前面提到了，ProxyFactoryBean 需要在 IOC 容器中进行配置，ProxyFactoryBean 是最灵活的一种 Spring AOP 应用。我们要从这里为入口了解一下。首先了解，在 XML 中配置 ProxyFactoryBean，配置 ProxyFactoryBean 要经过一系列步骤:</p>
<p>1.定义使用的通知器 Advisor，这个通知器作为一个 Bean 来定义。很重要的一点是，<strong>这个通知器的实现定义了需要对目标对象进行增强的切面行为，也就是 Advice</strong>。<br>2.定义一个 ProxyFactoryBean ，同样把他作为 Bean 来定义，是封装 AOP 主要功能的类。 在配置 ProxyFactoryBean 时，需要设定与 AOP 实现相关的重要属性，比如 proxyInterface 、interceptorName 和 target 等。interceptorName 往往设置为 Advisor 通知器，你可能会纠结这不是拦截器的意思吗？<strong>实际上这些通知器在 ProxyFactoryBean 的 AOP 配置下,是通过使用代理对象的拦截器机制起作用的</strong>。 请记住这句话。<br>3.定义 target 属性，作为 target 属性注入的 Bean。很明显，表示目标对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/***代码清单 9 在 XML 中配置 ProxyFactoryBean ***/</span><br><span class="line">    &lt;bean id=&quot;advisor&quot; class=&quot;cn.dombro.spring.aop.MyAdvisor&quot;/&gt;</span><br><span class="line">    &lt;bean id=&quot;aop_bean&quot; class=&quot;org.springframework.aop.framework.ProxyFactoryBean&quot;&gt;</span><br><span class="line">        &lt;property name=&quot;proxyInterfaces&quot; value=&quot;cn.dombro.spring.aop.xml.Counter&quot;/&gt;</span><br><span class="line">        &lt;property name=&quot;target&quot;&gt;</span><br><span class="line">            &lt;bean class=&quot;cn.dombro.spring.aop.xml.CounterImple&quot;/&gt;</span><br><span class="line">        &lt;/property&gt;</span><br><span class="line">        &lt;property name=&quot;interceptorNames&quot;&gt;</span><br><span class="line">            &lt;list&gt;&lt;value&gt;advisor&lt;/value&gt;&lt;/list&gt;</span><br><span class="line">        &lt;/property&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br></pre></td></tr></table></figure>
<h4 id="ProxyFactoryBean-生成-AopProxy"><a href="#ProxyFactoryBean-生成-AopProxy" class="headerlink" title="ProxyFactoryBean 生成 AopProxy"></a>ProxyFactoryBean 生成 AopProxy</h4><p>前面说到 Spring AOP 其作用的第一件事就是 为目标对象生成代理。那么 ProxyFactoryBean 是如何生成代理的呢？ProxyFactoryBean 中，需要为 target 目标对象生成 Proxy 代理对象，从而为 AOP 横切面的编织做好准备。</p>
<ul>
<li>两种生成代理对象的方式</li>
</ul>
<p>ProxyFactoryBean 有两种生成代理对象 AopProxy 的方式一种是使用JDK动态代理，另一种是使用 CGLIB。你可以把这句话当成结论记住，可以想一下为什么要用两种方式？答案很简单，JDK 的动态代理 只能代理那些 实现某个接口的目标对象，而 CGLIB 可以为没有实现接口的目标对象生成代理。</p>
<p><img src="http://p0bl99g4r.bkt.clouddn.com/spring_aop_aoproxy.PNG" alt=""></p>
<p><em>图3 两种代理都实现了 AopProxy接口</em></p>
<ul>
<li>AopProxy 的生成过程</li>
</ul>
<p>由于 ProxyFactoryBean 实现了 FactoryBean 接口，而从 FactoryBean 中获取对象是以 getObject() 方法，作为入口完成的。所以理所当然，如果想通过 ProxyFactoryBean 获得 AopProxy 对象就一定会从 ProxyFactoryBean 实现的 getObject() 方法中寻找。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/***代码清单 10 ProxyFactoryBean 的 getObject ****/</span><br><span class="line">public Object getObject() throws BeansException &#123;</span><br><span class="line">    //这个方法对 ProxyFactoryBean 的 Advisor 链进行初始化</span><br><span class="line">    this.initializeAdvisorChain();</span><br><span class="line">    //这里针对单例也就是默认的目标对象生成代理对象</span><br><span class="line">    if (this.isSingleton()) &#123;</span><br><span class="line">        return this.getSingletonInstance();</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        if (this.targetName == null) &#123;</span><br><span class="line">            this.logger.warn(&quot;Using non-singleton proxies with singleton targets is often undesirable. Enable prototype proxies by setting the &apos;targetName&apos; property.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        //这里针对非单例的目标对象生成代理对象</span><br><span class="line">        return this.newPrototypeInstance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从代码清单10 中可以看到，getObject() 方法做了两个非常重要的事情。</p>
<ol>
<li><p>通过 initializeAdvisorChain()方法，将配置在 ProxyFactoryBean 的 Advisor 链进行初始化。<strong>这个初始化是把从 IoC 容器中获取到的 通知器 添加到 拦截器链中</strong>。这里简单记忆有个印象即可。</p>
</li>
<li><p>对目标对象生成代理对象 AopProxy ，针对目标对象的单例或和单例对应生成单件代理和非单件代理的方法。我们主要研究单件代理生成方式 getSingletonInstance();</p>
</li>
</ol>
<ul>
<li>getSingletonInstance() 生成单件代理对象</li>
</ul>
<href id="z1">

<p>如上，ProxyFactoryBean 通过 在 getObject() 方法中调用　getSingletonInstance() 方法，为目标对象生成一个单例的代理。我们现在走进 getSingletonInstance 看一下这个代理是如何生成的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">/***代码清单11 getSingletonInstance 生成单例代理对象 ***/</span><br><span class="line">private synchronized Object getSingletonInstance() &#123;</span><br><span class="line">    if (this.singletonInstance == null) &#123;</span><br><span class="line">        this.targetSource = this.freshTargetSource();</span><br><span class="line">        if (this.autodetectInterfaces &amp;&amp; this.getProxiedInterfaces().length == 0 &amp;&amp; !this.isProxyTargetClass()) &#123;</span><br><span class="line">          //根据 AOP 框架判断需要代理的接口</span><br><span class="line">            Class&lt;?&gt; targetClass = this.getTargetClass();</span><br><span class="line">            if (targetClass == null) &#123;</span><br><span class="line">                throw new FactoryBeanNotInitializedException(&quot;Cannot determine target class for proxy&quot;);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            this.setInterfaces(ClassUtils.getAllInterfacesForClass(targetClass, this.proxyClassLoader));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        super.setFrozen(this.freezeProxy);</span><br><span class="line">        //2.这里使用 ProxyFactory 来生成 代理对象</span><br><span class="line">        this.singletonInstance = this.getProxy(this.createAopProxy());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return this.singletonInstance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//真正生成代理对象是使用 AopProxy.getProxy实现的 &lt;- 这句话很重要哦</span><br><span class="line">protected Object getProxy(AopProxy aopProxy) &#123;</span><br><span class="line">       return aopProxy.getProxy(this.proxyClassLoader);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>看上去貌似也没那么难，注意代码清单11 中的  17 行 通过 getProxy() 方法来生成代理对象，而其参数 是由 createAopProxy 返回的 AopProxy 对象。这里面又有什么玄机呢？createAopProxy 是在 ProxyCreatorSupport 定义，返回一个 AopProxy。只好点开 createAopProxy</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/***代码清单12 ProxyCreatorSupport 中的  createAopProxy ***/</span><br><span class="line">protected final synchronized AopProxy createAopProxy() &#123;</span><br><span class="line">    if (!this.active) &#123;</span><br><span class="line">        this.activate();</span><br><span class="line">    &#125;</span><br><span class="line">    //通过调用 AopProxyFactory 的 createAopProxy 方法得到 AopProxy 对象</span><br><span class="line">    return this.getAopProxyFactory().createAopProxy(this);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于代理对象的具体生成是 AopProxy 而生成，但 AopProxy 又有两种实现，JdkDynamicAopProxy 和 Cglib2AopProxy 两种方式。所以 ProxyCreatorSupport 的 createAopProxy 方法，会根据传入的 AdvisedSupport(这里传入this 是因为 ProxyCreatorSupport 实现了 AdvisedSupport) 来决定使用 JDK动态代理 还是 CGLIB 的方式生成代理。</p>
<ul>
<li>小结</li>
</ul>
<p>我觉的看到这你一定是蒙圈了，我用一句话总结，ProxyFactoryBean 生成代理对象由 getObject 方法中调用的 getSingletonInstance 方法为入口。而真正生成代理对象的是 AopProxy 的 getProxy 方法 ，具体使用哪种 AopProxy 生成 代理对象由 ProxyFactoryBean 的父类 AdvisedSupport 决定。</p>
<h4 id="JdkDynamicAopProxy-和-Cglib2AopProxy"><a href="#JdkDynamicAopProxy-和-Cglib2AopProxy" class="headerlink" title="JdkDynamicAopProxy 和 Cglib2AopProxy"></a>JdkDynamicAopProxy 和 Cglib2AopProxy</h4><p>上面说到 ProxyFactoryBean 会从 getObject 方法中的 getSingletonInstance 方法 成两种 AopProxy ，即 图3 中的 JdkDynamicAopProxy 和 Cglib2AopProxy 。其中 JdkDynamicAopProxy 使用动态代理为接口类型(实现接口类型)目标对象生成代理对象，而 Cglib2AopProxy 则通过第三方库可以为非接口类型目标对象生成代理对象。不过通过上一节我们知道，AopProxy 生成代理对象是通过 getProxy() 方法，<strong>所以无论  JdkDynamicAopProxy 还是 Cglib2AopProxy 我们只需要查看 getProxy() 中的代码就可以知道代理对象的生成过程了</strong>。</p>
<h5 id="代理对象的生成"><a href="#代理对象的生成" class="headerlink" title="代理对象的生成"></a>代理对象的生成</h5><ul>
<li>JdkDynamicAopProxy 生成 代理对象</li>
</ul>
<p>首先来看一下 基于 动态代理的 JdkDynamicAopProxy 是如何生成代理对象的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/***代码清单13 JdkDynamicAopProxy 生成代理对象***/</span><br><span class="line">public Object getProxy(ClassLoader classLoader) &#123;</span><br><span class="line">    if (logger.isDebugEnabled()) &#123;</span><br><span class="line">        logger.debug(&quot;Creating JDK dynamic proxy: target source is &quot; + this.advised.getTargetSource());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Class&lt;?&gt;[] proxiedInterfaces = AopProxyUtils.completeProxiedInterfaces(this.advised, true);</span><br><span class="line">    this.findDefinedEqualsAndHashCodeMethods(proxiedInterfaces);</span><br><span class="line">    //生成代理对象</span><br><span class="line">    return Proxy.newProxyInstance(classLoader, proxiedInterfaces, this);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以看到 JdkDynamicAopProxy 和 代码清单3 中的自定义动态代理类中的 blind 几乎是一样的。还可以得出一个结论 JdkDynamicAopProxy 一定实现了 InvocationHandler 接口,对，就是通过那个 this 。</p>
<ul>
<li>Cglib2AopProxy 生成代理对象</li>
</ul>
<p>具体参见 Cglib2AopProxy.getProxy() 方法，CGLIB 原理我也不是很懂，不敢瞎比比..(T_ T)。</p>
<h5 id="Spring-AOP-拦截器的调用"><a href="#Spring-AOP-拦截器的调用" class="headerlink" title="Spring AOP 拦截器的调用"></a>Spring AOP 拦截器的调用</h5><p>首先，一句结论 : 在 Spring AOP 通过 JdkDynamicAopProxy 或 Cglib2AopProxy 生成 代理对象的时候，相关的拦截器已经配置到代理对象中去了，拦截器在代理对象中起的作用是通过对这些方法的回调完成的。上述两种 AopProxy 拦截的方式是不一样的。</p>
<ul>
<li>拦截器、拦截器链</li>
</ul>
<p>关于什么是拦截器，实际上拦截器 就是 Spring AOP 将 Advisor 配置给代理对象起到拦截目标方法方法的对象。也就是说代理对象通过拦截器知道要对目标对象的哪些目标方法进行哪种通知。<strong>对目标方法的增强就是通过拦截器完成的</strong>。这句话可以当做结论记下来。<strong>拦截器链，就是配置的所有拦截器的集合</strong>。</p>
<h6 id="AopProxy-的拦截"><a href="#AopProxy-的拦截" class="headerlink" title="AopProxy 的拦截"></a>AopProxy 的拦截</h6><p>拦截，拦截什么呢？当然是拦截目标方法，实际上这个拦截的过程就是面向切面的过程。还记的原生代理类中我们在哪里对目标方法进行拦截吗？invoke 方法 。Spring  的 JdkDynamicAopProxy 也是在 invoke 方法中实现的拦截，但复杂得多。</p>
<ul>
<li>JdkDynamicAopProxy 的 invoke 拦截</li>
</ul>
<p>如果使用 JdkDynamicAopProxy 生成代理对象，则需要实现 InvocationHandler 的 invoke 方法设置拦截器的回调。这和代码清单3 中的原生 代理类是一样的。</p>
<href id="z2">

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">/***代码清单14 JdkDynamicAopProxy 的 invoke 回调***/</span><br><span class="line">public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line">        Object oldProxy = null;</span><br><span class="line">        boolean setProxyContext = false;</span><br><span class="line">        TargetSource targetSource = this.advised.targetSource;</span><br><span class="line">        Class&lt;?&gt; targetClass = null;</span><br><span class="line">        Object target = null;</span><br><span class="line"></span><br><span class="line">        Boolean var10;</span><br><span class="line">        try &#123;</span><br><span class="line">            if (this.equalsDefined || !AopUtils.isEqualsMethod(method)) &#123;</span><br><span class="line">                if (!this.hashCodeDefined &amp;&amp; AopUtils.isHashCodeMethod(method)) &#123;</span><br><span class="line">                    Integer var20 = this.hashCode();</span><br><span class="line">                    return var20;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                if (method.getDeclaringClass() == DecoratingProxy.class) &#123;</span><br><span class="line">                    Class var18 = AopProxyUtils.ultimateTargetClass(this.advised);</span><br><span class="line">                    return var18;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                Object retVal;</span><br><span class="line">                if (!this.advised.opaque &amp;&amp; method.getDeclaringClass().isInterface() &amp;&amp; method.getDeclaringClass().isAssignableFrom(Advised.class)) &#123;</span><br><span class="line">                    retVal = AopUtils.invokeJoinpointUsingReflection(this.advised, method, args);</span><br><span class="line">                    return retVal;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                if (this.advised.exposeProxy) &#123;</span><br><span class="line">                    oldProxy = AopContext.setCurrentProxy(proxy);</span><br><span class="line">                    setProxyContext = true;</span><br><span class="line">                &#125;</span><br><span class="line">                //1.得到目标对象</span><br><span class="line">                target = targetSource.getTarget();</span><br><span class="line">                if (target != null) &#123;</span><br><span class="line">                    targetClass = target.getClass();</span><br><span class="line">                &#125;</span><br><span class="line">                //1.通过 AdvisedSupport 获取目标方法的拦截器链。</span><br><span class="line">                List&lt;Object&gt; chain = this.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass);</span><br><span class="line">                //2.如果拦截器链是空的，则直接调用目标方法</span><br><span class="line">                if (chain.isEmpty()) &#123;</span><br><span class="line">                    Object[] argsToUse = AopProxyUtils.adaptArgumentsIfNecessary(method, args);</span><br><span class="line">                    //这里是对目标方法的调用</span><br><span class="line">                    retVal = AopUtils.invokeJoinpointUsingReflection(target, method, argsToUse);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                //3.如果有拦截器链，则将代理对象，目标对象，目标方法，方法参数，</span><br><span class="line">                //以及拦截器链封装为一个 MethodInvocation 对象</span><br><span class="line">                    MethodInvocation invocation = new ReflectiveMethodInvocation(proxy, target, method, args, targetClass, chain);</span><br><span class="line">                //4.invocation.proceed 方法会沿着拦截器链向前执行      </span><br><span class="line">                    retVal = invocation.proceed();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                Class&lt;?&gt; returnType = method.getReturnType();</span><br><span class="line">                if (retVal != null &amp;&amp; retVal == target &amp;&amp; returnType != Object.class &amp;&amp; returnType.isInstance(proxy) &amp;&amp; !RawTargetAccess.class.isAssignableFrom(method.getDeclaringClass())) &#123;</span><br><span class="line">                    retVal = proxy;</span><br><span class="line">                &#125; else if (retVal == null &amp;&amp; returnType != Void.TYPE &amp;&amp; returnType.isPrimitive()) &#123;</span><br><span class="line">                    throw new AopInvocationException(&quot;Null return value from advice does not match primitive return type for: &quot; + method);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                Object var13 = retVal;</span><br><span class="line">                return var13;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            var10 = this.equals(args[0]);</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            if (target != null &amp;&amp; !targetSource.isStatic()) &#123;</span><br><span class="line">                targetSource.releaseTarget(target);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (setProxyContext) &#123;</span><br><span class="line">                AopContext.setCurrentProxy(oldProxy);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return var10;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>代码清14 的重点有三处:</p>
<ol>
<li>当目标方法不存在拦截器链时,将直接调用目标方法。这个目标方法的调用是 <code>AopUtils.invokeJoinpointUsingReflection()</code>  方法。</li>
<li>拦截器链是通过 AdvisedSupport.getInterceptorsAndDynamicInterceptionAdvice()方法得到的，传入的参数是 目标方法 和 一个类加载器。</li>
<li>将拦截器链、目标方法、目标对象、目标方法参数作为参数，构造出一个 ReflectiveMethodInvocation 对象，在执行 MethodInvocation.proceed 方法，这个方法会按照拦截器链的方向向前执行。</li>
</ol>
<p>以上三个发现的结论是很重要的。</p>
<ul>
<li>Cglib2AopProxy 的 intercept 拦截</li>
</ul>
<p>Cglib2AopProxy 对 目标方法的拦截和 JdkDynamicAopProxy 的方式十分类似。这里就只说下区别：</p>
<ol>
<li>Cglib2AopProxy 的拦截器回调发生在 intercept 方法中。</li>
<li>Cglib2AopProxy 对拦截器链的调用通过构造 CglibMethodInvocation 对象完成的。</li>
</ol>
<h6 id="拦截器链的调用"><a href="#拦截器链的调用" class="headerlink" title="拦截器链的调用"></a>拦截器链的调用</h6><p>Spring AOP 对目标对象的增强的实现封装在拦截器链中，有一个个具体的拦截器来完成。那么究竟是如何实现的呢？通过上一节我们知道，无论是 JdkDynamicAopProxy 还是 Cglib2AopProxy 对拦截器链的调用都是殊途同归，通过 ReflectiveMethodInvocation 对象的 proceed 方法。一起来看一下：</p>
<p><href id="h15"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">/***代码清单 15 ReflectiveMethodInvocation 的 proceed 方法***/</span><br><span class="line">public Object proceed() throws Throwable &#123;</span><br><span class="line">    //0.如果拦截器链中的迭代器调用完毕，这里开始调用目标方法</span><br><span class="line">    if (this.currentInterceptorIndex == this.interceptorsAndDynamicMethodMatchers.size() - 1) &#123;</span><br><span class="line">        return this.invokeJoinpoint();</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">       //1.从拦截器链中第一个拦截器开始</span><br><span class="line">        Object interceptorOrInterceptionAdvice = this.interceptorsAndDynamicMethodMatchers.get(++this.currentInterceptorIndex);</span><br><span class="line">        if (interceptorOrInterceptionAdvice instanceof InterceptorAndDynamicMethodMatcher) &#123;</span><br><span class="line">          //2. 对拦截器进行动态判断，如果和定义的 Pointcut 一致，那么 Advice 将会执行。</span><br><span class="line">          //如果不匹配，那么递归调用 proceed， 直到所有拦截器都被运行过为止。    </span><br><span class="line">            InterceptorAndDynamicMethodMatcher dm = (InterceptorAndDynamicMethodMatcher)interceptorOrInterceptionAdvice;</span><br><span class="line">            return dm.methodMatcher.matches(this.method, this.targetClass, this.arguments) ? dm.interceptor.invoke(this) : this.proceed();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return ((MethodInterceptor)interceptorOrInterceptionAdvice).invoke(this);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></href></p>
<p>以上就是整个拦截器目标方法被调用的过程。有点神奇耶，我们看到ReflectiveMethodInvocation.proceed 方法会遍历拦截器链里面的所有拦截器，<strong>如果拦截器中切入点和当前要调用的匹配就执行拦截器的 invoke 方法。如果拦截器中的切入点和当前方法不匹配，则按照 ReflectiveMethodInvocation 的 proceed 方法，继续下一个拦截器</strong>。在下面会介绍拦截器的 inbvoke 方法。当所有拦截器都遍历完了，就执行目标方法！多么精巧的设计。</p>
<h5 id="拦截器链的生成"><a href="#拦截器链的生成" class="headerlink" title="拦截器链的生成"></a>拦截器链的生成</h5><p>上面直接讲了 拦截器链的调用 而跳过了 拦截器的生成这部分。这里来简单补充一下。</p>
<ol>
<li>首先拦截器链是由 AdvisedSupport.getInterceptorsAndDynamicInterceptionAdvice() 方法得到的(上面提到了)。</li>
<li>而在上述方法中生成 拦截器链 则是由配置好的生成拦截器链的工厂 DefaultAdvisorChainFactory. getInterceptorsAndDynamicInterceptionAdvice() 生成。拦截器工厂生成拦截器则需要 通知器链。一起来看一下</li>
</ol>
<href id="z4">

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">/***代码清单16 DefaultAdvisorChainFactory 生成拦截器链***/</span><br><span class="line">public List&lt;Object&gt; getInterceptorsAndDynamicInterceptionAdvice(Advised config, Method method, Class&lt;?&gt; targetClass) &#123;</span><br><span class="line">    //1.首先通过 config 得到通知器链</span><br><span class="line">    List&lt;Object&gt; interceptorList = new ArrayList(config.getAdvisors().length);</span><br><span class="line">    Class&lt;?&gt; actualClass = targetClass != null ? targetClass : method.getDeclaringClass();</span><br><span class="line">    boolean hasIntroductions = hasMatchingIntroductions(config, actualClass);</span><br><span class="line">    AdvisorAdapterRegistry registry = GlobalAdvisorAdapterRegistry.getInstance();</span><br><span class="line">    Advisor[] var8 = config.getAdvisors();</span><br><span class="line">    int var9 = var8.length;</span><br><span class="line"></span><br><span class="line">    for(int var10 = 0; var10 &lt; var9; ++var10) &#123;</span><br><span class="line">        Advisor advisor = var8[var10];</span><br><span class="line">        MethodInterceptor[] interceptors;</span><br><span class="line">        if (advisor instanceof PointcutAdvisor) &#123;</span><br><span class="line">            PointcutAdvisor pointcutAdvisor = (PointcutAdvisor)advisor;</span><br><span class="line">            if (config.isPreFiltered() || pointcutAdvisor.getPointcut().getClassFilter().matches(actualClass)) &#123;</span><br><span class="line">              //2.看到拦截器是通过 AdvisorAdapterRegistry 对象的 getInterceptors 方法让针对通知器</span><br><span class="line">              //生成拦截器的。&lt;- 这个方法很重要！</span><br><span class="line">                interceptors = registry.getInterceptors(advisor);</span><br><span class="line">                MethodMatcher mm = pointcutAdvisor.getPointcut().getMethodMatcher();</span><br><span class="line">                if (MethodMatchers.matches(mm, method, actualClass, hasIntroductions)) &#123;</span><br><span class="line">                    if (mm.isRuntime()) &#123;</span><br><span class="line">                        MethodInterceptor[] var15 = interceptors;</span><br><span class="line">                        int var16 = interceptors.length;</span><br><span class="line"></span><br><span class="line">                        for(int var17 = 0; var17 &lt; var16; ++var17) &#123;</span><br><span class="line">                            MethodInterceptor interceptor = var15[var17];</span><br><span class="line">                            interceptorList.add(new InterceptorAndDynamicMethodMatcher(interceptor, mm));</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        interceptorList.addAll(Arrays.asList(interceptors));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else if (advisor instanceof IntroductionAdvisor) &#123;</span><br><span class="line">            IntroductionAdvisor ia = (IntroductionAdvisor)advisor;</span><br><span class="line">            if (config.isPreFiltered() || ia.getClassFilter().matches(actualClass)) &#123;</span><br><span class="line">                interceptors = registry.getInterceptors(advisor);</span><br><span class="line">                interceptorList.addAll(Arrays.asList(interceptors));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            Interceptor[] interceptors = registry.getInterceptors(advisor);</span><br><span class="line">            interceptorList.addAll(Arrays.asList(interceptors));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return interceptorList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实际上，在代码清单16 中，最值得研究的就是利用 AdvisorAdapterRegistry 对象的 getInterceptors ，即 registry.getInterceptors(advisor) 方法 ，从通知器得到拦截器。这里用到了适配器模式。下面会详细讲解。值得注意的是，我们看到拦截器链的生成</p>
<ol>
<li>通知器链从哪里生成的？还记得 ProxyFactoryBean 的 getObject 中的 initializeAdvisorChain() 方法吗? 一起来看一下:</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">/***代码清单 17 ProxyFactoryBean 的初始化 通知器链***/</span><br><span class="line">private synchronized void initializeAdvisorChain() throws AopConfigException, BeansException &#123;</span><br><span class="line">       if (!this.advisorChainInitialized) &#123;</span><br><span class="line">           if (!ObjectUtils.isEmpty(this.interceptorNames)) &#123;</span><br><span class="line">               if (this.beanFactory == null) &#123;</span><br><span class="line">                   throw new IllegalStateException(&quot;No BeanFactory available anymore (probably due to serialization) - cannot resolve interceptor names &quot; + Arrays.asList(this.interceptorNames));</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               if (this.interceptorNames[this.interceptorNames.length - 1].endsWith(&quot;*&quot;) &amp;&amp; this.targetName == null &amp;&amp; this.targetSource == EMPTY_TARGET_SOURCE) &#123;</span><br><span class="line">                   throw new AopConfigException(&quot;Target required after globals&quot;);</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               String[] var1 = this.interceptorNames;</span><br><span class="line">               int var2 = var1.length;</span><br><span class="line"></span><br><span class="line">               for(int var3 = 0; var3 &lt; var2; ++var3) &#123;</span><br><span class="line">                   String name = var1[var3];</span><br><span class="line">                   if (this.logger.isTraceEnabled()) &#123;</span><br><span class="line">                       this.logger.trace(&quot;Configuring advisor or advice &apos;&quot; + name + &quot;&apos;&quot;);</span><br><span class="line">                   &#125;</span><br><span class="line"></span><br><span class="line">                   if (name.endsWith(&quot;*&quot;)) &#123;</span><br><span class="line">                       if (!(this.beanFactory instanceof ListableBeanFactory)) &#123;</span><br><span class="line">                           throw new AopConfigException(&quot;Can only use global advisors or interceptors with a ListableBeanFactory&quot;);</span><br><span class="line">                       &#125;</span><br><span class="line"></span><br><span class="line">                       this.addGlobalAdvisor((ListableBeanFactory)this.beanFactory, name.substring(0, name.length() - &quot;*&quot;.length()));</span><br><span class="line">                   &#125; else &#123;</span><br><span class="line">                     //这里才是重点</span><br><span class="line">                       Object advice;</span><br><span class="line">                       if (!this.singleton &amp;&amp; !this.beanFactory.isSingleton(name)) &#123;</span><br><span class="line">                     //1.看，通过 BeanFactory 获得 interceptorNames 这个 List 中的每个 Advisor</span><br><span class="line">                     //的名字,交给BeanFactory，再通过 getBean 去获取</span><br><span class="line">                           advice = new ProxyFactoryBean.PrototypePlaceholderAdvisor(name);</span><br><span class="line">                       &#125; else &#123;</span><br><span class="line">                           advice = this.beanFactory.getBean(name);</span><br><span class="line">                       &#125;</span><br><span class="line">                      //2.将得到的所有 Advisor 加入到通知链中</span><br><span class="line">                       this.addAdvisorOnChainCreation(advice, name);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           this.advisorChainInitialized = true;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>通过代码清单17 我们知道了 Advisor 的获取是通过 IoC 容器完成的，多么精巧的设定。</p>
<h4 id="从-Advice-通知得到-Interceptor-拦截器"><a href="#从-Advice-通知得到-Interceptor-拦截器" class="headerlink" title="从 Advice 通知得到 Interceptor 拦截器"></a>从 Advice 通知得到 Interceptor 拦截器</h4><p>前面通过 代码清单16 ，已经介绍了这个很重要的方法 AdvisorAdapterRegistry.getInterceptors 方法，会根据 Advisor 得到 拦截器 Interceptor,但具体的实现是在 DefaultAdvisorAdapterRegistry 对象中，</p>
<p><href id="z3"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">/***代码清单 18 DefaultAdvisorAdapterRegistry 中的适配注册 拦截器方法***/</span><br><span class="line">//这里实在 DefaultAdvisorChainFactory 中启动的 getInterceptors 的地方</span><br><span class="line">public MethodInterceptor[] getInterceptors(Advisor advisor) throws UnknownAdviceTypeException &#123;</span><br><span class="line">    List&lt;MethodInterceptor&gt; interceptors = new ArrayList(3);</span><br><span class="line">    //1.从 通知器中得到 通知</span><br><span class="line">    Advice advice = advisor.getAdvice();</span><br><span class="line">    //2.如果是 MethodInterceptor 类型通知，直接加入 interceptors 的 List 中不适配</span><br><span class="line">    if (advice instanceof MethodInterceptor) &#123;</span><br><span class="line">        interceptors.add((MethodInterceptor)advice);</span><br><span class="line">    &#125;</span><br><span class="line">    //3.得到是配置的 Adapter 迭代器，此处配置好的 Adapter 有 :</span><br><span class="line">    // MethodBeforeAdviceAdapter，AfterReturningAdviceInterceptor,ThrowsAdviceInterceptor</span><br><span class="line">    Iterator var4 = this.adapters.iterator();</span><br><span class="line"></span><br><span class="line">    while(var4.hasNext()) &#123;</span><br><span class="line">      //3.使用 AdvisorAdapter 进行适配</span><br><span class="line">        AdvisorAdapter adapter = (AdvisorAdapter)var4.next();</span><br><span class="line">      //4.从 Advice 中得到的其对应的 Adapter 适配器，再从该适配器中取出已经封装好了的 拦截器。</span><br><span class="line">        if (adapter.supportsAdvice(advice)) &#123;</span><br><span class="line">            interceptors.add(adapter.getInterceptor(advisor));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (interceptors.isEmpty()) &#123;</span><br><span class="line">        throw new UnknownAdviceTypeException(advisor.getAdvice());</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return (MethodInterceptor[])interceptors.toArray(new MethodInterceptor[interceptors.size()]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></href></p>
<p>看这部分的时候。一定要看 代码清单18 中的注释，DefaultAdvisorAdapterRegistry 的 getInterceptors 方法说白了通过 通知 Advisor 中的 不同通知类型，利用适配器模式生成不同类型的拦截器。不同类型的拦截器的 invoke 方法实现各有不同，用来达到以哪种形式进行增强的目的。</p>
<p>举个例子：Advisor 中的通知 Advice 如果是 前置通知 就生成 MethodBeforeAdviceInterceptor 拦截器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/***代码清单 19  MethodBeforeAdviceInterceptor 拦截器***/</span><br><span class="line">public class MethodBeforeAdviceInterceptor implements MethodInterceptor, Serializable &#123;</span><br><span class="line">    private MethodBeforeAdvice advice;</span><br><span class="line"></span><br><span class="line">    public MethodBeforeAdviceInterceptor(MethodBeforeAdvice advice) &#123;</span><br><span class="line">        Assert.notNull(advice, &quot;Advice must not be null&quot;);</span><br><span class="line">        this.advice = advice;</span><br><span class="line">    &#125;</span><br><span class="line">    //注意这个方法！是真正实现对目标方法增强的部分</span><br><span class="line">    public Object invoke(MethodInvocation mi) throws Throwable &#123;</span><br><span class="line">       //首先调用了advice  的前置增强</span><br><span class="line">        this.advice.before(mi.getMethod(), mi.getArguments(), mi.getThis());</span><br><span class="line">        //执行过后会让整个拦截器链向前执行</span><br><span class="line">        return mi.proceed();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Advisor 中的通知 Advice 如果是 返回通知 就生成 AfterReturningAdviceInterceptor 拦截器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/***代码清单 20 AfterReturningAdviceInterceptor 拦截器***/</span><br><span class="line">public class AfterReturningAdviceInterceptor implements MethodInterceptor, AfterAdvice, Serializable &#123;</span><br><span class="line">    private final AfterReturningAdvice advice;</span><br><span class="line"></span><br><span class="line">    public AfterReturningAdviceInterceptor(AfterReturningAdvice advice) &#123;</span><br><span class="line">        Assert.notNull(advice, &quot;Advice must not be null&quot;);</span><br><span class="line">        this.advice = advice;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Object invoke(MethodInvocation mi) throws Throwable &#123;</span><br><span class="line">        //先让拦截器链向前执行</span><br><span class="line">        Object retVal = mi.proceed();</span><br><span class="line">        //之后调用后置增强</span><br><span class="line">        this.advice.afterReturning(retVal, mi.getMethod(), mi.getArguments(), mi.getThis());</span><br><span class="line">        return retVal;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们看到不同的拦截器，首先一定要注意到 invoke() 方法，结合 <a href="#h15">代码清单15</a> 看到的 Interceptor.invoke() 的调用，再以方法前置拦截器 MethodBeforeAdviceInterceptor 中的 invoke()为例，我们看到 方法前置拦截器会首先出发 Advice.before 的回调，然后在执行 MethodInvocation.proceed ，整个拦截器链向前运行，当某个拦截器对目标方法匹配，同样会执行该拦截器的 invoke 方法，所以拦截器的 invoke 方法是真正实现切面增强的地方。啊！多么精巧的设计！！！</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>一些总结(想起什么说什么)</li>
</ul>
<p>0.一些专业术语就不总结了。打字累。<br>1.Spring AOP 中一个重要对象 Advisor 通知器。它是由 Advice 通知 和 Pointcut 切点构成。Advisor 决定了要在哪个 目标方法 进行那种类型的切面增强。Advisor 就像是一个作战计划，有了 Advisor 还不能实现真正意义上的切面增强。<br>2.AOP 实现的核心是靠动态代理生成代理对象(很多书都不把这句话说完整，歧义很大的)，Spring AOP 有两种生成代理对象的方法，使用 JDK 动态代理 的 JdkDynamicAopProxy 和 使用 第三方库的 cglib 的 Cglib2AopProxy。之所以会有两种生成代理对象的策略，是因为 JDk 动态代理只能为实现某接口的类生成代理对象，而 cglib 则可以为任何类生成代理对象。<br>3.生成代理对象的入口是 ProxyFactoryBean 的 getObject() 方法，该方法也是使用首先调用 initializeAdvisorChain() 方法，完成 通知器链的初始化，然后 调用 getSingletonInstance () 方法，获取代理对象。<br>4.getSingletonInstance()的原理是调用 AopProxy.getProxy() 生成代理对象。调用 ProxyFactoryBean.createAopProxy 返回的两种不同的 生成代理类 JdkDynamicAopProxy 和 Cglib2AopProxy。在调用这两个类的 getProxy 方法。具体操作可以。<a href="#z1">戳这里</a><br>5.Spring AOP 完成对目标方法的增强是靠拦截器，JdkDynamicAopProxy 中实现对目标方法的拦截是在 invoke 方法中。在 invoke 方法中 通过 AdvisedSupport.getInterceptorsAndDynamicInterceptionAdvice() 方法获取拦截器链。并将拦截器链配置成 MethodInvocation 对象，然后调用 MethodInvocation.proceed() 方法，实现对拦截器的向前调用。<a href="#z2">戳这里</a> 真正生成 拦截器链的 地方是 DefaultAdvisorChainFactory.getInterceptorsAndDynamicInterceptionAdvice() 方法。<a href="#z4">戳这里</a><br>6.MethodInvocation.proceed()方法首先会检查当前拦截器是否和调用的方法匹配，如果匹配，则执行该拦截器的invoke方法。拦截器的 invoke 方法是真正实现切面增强的地方。<a href="#h15">戳这里</a><br>7.至于拦截器链如何生成，拦截器是在  GlobalAdvisorAdapterRegistry 的 getInterceptors 方法生产给你目标方法的所有拦截器，这个方法需要传入一个通知器 Advisor 作为参数，即通过 Advisor 生成 目标方的所有拦截器，再将这些拦截器添加到一个 List 中，形成了拦截器链。<a href="#z4">戳这里</a><br>8.在 GlobalAdvisorAdapterRegistry.getInterceptors(advisor)方法中,使用适配器模式 为不同的通知器生成不同拦截器，不同的拦截器的 invoke 方法是不一样的，<a href="#z3">戳这里</a><br>9.ProxyFactoryBean.initializeAdvisorChain() 方法，通过 BeanFactory 从 XML 配置中获取 所有 Advisor 便将其组成 通知器链，并将其交给 AdvisedSupport 持有。通知器链为后面拦截器链的生成提供了原材料，所以 Advisor 是很重要的对象。</p>
<ul>
<li>一点感受</li>
</ul>
<p>咳咳！一个不小心写了这么长的笔记。昨晚还刷了一个夜。起初看 Spring AOP 这里我很崩溃！满脑子都再说：啥！啥！啥！这都是个啥！究其原因，是因为当时对 AOP 和动态代理 这的概念有些模糊。弄清楚 AOP 后，我已经完全被好奇心驱使，开始去看源码。没有看得那么细，但是 Spring 的命名规范，不需要一个方法一个方法的去看。了解大概意思和思想那就好了。看过这篇笔记的同学一定会发现，笔记说的最多的一句话就是 ：啊！多么精巧的设计！是的，Spring 得开发人员实在是太牛了。</p>
</href></href></href>
    </article>
    <!-- 前后页  -->
    <ul class="post-pager">
        
        
            <li class="previous">
                <a href= "/2018/04/13/Java并发编程基础/" title= Java并发编程基础.md >
                    <span>Previous Post</span>
                    <span>Java并发编程基础.md</span>
                </a>
            </li>
        
    </ul>
    <!-- 评论插件 -->
    <!-- 来必力City版安装代码 -->

<!-- City版安装代码已完成 -->
    
    
<div id="container"></div>
<link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css">
<script src="https://imsun.github.io/gitment/dist/gitment.browser.js"></script>
<script>
    var gitment = new Gitment({
        // id: "Spring核心AOP", // 可选。默认为 location.href
        owner: 'DomBro96',
        repo: 'DomBro96.github.io',
        oauth: {
            client_id: '4a6fa6686f2dd417ed61',
            client_secret: 'cc1f043ee266bc750c481d6a24a98188a185e2eb',
        },
    })
    gitment.render('container')

</script>

    <!--PC版-->

    <!--PC版-->


    
</main>
            <!-- profile -->
            
        </div>
        <footer class="footer footer-unloaded">
    <!-- social  -->
    
    <div class="social">
        
    
        
            
                <a href="mailto:460716809@qq.com" class="iconfont-archer email" title=email ></a>
            
        
    
        
            
                <a href="https://github.com/DomBro96" class="iconfont-archer github" target="_blank" title="github"></a>
            
        
    
        
            
                <a href="https://twitter.com/Bro_Doom" class="iconfont-archer twitter" target="_blank" title="twitter"></a>
            
        
    
        
            
                <a href="https://www.instagram.com/dombro7277/" class="iconfont-archer instagram" target="_blank" title="instagram"></a>
            
        
    
        
            
                <a href="https://leetcode.com/dombro96/" class="iconfont-archer others" target="_blank" title="others"></a>
            
        
    

    </div>
    
    <!-- powered by Hexo  -->
    <div class="copyright">
        <span id="hexo-power">Powered by <a href="https://hexo.io/" target="_blank">Hexo</a></span><span class="iconfont-archer power">&#xe635;</span><span id="theme-info">Theme <a href="https://github.com/fi3ework/hexo-theme-archer" target="_blank">archer</a></span>
    </div>
    <!-- 不蒜子  -->
    
    <div class="busuanzi-container">
        <span id="busuanzi_container_site_pv">Welcome, No. <span id="busuanzi_value_site_pv"></span> visitor.
        </span>
    </div>
    
</footer>
    </div>
    <!-- toc -->
    
    <div class="toc-wrapper">
        <div class="toc-catalog">
            <span class="iconfont-archer catalog-icon">&#xe613;</span><span>CATALOG</span>
        </div>
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring的核心-——-AOP"><span class="toc-number">1.</span> <span class="toc-text">Spring的核心 —— AOP</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#前言"><span class="toc-number">1.1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AOP"><span class="toc-number">1.2.</span> <span class="toc-text">AOP</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#啥是-AOP"><span class="toc-number">1.2.1.</span> <span class="toc-text">啥是 AOP</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#AOP-实现的核心动态代理"><span class="toc-number">1.2.2.</span> <span class="toc-text">AOP 实现的核心动态代理</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Spring-AOP"><span class="toc-number">1.3.</span> <span class="toc-text">Spring AOP</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#通知-切点-通知器"><span class="toc-number">1.3.1.</span> <span class="toc-text">通知 切点 通知器</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#通知-Advice"><span class="toc-number">1.3.1.1.</span> <span class="toc-text">通知 Advice</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#切点-关注点-Pointcut"><span class="toc-number">1.3.2.</span> <span class="toc-text">切点(关注点) Pointcut</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#通知器-Advisor"><span class="toc-number">1.3.3.</span> <span class="toc-text">通知器 Advisor</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Spring-AOP-设计与实现"><span class="toc-number">1.3.4.</span> <span class="toc-text">Spring AOP 设计与实现</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Spring-AOP-的设计分析"><span class="toc-number">1.3.4.1.</span> <span class="toc-text">Spring AOP 的设计分析</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Spring-AOP-的-重点研究对象-ProxyFactoryBean"><span class="toc-number">1.3.4.2.</span> <span class="toc-text">Spring AOP 的 重点研究对象 ProxyFactoryBean</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ProxyFactoryBean-生成-AopProxy"><span class="toc-number">1.3.5.</span> <span class="toc-text">ProxyFactoryBean 生成 AopProxy</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#JdkDynamicAopProxy-和-Cglib2AopProxy"><span class="toc-number">1.3.6.</span> <span class="toc-text">JdkDynamicAopProxy 和 Cglib2AopProxy</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#代理对象的生成"><span class="toc-number">1.3.6.1.</span> <span class="toc-text">代理对象的生成</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Spring-AOP-拦截器的调用"><span class="toc-number">1.3.6.2.</span> <span class="toc-text">Spring AOP 拦截器的调用</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#AopProxy-的拦截"><span class="toc-number">1.3.6.2.1.</span> <span class="toc-text">AopProxy 的拦截</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#拦截器链的调用"><span class="toc-number">1.3.6.2.2.</span> <span class="toc-text">拦截器链的调用</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#拦截器链的生成"><span class="toc-number">1.3.6.3.</span> <span class="toc-text">拦截器链的生成</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#从-Advice-通知得到-Interceptor-拦截器"><span class="toc-number">1.3.7.</span> <span class="toc-text">从 Advice 通知得到 Interceptor 拦截器</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#总结"><span class="toc-number">1.4.</span> <span class="toc-text">总结</span></a></li></ol></li></ol>
    </div>
    
    <div class="back-top">&#xe639;</div>
    <div class="sidebar">
    <div class="sidebar-header sidebar-header-show-archive">
        <div class="sidebar-category">
            <span class="sidebar-archive-link"><span class="iconfont-archer">&#xe67d;</span>Archive</span>
            <span class="sidebar-tags-link"><span class="iconfont-archer">&#xe610;</span>Tag</span>
        </div>
    </div>
    <div class="sidebar-content sidebar-content-show-archive">
          <div class="sidebar-archive">
    <!-- 在ejs中将archive按照时间排序 -->
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    <div class="total-archive"> Total : 24 </div>
    
    <div class="post-archive">
    
    
    
    
    <div class="archive-year"> 2018 </div>
    <ul class="year-list">
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">04/21</span><a class="archive-post-title" href= "/2018/04/21/Spring核心AOP/" >Spring核心AOP</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">04/13</span><a class="archive-post-title" href= "/2018/04/13/Java并发编程基础/" >Java并发编程基础.md</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">03/26</span><a class="archive-post-title" href= "/2018/03/26/AVL树和红黑树/" >AVL树和红黑树</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">03/19</span><a class="archive-post-title" href= "/2018/03/19/几种基本排序/" >几种基本排序</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">03/11</span><a class="archive-post-title" href= "/2018/03/11/线程/" >线程</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">01/26</span><a class="archive-post-title" href= "/2018/01/26/散列/" >散列</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">01/01</span><a class="archive-post-title" href= "/2018/01/01/happy-new-year/" >别了，2017</a>
        </li>
    
    
    
    
    
        </ul>
    
    <div class="archive-year"> 2017 </div>
    <ul class="year-list">
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">12/29</span><a class="archive-post-title" href= "/2017/12/29/二叉搜索树/" >二叉搜索树</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">12/21</span><a class="archive-post-title" href= "/2017/12/21/栈及栈的应用/" >栈及栈的应用</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">12/12</span><a class="archive-post-title" href= "/2017/12/12/高级bash/" >高级bash</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">12/11</span><a class="archive-post-title" href= "/2017/12/11/浅谈token/" >浅谈token</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">12/11</span><a class="archive-post-title" href= "/2017/12/11/vim编辑器/" >vim编辑器</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">12/11</span><a class="archive-post-title" href= "/2017/12/11/磁盘与Linux分区/" >磁盘与Linux分区</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">12/11</span><a class="archive-post-title" href= "/2017/12/11/Linux文件与文件系统的打包/" >Linux文件与文件系统的打包</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">12/11</span><a class="archive-post-title" href= "/2017/12/11/初识bash/" >初识bash</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">12/11</span><a class="archive-post-title" href= "/2017/12/11/Java工厂设计模式/" >Java工厂设计模式</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">12/11</span><a class="archive-post-title" href= "/2017/12/11/Java优雅的处理异常/" >Java优雅的处理异常</a>
        </li>
    
    
    
    
    
        </ul>
    
    <div class="archive-year"> Invalid date </div>
    <ul class="year-list">
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">Invalid date</span><a class="archive-post-title" href= "/2017/12/01/hello-world/" >世界你好</a>
        </li>
    
    
    
    
    
        </ul>
    
    <div class="archive-year"> 2017 </div>
    <ul class="year-list">
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">12/11</span><a class="archive-post-title" href= "/2017/12/11/文件与文件系统的压缩与打包/" >文件与文件系统的压缩与打包</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">12/11</span><a class="archive-post-title" href= "/2017/12/11/Linux的文件权限与目录配置/" >Linux的文件权限与目录配置</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">12/10</span><a class="archive-post-title" href= "/2017/12/10/文件系统管理/" >文件系统管理</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">12/10</span><a class="archive-post-title" href= "/2017/12/10/Linux文件与目录管理/" >Linux文件与目录管理</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">12/06</span><a class="archive-post-title" href= "/2017/12/06/动态规划-Floyed算法/" >动态规划-Floyed算法</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">12/04</span><a class="archive-post-title" href= "/2017/12/04/堆排序-HeapSort/" >堆排序-HeapSort</a>
        </li>
    
    </div>
  </div>
        <div class="sidebar-tags">
    <div class="sidebar-tags-name">
    
        <span class="sidebar-tag-name"><a href= "#">Java并发</a></span>
    
        <span class="sidebar-tag-name"><a href= "#">数据结构 Data Structures</a></span>
    
        <span class="sidebar-tag-name"><a href= "#">Spring技术内幕</a></span>
    
        <span class="sidebar-tag-name"><a href= "#">设计模式</a></span>
    
        <span class="sidebar-tag-name"><a href= "#">casual writing</a></span>
    
        <span class="sidebar-tag-name"><a href= "#">JavaSE</a></span>
    
        <span class="sidebar-tag-name"><a href= "#">Linux</a></span>
    
        <span class="sidebar-tag-name"><a href= "#">hello world</a></span>
    
        <span class="sidebar-tag-name"><a href= "#">算法algorithm</a></span>
    
        <span class="sidebar-tag-name"><a href= "#">JavaWeb</a></span>
    
    </div>
    <div class="tag-load-fail" style="display: none; color: #ccc; font-size: 0.6rem;">
    缺失模块。<br/>
    1、请确保node版本大于6.2<br/>
    2、在博客根目录（注意不是archer根目录）执行以下命令：<br/>
    <span style="color: #f75357; font-size: 1rem; line-height: 2rem;">npm i hexo-generator-json-content --save</span><br/>
    3、在根目录_config.yml里添加配置：
    <pre style="color: #888; font-size: 0.6rem;">
jsonContent:
  meta: false
  pages: false
  posts:
    title: true
    date: true
    path: true
    text: false
    raw: false
    content: false
    slug: false
    updated: false
    comments: false
    link: false
    permalink: false
    excerpt: false
    categories: false
    tags: true</pre>
    </div> 
    <div class="sidebar-tag-list"></div>
</div>
    </div>
</div> 
    <script>
    var jsInfo = {
        root: '/'
    }
</script>
    <!-- 不蒜子  -->
    
    <script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    
    <!-- CNZZ统计  -->
    
    </div>
    </body>
</html>


