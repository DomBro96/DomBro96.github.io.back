<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Welcome</title>
  
  <subtitle>Dom&#39;know</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-07-22T08:33:00.811Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>dombro</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>工厂方法引发的思考</title>
    <link href="http://yoursite.com/2018/07/22/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E5%BC%95%E5%8F%91%E7%9A%84%E6%80%9D%E8%80%83/"/>
    <id>http://yoursite.com/2018/07/22/工厂方法引发的思考/</id>
    <published>2018-07-22T08:28:48.000Z</published>
    <updated>2018-07-22T08:33:00.811Z</updated>
    
    <content type="html"><![CDATA[<h1 id="单例工厂方法引发的思考"><a href="#单例工厂方法引发的思考" class="headerlink" title="单例工厂方法引发的思考"></a>单例工厂方法引发的思考</h1><p>emmm， 今天被朋友嘲讽了代码。有点小情绪，俗话说知耻而后勇，错了就要认嘛~</p><h2 id="我的初衷——单例模式"><a href="#我的初衷——单例模式" class="headerlink" title="我的初衷——单例模式"></a>我的初衷——单例模式</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/*** 代码清单 1 不伦不类的工厂方法 ***/</span><br><span class="line">class UserService&#123;</span><br><span class="line"></span><br><span class="line">  private UserService()&#123;&#125;</span><br><span class="line"></span><br><span class="line">  public static UserService getInstance()&#123;</span><br><span class="line">      return new UserService();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实话实说，这代码我也没搞懂我当初要干什么。好像是为了当初让编写上层控制层的同学更好的得到 <code>UserService</code>，提供的一个接口。当初的想法应该是提供一个单例的  <code>UserService</code> (很不幸，代码清单 1 一直在创建对象)，那代码就应该是代码清单 2</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/*** 代码清单 2 单线程的工厂方法 ***/</span><br><span class="line">class UserService&#123;</span><br><span class="line"></span><br><span class="line">  private UserService()&#123;&#125;</span><br><span class="line"></span><br><span class="line">  private  static UserService instance;</span><br><span class="line"></span><br><span class="line">  public static UserService getInstance()&#123;</span><br><span class="line">       if (instance == null)&#123;</span><br><span class="line">            instance = new UserService();</span><br><span class="line">       &#125;</span><br><span class="line">       return instance;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>嗯，很美丽。<strong>对象只有在需要时被创建(对象的延迟初始化)，而且不需要自己手动 <code>new</code> ，降低初始化类的开销</strong>。实际上代码清单 2 <em>隐藏着一个大问题——多线程访问</em>。</p><h2 id="多线程的思考"><a href="#多线程的思考" class="headerlink" title="多线程的思考"></a>多线程的思考</h2><h3 id="多线程不安全的延迟初始化"><a href="#多线程不安全的延迟初始化" class="headerlink" title="多线程不安全的延迟初始化"></a>多线程不安全的延迟初始化</h3><p>代码清单 3 中，假设两个线程: 线程A 和 线程B 调用 <code>getInstance()</code> 方法，当线程A判断 instance 是否为空，而此时线程 B 虽然执行 <code>instance = new UserService</code> ，但 线程A 可能并没有看到线程B 的初始化操作(即 instance 在 线程A 看来是 null，原因见 <a href="#1">tips 1</a>)。 <strong>这个时候 线程A 和 线程B 会造出两个对象，线程不安全</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/*** 代码清单 3 两个线程调用 getInstance***/</span><br><span class="line">public static UserService getInstance()&#123;</span><br><span class="line">     if (instance == null)&#123;                   //线程 A 执行</span><br><span class="line">          instance = new UserService();       //线程 B 执行</span><br><span class="line">     &#125;</span><br><span class="line">     return instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="1">tips 1</h5><blockquote><p>创建一个对象，instance = new Instance() 可以分解为下面三行伪代码:<br><br>memory = allocate();   // 1.分配对象的内存空间   <br><br>ctorInstance(memory);  // 2.初始化对象          <br><br>instance = memory;     // 3.设置 instance 指向刚分配的内存地址    <br><br>所以当 线程 B 创建对象时，有可能还没有到第三步，那么线程 A 读到的 instance 就是 null。</p></blockquote><h3 id="用锁的代价"><a href="#用锁的代价" class="headerlink" title="用锁的代价"></a>用锁的代价</h3><p>既然多线程不安全，自然想到使用 <code>sychronized</code> 关键字，让线程同步访问 <code>getInstance()</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/*** 代码清单 4 加锁同步 ***/</span><br><span class="line">public sychronized static UserService getInstance()&#123;</span><br><span class="line">     if (instance == null)&#123;                   //线程 A 执行</span><br><span class="line">          instance = new UserService();       //线程 B 执行</span><br><span class="line">     &#125;</span><br><span class="line">     return instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>线程当然是安全的，但是当访问线程过多时，会造成性能严重下降。因为即使 instance 已经创建了，线程还是要同步的进行获取。</p><h3 id="看起来很美的双重检查锁定"><a href="#看起来很美的双重检查锁定" class="headerlink" title="看起来很美的双重检查锁定"></a>看起来很美的双重检查锁定</h3><p>可不可以只有当线程判断 <code>instance == null</code>  时，再上锁呢？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/*** 代码清单 5 双重检查锁定 ***/</span><br><span class="line">public static UserService getInstance()&#123;</span><br><span class="line">     if (instance == null)&#123;                   //一重检查</span><br><span class="line">          sychronized(UserService.class)&#123;</span><br><span class="line">              if(instance == null)&#123;           //双重检查</span><br><span class="line">                  instance = new UserService();</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;   </span><br><span class="line">     &#125;</span><br><span class="line">      return instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看起来很美，一重检查判断 <code>instance == null</code> 时，会同步获取当前类对象的锁，当多个线程试图同时创建对象时，会通过加锁来保证只有一个线程能创建对象。<strong>但是，这是一个错误的优化！ 代码执行到一重检查，判断 instance != null 时，instance 有可能还没有完成初始化</strong> ！</p><ul><li>创建对象时的重排序</li></ul><p>在 <a href="#1">tips 1</a> 中，解释了当一个对象创建时的三个步骤，然而这三个步骤可能会被编译器重排序。所谓重排序就是为了使代码运行的更快，编译器，处理器，或者系统内存对程序进行的一种运行时优化。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/***代码清单 6 创建对象重排序后的伪代码***/</span><br><span class="line">memory = allocate();   //1.分配对象的内存空间    </span><br><span class="line">instance = memory;     //2.设置 instance 指向分配的内存地址   </span><br><span class="line">ctorInstance(memory);  //3.初始化对象</span><br></pre></td></tr></table></figure><p>上面的重排序在单线程中是没有任何问题的，反而效率比正常的创建对象顺序更快。 但如果在多线程环境下，问题就很大了。假设 线程A 运行到  <code>instance == null</code> 时，<strong>线程 B 运行到 instance = new UserService()，并在实例化过程中发生了重排序，且刚刚执行到重排序的第二步，此时，instance 并没有被初始化，仅仅是一个空的引用。线程A于 是很悲催的返回一个空的引用</strong> 。看似线程安全的双重检查，并不是很安全哦，这种实例化过程中的重排序在 JDK 7 是很常见的。</p><h3 id="解决方式"><a href="#解决方式" class="headerlink" title="解决方式"></a>解决方式</h3><p>针对双重检查锁定的解决方式，解铃换需系铃人。问题在于实例化过程中的重排序，那就针对重排序解决问题。思路有两个：</p><ol><li><p>禁止实例化过程中的重排序</p></li><li><p>允许重排序，但不让其他线程看到这个重排序</p></li></ol><h3 id="禁止重排序-基于-volatile-的解决方案"><a href="#禁止重排序-基于-volatile-的解决方案" class="headerlink" title="禁止重排序 基于 volatile 的解决方案"></a>禁止重排序 基于 volatile 的解决方案</h3><p>说道禁止重排序，那就不得不提到并发世界中的另一个关键字 <code>volatile</code>了。</p><ul><li>volatile 关键字禁止重排序</li></ul><p> <code>volatile</code> <strong>关键字的写 永远 happens-before</strong> <code>volatile</code> <strong>的读</strong>。也就是说当一个线程在读取 <code>volatile</code> 变量时，读取到的永远都是 <code>volatile</code> 变量最新的值。所以当对象的引用为 <code>volatile</code> 时，再多线程环境下的重排序就被禁止了。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">/*** 代码清单 7 使用 volatile 关键字解决问题***/</span><br><span class="line">class UserService&#123;</span><br><span class="line"></span><br><span class="line">  private UserService()&#123;&#125;</span><br><span class="line"></span><br><span class="line">  private volatile static UserService instance;</span><br><span class="line"></span><br><span class="line">  public static UserService getInstance()&#123;</span><br><span class="line">       if (instance == null)&#123;                   </span><br><span class="line">            sychronized(UserService.class)&#123;</span><br><span class="line">                if(instance == null)&#123;           </span><br><span class="line">                    instance = new UserService();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;   </span><br><span class="line">       &#125;</span><br><span class="line">        return instance;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 代码清单 7 通过 volatile，保证线程安全的延迟初始化对象。</p><h3 id="允许重排序，基于-类初始化-的解决方案"><a href="#允许重排序，基于-类初始化-的解决方案" class="headerlink" title="允许重排序，基于 类初始化 的解决方案"></a>允许重排序，基于 类初始化 的解决方案</h3><ul><li>类的初始化</li></ul><blockquote><p>JVM 在类初始化阶段(Class 被加载后，且被线程使用之前)，会执行类的初始化。执行类的初始化期间，JVM 会获取一个锁，<strong>这个锁可以同步多个线程对同一个类的初始化</strong> 。———《Java并发编程艺术》</p></blockquote><p> 每一个类和接口C，都有一个唯一的初始化锁 LC 与之对应。JVM 在初始化期间会获取这个初始化锁，并且每个线程保证 <strong>至少获取一次</strong> 锁来确保这个类被初始化。也就是在初始化一个类时会通过这个 类的LC锁 <strong>使线程同步的初始化</strong> 这个类。<strong>初始化一个类，包括执行这个类的静态初始化和初始化在这个类中声明的静态字段</strong>。</p><ul><li>初始化的条件</li></ul><p>首次发生下面任意一种情况时，一个类或一个接口T 将立即被初始化:</p><ol><li>T 是一个类，而且一个 T 类型的实例被创建。</li><li>T 是一个类，且 T 中声明的一个静态方法被调用。</li><li>T 中声明的一个静态字段被赋值。</li><li>T 中声明的一个静态字段被使用，而且这个字段不是一个常量字段。</li></ol><ul><li>原理</li></ul><p>由于涉及到线程获取类的 L锁 ，这个过程虽然好理解，但是比较复杂，简单总结一下。当线程触发了类初始化时，会获取这个类对应 Class对象的初始化锁 (LC)，这个锁是同步获取的，即只有一个线程可以对类进行初始化。</p><ol><li><p>若 类C 没有被初始化过，类的初始化状态为 status = noinit， 当线程A初始化该类时 status = initing，表示正在初始化。其他线程被阻塞。</p></li><li><p>线程A释放初始化锁，执行 类C 的静态初始化和初始化这个类的静态字段。此时线程B，获取到 类C 的初始化锁，查看初始化状态 status = initing, 释放初始化锁，在初始化锁的 condition 上等待(相当于wait(),进入等待队列)。</p></li></ol><ol><li><p>线程A 获取初始化锁(此时已经初始化完毕)，更改初始化状态为 status = inited，唤醒所有在锁的 condition 等待的线程。释放锁，线程A 的初始化过程完毕。</p></li><li><p>线程B 获取初始化锁，查看初始化状态为 status = inited, 释放锁(因为已经被初始化过了)，线程B 的初始化过程完毕。</p></li><li><p>其他线程获取到锁，读取到 status = inited 后，释放锁，同样不做初始化行为，完成类的初始化操作。</p></li></ol><p>可以发现，从始至终只有一个线程会真正的执行类的初始化，即类只被初始化一次。回到本节的主题，当一个线程对类初始化时，其他的线程自然是允许在实例化重排序的。</p><ul><li>实现</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/*** 代码清单 8 类初始化的解决方案 ***/</span><br><span class="line">public class UserService&#123;</span><br><span class="line">  //静态内部类</span><br><span class="line">  private static class InstanceHolder&#123;</span><br><span class="line">    public static UserService instance = new UserService();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public static UserService getInstance()&#123;</span><br><span class="line">    return InstanceHolder.instance;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码清单 8 中，当线程调用 <code>InstanceHolder.instance;</code> 时，会触发类 InstanceHolder 的初始化, 属于触发类初始化的情况 4。由于 instance 是静态的，所以 instance 也是单例的。</p><h3 id="两种方式的比较"><a href="#两种方式的比较" class="headerlink" title="两种方式的比较"></a>两种方式的比较</h3><p>字段的延迟初始化降低初始化类或创建实例的开销，但增加了访问被延迟初始化字段的开销。上述两种线程安全的延迟初始化方式，从胆码简介程度上来看 类初始化更加的简便。但是基于 volatile 的双重检查策略的优势是: 不仅可以延迟初始化静态字段，还可以对实例字段延迟初始化。所以得出的结论是: 如果要对静态字段延迟初始化，选用类的初始化方式；如果要对实例字段延迟初始化选用基于 volatile 的双重检查策略。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>有时候一个你很难去关注的点，它蕴含的知识点是难以想象的。从简单的单例模式，到对延迟初始化在并发环境下的思考。还真的是学无止境。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;单例工厂方法引发的思考&quot;&gt;&lt;a href=&quot;#单例工厂方法引发的思考&quot; class=&quot;headerlink&quot; title=&quot;单例工厂方法引发的思考&quot;&gt;&lt;/a&gt;单例工厂方法引发的思考&lt;/h1&gt;&lt;p&gt;emmm， 今天被朋友嘲讽了代码。有点小情绪，俗话说知耻而后勇，错了
      
    
    </summary>
    
    
      <category term="Java并发" scheme="http://yoursite.com/tags/Java%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Spring核心AOP</title>
    <link href="http://yoursite.com/2018/04/21/Spring%E6%A0%B8%E5%BF%83AOP/"/>
    <id>http://yoursite.com/2018/04/21/Spring核心AOP/</id>
    <published>2018-04-21T03:37:52.000Z</published>
    <updated>2018-04-22T13:28:39.294Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Spring的核心-——-AOP"><a href="#Spring的核心-——-AOP" class="headerlink" title="Spring的核心 —— AOP"></a>Spring的核心 —— AOP</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>最近在撸《Spring技术内幕》 这本书(很赞的一本 Spring 源码级别的书)，用作者的话来说 AOP 和 IOC 属于 Spring的核心 部分。但是要明确的是，无论是 IoC 还是 AOP 都只是 Spring 给出众多功能的一种，并不能说 Spring 是单纯的 IoC 或 AOP 框架。今天要说的 AOP 从底层介绍 Spring AOP 在底层是如何基本实现的，看过后会发现 Spring 的作者们真的是太牛逼了。我可能不会按照作者的思路来，通过这本书加上我的理解解开 Spring AOP 那 <del>性感</del> 神秘的面纱。然后，墙裂建议看这篇笔记的人一定不要错过最后的总结。</p><h3 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h3><h4 id="啥是-AOP"><a href="#啥是-AOP" class="headerlink" title="啥是 AOP"></a>啥是 AOP</h4><p>在进入 Spring AOP 之前，你得知道 AOP 这玩意儿 不是 Spring 的专利。人家自己是一个专有名词 —— Aspect Oriented Programming 即面向切面编程。md,不是要面向对象编程吗？咋又面向切面编程了？啥叫切面？ 没错，这两个问题是我在开始学 Spring 的时候的问题。</p><ul><li>面向切面 &amp; AOP 要做什么</li></ul><p>先抛出一个<strong>个人结论</strong>(注意个人这两个字): 面向切面，就是面向方法。 为什么这么说？得从 AOP 要达到的目的说起。假设有一个场景，你对数据表进行 CRUD 操作，当然这四个操作在不同的方法中。你希望将记录下每次 CRUD 的执行过程及结果，并将其放入日志文件中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/****代码清单 1 向表中插入记录并记录到日志的伪码***/</span><br><span class="line">public void createStudent(Student student)&#123;</span><br><span class="line">       //1.在数据表中插入 student 这条记录</span><br><span class="line">           insert(student);</span><br><span class="line">       //2.将操作结果放入日志中</span><br><span class="line">           intoLog();</span><br><span class="line">   &#125;</span><br><span class="line">仅以插入为例子，RUD 操作省略...</span><br></pre></td></tr></table></figure><p>如代码清单1中，将操作结果记录到日志并不是 createStudent 这个方法业务范围，也就是说 intoLog 与业务无关，上述代码太不规范耦合性较大。自然而然想到将 intoLog  操作抽离出来，在每次执行 createStudent() 方法之后，在调用 intoLog 方法，这样就做到了解耦又使代码整洁。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">/****代码清单 2 将 记录到日志操作抽离出来***/</span><br><span class="line">public void createStudent(Student student)&#123;</span><br><span class="line">           insert(student);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">//记录到日志的方法</span><br><span class="line">public viod intoLog()&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//该方法表示上层的调用</span><br><span class="line">public void  doService(Student stu)&#123;</span><br><span class="line">StudentService service = new StudentServiceImp();</span><br><span class="line">LogService log = new LogService();</span><br><span class="line">//在插入后记录到日志中去</span><br><span class="line">service.createStudent(stu);</span><br><span class="line">log.intoLog();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>乍一看这好像也没啥问题，可是这只是一个添加操作，还是要手动的把操作记录到日志中去。如果有更多对标的操作，那岂不是每个操作之后都要手动调用记录日志的方法？ <strong>嫌麻烦是人类进步的阶梯， 要是有一种方式可以达到 调动插入方法 后就自动将结果记录到日志中的效果，岂不快哉？</strong>  换句话说，关注点在 <strong>方法</strong> 上，所要达到的效果也是建立在方法上。<strong>这是面向方法编程</strong> ！</p><ul><li>对一些名词的解释</li></ul><p>至于为什么要叫面向切面编程，小孩没娘，说来话长。我们知道 Java 方法的调用到执行记录在 Java 运行时数据区的虚拟机栈中(具体来说是栈帧)，可以抽象的把方法的调用看成是一长串的线性结构。所以当对虚拟机栈中某个方法(无论执行前还是执行后)做一些操作，就好像在这个线性结构上的某个节点(栈帧)横着切了过去！<strong>这就是面向切面编程这个名字的由来，至于这个方法我们叫他横切关注点又叫目标方法，对这个方法做的操作我们叫他对方法的切面增强。持有这个方法的对象我们叫他目标对象。</strong></p><h4 id="AOP-实现的核心动态代理"><a href="#AOP-实现的核心动态代理" class="headerlink" title="AOP 实现的核心动态代理"></a>AOP 实现的核心动态代理</h4><p>上面我们知道了 AOP 要做的是对某个横切关注点的增强(翻译成中文就是对目标对象的某方法执行前后做一些操作)，要强调的是我们不是增强可不一定是在方法执行后，也可以是方法执行前，甚至是在方法出异常的情况下都可以对目标对象的方法增强。下面来说一下 AOP 的实现。</p><ul><li>AOP 的实现</li></ul><p>那么 AOP 要怎样实现呢？在调用目标方法前后要完成对该方法的增强,很难不让人想到代理模式的动态代理。说白了动态代理不就是在 invoke 方法中对 被代理对象的代理方法进行一个回调吗？还是以记录日志为例子，只要在代理对象的 invoke 方法回调目标方法之后记录至日志就好啦！</p><ul><li>Java动态代理</li></ul><p>复习一下　Java 动态代理，毕竟这是 AOP 的核心。Java 代理又分为静态代理和动态代理，两者的思路都是在代理对象的方法中回调被代理对象的方法，这里就不讲静态代理了。动态代理的代理类需要实现 InvocationHandler 的 invoke 方法 。而被代理类则要实现一个接口，这样代理类对象就不必知道代理对象方法的具体实现。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/***代码清单3 一个动态代理类***/</span><br><span class="line">public class MyProxy implements InvocationHandler &#123;</span><br><span class="line"></span><br><span class="line">    Object target;</span><br><span class="line"></span><br><span class="line">    public Object blind(Object object)&#123;</span><br><span class="line">        //给出被代理对象实例</span><br><span class="line">        target = object;</span><br><span class="line">        //返回一个代理类对象</span><br><span class="line">        return Proxy.newProxyInstance(target.getClass().getClassLoader(),target.getClass().getInterfaces(),this);</span><br><span class="line">    &#125;</span><br><span class="line">//每次调用被代理对象的方法，都会调用 代理对象的 invoke 方法</span><br><span class="line">    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line">        Object returnResult = method.invoke(target,args);</span><br><span class="line">        return returnResult;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Java动态代理 实现的 AOP</li></ul><p>在代码清单3 的动态代理类的 invoke 方法中，我们可以在执行目标方法前后插入对目标方法的增强。还是以 记录日志为例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">/***代码清单4 动态代理类实现 AOP ***/</span><br><span class="line">public class CreateStudentProxy implements InvocationHandler &#123;</span><br><span class="line"></span><br><span class="line">    Object target;</span><br><span class="line"></span><br><span class="line">    public Object blind(Object object)&#123;</span><br><span class="line"></span><br><span class="line">        target = object;</span><br><span class="line">        return Proxy.newProxyInstance(target.getClass().getClassLoader(),target.getClass().getInterfaces(),this);</span><br><span class="line">    &#125;</span><br><span class="line">//每次调用被代理对象的方法，都会调用 代理对象的 invoke 方法</span><br><span class="line">    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line">        Object returnResult = method.invoke(target,args);</span><br><span class="line">        //在这里调用 intoLog 方法，实现后置增强</span><br><span class="line">        intoLog();</span><br><span class="line">        return returnResult;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//我们假设 createStudent 方法是 StudentServiceImp 实现的 StudentService 方法。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">  StudentServiceImp serviceImp = new StudentServiceImp();</span><br><span class="line">  CreateStudentProxy proxy= new CreateStudentProxy();</span><br><span class="line">  StudentService service = (StudentService)proxy.blind(serviceImp);</span><br><span class="line">  //这会执行 代理类 中的 invoke 方法</span><br><span class="line">  service.createStudent(student);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过代码清单4 这是一个很简单的例子，我们大概其了解了 AOP 增强的原理，就是通过代理对象的 invoke 方法中的回调。其实这个原理还是很好懂得，现在可以揣测到 Spring 也一定是用到代理技术实现 AOP 的。 或许你会说，这也没看见代码量少了啊，反而多写了好多代码。图样图森破！使用代理实现面向切面编程充分做到了解耦，不必担心方法的增强写在方法中这种不规范的写法，也不必每次都手动调用增强方法，只要使用代理的接口调用目标方法就可以了，充分解决了提出的问题! 如果真的要挑毛病，也只能是动态代理使用反射会慢一点点。</p><h3 id="Spring-AOP"><a href="#Spring-AOP" class="headerlink" title="Spring AOP"></a>Spring AOP</h3><p>简单了解了 AOP 原理，终于来到了 Spring AOP 。看过这部分，你会发现。哇！写出 Spring AOP 的人，太牛逼了！怎么会有如此精巧的设计方式，简直到了到了代码和设计艺术水平。我一辈子都写不出来这种代码。</p><h4 id="通知-切点-通知器"><a href="#通知-切点-通知器" class="headerlink" title="通知 切点 通知器"></a>通知 切点 通知器</h4><p>通知 Advice 、切点 PointCut 、通知器 Advisor 他们既是名词又是 Spring AOP 的三个重要对象。决定了 AOP  切入什么、怎样切入 和 在哪切入 的问题。一起来看一下。</p><h5 id="通知-Advice"><a href="#通知-Advice" class="headerlink" title="通知 Advice"></a>通知 Advice</h5><p>那么通知是干啥的呢？通知定义了在连接点中做些什么，为 切面增强织 入提供接口。(连接点就是我们上面说的方法也即横切关注点。Spring 中的一些名词可能会不太一致，但我们不在这里纠结) 也就是说 Advice 定义了切入内容以及怎样切入。</p><p><em>注：要说明一点的是 Advice 不是 Spring 中定义的接口，而是 AOP 联盟定义的。不明觉厉。当然这里也只当个了解就行了。</em></p><ul><li>切入什么 &amp; 如何切入</li></ul><p>从 Advice 的定义，可以看出我们可以在 Advice 中定义切面的增强。例如，可以把上面举的记录日志操作定义到 Advice 中。 至于如何定义到 Advice 这就涉及到了 如何切入的问题。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/***代码清单5 Advice 接口****/</span><br><span class="line">public interface Advice &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们看到 Advice 接口空空如也，啥都没有。没关系 Spring 通过扩展 Advice ，给出了更多的通知类型，供使用者选择。比如我们熟悉的前置通知，后置通知，环绕通知，异常通知… 底层原理都是实现了这些具体的通知的方法而已。</p><p><img src="http://p0bl99g4r.bkt.clouddn.com/spring_aop_advice.PNG" alt=""></p><p><em>图 1 Advice 类继承关系</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/***代码清单6 常见的几种具体通知***/</span><br><span class="line">//前置通知</span><br><span class="line">public interface MethodBeforeAdvice extends BeforeAdvice &#123;</span><br><span class="line">   //我们看到 Method 参数，就是连接点</span><br><span class="line">    void before(Method var1, Object[] var2, Object var3) throws Throwable;</span><br><span class="line">&#125;</span><br><span class="line">//后置通知</span><br><span class="line">public interface AfterReturningAdvice extends AfterAdvice &#123;</span><br><span class="line">    void afterReturning(Object var1, Method var2, Object[] var3, Object var4) throws Throwable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以根据通知的名称和方法名 就可以得出 如何切入 这个问题，例如 MethodBeforeAdvice 中的 before　方法，就是以前置通知的方式切入，至于切入什么据要看你在 before 中定义的操作了。</p><h4 id="切点-关注点-Pointcut"><a href="#切点-关注点-Pointcut" class="headerlink" title="切点(关注点) Pointcut"></a>切点(关注点) Pointcut</h4><p>Pointcut 决定了 Advice 通知应该作用于那个连接点，也就是作用于哪个方法。也就是 在哪切入这个问题。注意的是，我在刚开始的时候以为 Pointcut 只可能是一个方法，其实不然。Pointcut 定义的是需要增强方法的集合，这些集合的选取按照一定规则生成。例如，通过正则表达式或者编程式声明 切入点的时候我们有时候会让一个 通知 增强不止一个 方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/***代码清单7 Pointcut 切点****/</span><br><span class="line">public interface Pointcut &#123;</span><br><span class="line">    Pointcut TRUE = TruePointcut.INSTANCE;</span><br><span class="line"></span><br><span class="line">    ClassFilter getClassFilter();</span><br><span class="line"></span><br><span class="line">    MethodMatcher getMethodMatcher();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们看到 pointcut 需要返回一个 MethodMather 对象。 Pointcut 就是通过这个 MethodMather 来判断当前连接点是否匹配的。也就是是说有这个 MethodMather 来判断是否要对当前调用的方法应用配置好的 Advice 通知。<br>Pointcut 也有很多子类伙子接口，比较常见的是使用 正则表达式 切点 JdkRegexpMethodPointcut,该切点通过匹配正则表达式来匹配连接点; 以及 NameMatchMethodPointcut ，他通过 切点的方法</p><h4 id="通知器-Advisor"><a href="#通知器-Advisor" class="headerlink" title="通知器 Advisor"></a>通知器 Advisor</h4><p>事实上，我们通过 通知 和 切点 这这俩 在表面上看起来已经 AOP 的必要条件就已经满足了。那么就需要另一个对象 通知器 Advisor 将这二者结合起来。 通过这个通知器，可以定义应该使用那个通知并在那个关注点使用它。体现了 Spring 良好的封装性。Advisor 为 使用 IoC 容器配置 AOP 应用，提供了便利( 设置 bean property 就可以了)。<br>Advisor 是一个接口，默认的 Advisor 是 DefaultPointcutAdvisor 。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">/***代码清单8 默认的 Advisor ***/</span><br><span class="line">public class DefaultPointcutAdvisor extends AbstractGenericPointcutAdvisor implements Serializable &#123;</span><br><span class="line">    private Pointcut pointcut;</span><br><span class="line">    //注意，这里的关注点用单例模式获取</span><br><span class="line">    public DefaultPointcutAdvisor() &#123;</span><br><span class="line">        this.pointcut = Pointcut.TRUE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public DefaultPointcutAdvisor(Advice advice) &#123;</span><br><span class="line">        this(Pointcut.TRUE, advice);</span><br><span class="line">    &#125;</span><br><span class="line">    //初始化 Pointcut 和 Advice</span><br><span class="line">    public DefaultPointcutAdvisor(Pointcut pointcut, Advice advice) &#123;</span><br><span class="line">        this.pointcut = Pointcut.TRUE;</span><br><span class="line">        this.pointcut = pointcut;</span><br><span class="line">        this.setAdvice(advice);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setPointcut(Pointcut pointcut) &#123;</span><br><span class="line">        this.pointcut = pointcut != null ? pointcut : Pointcut.TRUE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Pointcut getPointcut() &#123;</span><br><span class="line">        return this.pointcut;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return this.getClass().getName() + &quot;: pointcut [&quot; + this.getPointcut() + &quot;]; advice [&quot; + this.getAdvice() + &quot;]&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Spring-AOP-设计与实现"><a href="#Spring-AOP-设计与实现" class="headerlink" title="Spring AOP 设计与实现"></a>Spring AOP 设计与实现</h4><p>现在我们知道了 Spring 是通过 Advisor 通知器 对关注点进行切面增强的。然而知道这个还远远不够，Advisor 只是给了一个大概的轮廓。Spring AOP 要做到的效果是调用目标对象的关注点方法，就会将对应的增强效果显示出来 ，显然，为了解决这个问题 Spring AOP 同样是靠动态代理实现的。这里可以猜测一下下:</p><p><href id="q1">猜测 1 : 由于 Advisor 可以知道关注点和通知，那么 Spring　AOP 的 代理类的 代理方法一定会使用到 Advisor 。</href></p><h5 id="Spring-AOP-的设计分析"><a href="#Spring-AOP-的设计分析" class="headerlink" title="Spring AOP 的设计分析"></a>Spring AOP 的设计分析</h5><p>在介绍 AOP 的时候介绍到实现 AOP 的核心是动态代理，即通过 代理类 实现切面的织入。同样 Spring 也是如此，Spring 的核心技术就是 JDK动态代理。</p><blockquote><p>以动态代理技术为基础，设计出一系列 AOP 的横切实现，比如 前置通知、返回通知，异常通知等。同时 Spring 还提供一些列的 Pointcut 来匹配切入点。 ——《Spring技术内幕》</p></blockquote><p>使用 Spring　AOP 是一件简单的事，只需要配置相关的 Bean 定义即可。然而为了让 Spring AOP 起作用，需要完成一系列的步骤。比如 为目标对象建立 代理，启动代理对象的拦截器完成横切面(增强切入点) 的织入。</p><h5 id="Spring-AOP-的-重点研究对象-ProxyFactoryBean"><a href="#Spring-AOP-的-重点研究对象-ProxyFactoryBean" class="headerlink" title="Spring AOP 的 重点研究对象 ProxyFactoryBean"></a>Spring AOP 的 重点研究对象 ProxyFactoryBean</h5><ul><li>Spring AOP 的应用类</li></ul><p>Spring AOP 为我们准备了三个 AOP 的应用类，分别是 AspectJProxyFactory、ProxyFactoryBean、ProxyFactory 。对于使用 Spring AOP 的应用，以上三个类都提供了对 AOP 功能的封装。区别在于 AspectJProxyFactory 集成了 Spring 和 AspectJ 的作用；ProxyFactoryBean 可以在 IoC 容器中完成声明式配置 AOP 功能，而使用 ProxyFactory 则需要编程式的使用 AOP 功能。 <strong>明眼人一看就知道，那肯定是结合了 IoC 和 AOP 的 ProxyFactoryBean 更有研究的价值</strong>！</p><p><img src="http://p0bl99g4r.bkt.clouddn.com/spring_aop_proxyfactorybean.PNG" alt=""></p><p><em>图2 ProxyFactoryBean 的类继承关系</em></p><p>在 图2 中，有几个要注意的类</p><p>1.ProxyConfig 是一个数据基类，这个基类为 ProxyFactoryBean 提供了配置属性。<br>2.AdvisedSupport 的实现中，封装了 AOP 对通知的和通知器的相关操作。</p><ul><li>配置 ProxyFactoryBean</li></ul><p>前面提到了，ProxyFactoryBean 需要在 IOC 容器中进行配置，ProxyFactoryBean 是最灵活的一种 Spring AOP 应用。我们要从这里为入口了解一下。首先了解，在 XML 中配置 ProxyFactoryBean，配置 ProxyFactoryBean 要经过一系列步骤:</p><p>1.定义使用的通知器 Advisor，这个通知器作为一个 Bean 来定义。很重要的一点是，<strong>这个通知器的实现定义了需要对目标对象进行增强的切面行为，也就是 Advice</strong>。<br>2.定义一个 ProxyFactoryBean ，同样把他作为 Bean 来定义，是封装 AOP 主要功能的类。 在配置 ProxyFactoryBean 时，需要设定与 AOP 实现相关的重要属性，比如 proxyInterface 、interceptorName 和 target 等。interceptorName 往往设置为 Advisor 通知器，你可能会纠结这不是拦截器的意思吗？<strong>实际上这些通知器在 ProxyFactoryBean 的 AOP 配置下,是通过使用代理对象的拦截器机制起作用的</strong>。 请记住这句话。<br>3.定义 target 属性，作为 target 属性注入的 Bean。很明显，表示目标对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/***代码清单 9 在 XML 中配置 ProxyFactoryBean ***/</span><br><span class="line">    &lt;bean id=&quot;advisor&quot; class=&quot;cn.dombro.spring.aop.MyAdvisor&quot;/&gt;</span><br><span class="line">    &lt;bean id=&quot;aop_bean&quot; class=&quot;org.springframework.aop.framework.ProxyFactoryBean&quot;&gt;</span><br><span class="line">        &lt;property name=&quot;proxyInterfaces&quot; value=&quot;cn.dombro.spring.aop.xml.Counter&quot;/&gt;</span><br><span class="line">        &lt;property name=&quot;target&quot;&gt;</span><br><span class="line">            &lt;bean class=&quot;cn.dombro.spring.aop.xml.CounterImple&quot;/&gt;</span><br><span class="line">        &lt;/property&gt;</span><br><span class="line">        &lt;property name=&quot;interceptorNames&quot;&gt;</span><br><span class="line">            &lt;list&gt;&lt;value&gt;advisor&lt;/value&gt;&lt;/list&gt;</span><br><span class="line">        &lt;/property&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br></pre></td></tr></table></figure><h4 id="ProxyFactoryBean-生成-AopProxy"><a href="#ProxyFactoryBean-生成-AopProxy" class="headerlink" title="ProxyFactoryBean 生成 AopProxy"></a>ProxyFactoryBean 生成 AopProxy</h4><p>前面说到 Spring AOP 其作用的第一件事就是 为目标对象生成代理。那么 ProxyFactoryBean 是如何生成代理的呢？ProxyFactoryBean 中，需要为 target 目标对象生成 Proxy 代理对象，从而为 AOP 横切面的编织做好准备。</p><ul><li>两种生成代理对象的方式</li></ul><p>ProxyFactoryBean 有两种生成代理对象 AopProxy 的方式一种是使用JDK动态代理，另一种是使用 CGLIB。你可以把这句话当成结论记住，可以想一下为什么要用两种方式？答案很简单，JDK 的动态代理 只能代理那些 实现某个接口的目标对象，而 CGLIB 可以为没有实现接口的目标对象生成代理。</p><p><img src="http://p0bl99g4r.bkt.clouddn.com/spring_aop_aoproxy.PNG" alt=""></p><p><em>图3 两种代理都实现了 AopProxy接口</em></p><ul><li>AopProxy 的生成过程</li></ul><p>由于 ProxyFactoryBean 实现了 FactoryBean 接口，而从 FactoryBean 中获取对象是以 getObject() 方法，作为入口完成的。所以理所当然，如果想通过 ProxyFactoryBean 获得 AopProxy 对象就一定会从 ProxyFactoryBean 实现的 getObject() 方法中寻找。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/***代码清单 10 ProxyFactoryBean 的 getObject ****/</span><br><span class="line">public Object getObject() throws BeansException &#123;</span><br><span class="line">    //这个方法对 ProxyFactoryBean 的 Advisor 链进行初始化</span><br><span class="line">    this.initializeAdvisorChain();</span><br><span class="line">    //这里针对单例也就是默认的目标对象生成代理对象</span><br><span class="line">    if (this.isSingleton()) &#123;</span><br><span class="line">        return this.getSingletonInstance();</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        if (this.targetName == null) &#123;</span><br><span class="line">            this.logger.warn(&quot;Using non-singleton proxies with singleton targets is often undesirable. Enable prototype proxies by setting the &apos;targetName&apos; property.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        //这里针对非单例的目标对象生成代理对象</span><br><span class="line">        return this.newPrototypeInstance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从代码清单10 中可以看到，getObject() 方法做了两个非常重要的事情。</p><ol><li><p>通过 initializeAdvisorChain()方法，将配置在 ProxyFactoryBean 的 Advisor 链进行初始化。<strong>这个初始化是把从 IoC 容器中获取到的 通知器 添加到 拦截器链中</strong>。这里简单记忆有个印象即可。</p></li><li><p>对目标对象生成代理对象 AopProxy ，针对目标对象的单例或和单例对应生成单件代理和非单件代理的方法。我们主要研究单件代理生成方式 getSingletonInstance();</p></li></ol><ul><li>getSingletonInstance() 生成单件代理对象</li></ul><href id="z1"><p>如上，ProxyFactoryBean 通过 在 getObject() 方法中调用　getSingletonInstance() 方法，为目标对象生成一个单例的代理。我们现在走进 getSingletonInstance 看一下这个代理是如何生成的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">/***代码清单11 getSingletonInstance 生成单例代理对象 ***/</span><br><span class="line">private synchronized Object getSingletonInstance() &#123;</span><br><span class="line">    if (this.singletonInstance == null) &#123;</span><br><span class="line">        this.targetSource = this.freshTargetSource();</span><br><span class="line">        if (this.autodetectInterfaces &amp;&amp; this.getProxiedInterfaces().length == 0 &amp;&amp; !this.isProxyTargetClass()) &#123;</span><br><span class="line">          //根据 AOP 框架判断需要代理的接口</span><br><span class="line">            Class&lt;?&gt; targetClass = this.getTargetClass();</span><br><span class="line">            if (targetClass == null) &#123;</span><br><span class="line">                throw new FactoryBeanNotInitializedException(&quot;Cannot determine target class for proxy&quot;);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            this.setInterfaces(ClassUtils.getAllInterfacesForClass(targetClass, this.proxyClassLoader));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        super.setFrozen(this.freezeProxy);</span><br><span class="line">        //2.这里使用 ProxyFactory 来生成 代理对象</span><br><span class="line">        this.singletonInstance = this.getProxy(this.createAopProxy());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return this.singletonInstance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//真正生成代理对象是使用 AopProxy.getProxy实现的 &lt;- 这句话很重要哦</span><br><span class="line">protected Object getProxy(AopProxy aopProxy) &#123;</span><br><span class="line">       return aopProxy.getProxy(this.proxyClassLoader);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>看上去貌似也没那么难，注意代码清单11 中的  17 行 通过 getProxy() 方法来生成代理对象，而其参数 是由 createAopProxy 返回的 AopProxy 对象。这里面又有什么玄机呢？createAopProxy 是在 ProxyCreatorSupport 定义，返回一个 AopProxy。只好点开 createAopProxy</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/***代码清单12 ProxyCreatorSupport 中的  createAopProxy ***/</span><br><span class="line">protected final synchronized AopProxy createAopProxy() &#123;</span><br><span class="line">    if (!this.active) &#123;</span><br><span class="line">        this.activate();</span><br><span class="line">    &#125;</span><br><span class="line">    //通过调用 AopProxyFactory 的 createAopProxy 方法得到 AopProxy 对象</span><br><span class="line">    return this.getAopProxyFactory().createAopProxy(this);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于代理对象的具体生成是 AopProxy 而生成，但 AopProxy 又有两种实现，JdkDynamicAopProxy 和 Cglib2AopProxy 两种方式。所以 ProxyCreatorSupport 的 createAopProxy 方法，会根据传入的 AdvisedSupport(这里传入this 是因为 ProxyCreatorSupport 实现了 AdvisedSupport) 来决定使用 JDK动态代理 还是 CGLIB 的方式生成代理。</p><ul><li>小结</li></ul><p>我觉的看到这你一定是蒙圈了，我用一句话总结，ProxyFactoryBean 生成代理对象由 getObject 方法中调用的 getSingletonInstance 方法为入口。而真正生成代理对象的是 AopProxy 的 getProxy 方法 ，具体使用哪种 AopProxy 生成 代理对象由 ProxyFactoryBean 的父类 AdvisedSupport 决定。</p><h4 id="JdkDynamicAopProxy-和-Cglib2AopProxy"><a href="#JdkDynamicAopProxy-和-Cglib2AopProxy" class="headerlink" title="JdkDynamicAopProxy 和 Cglib2AopProxy"></a>JdkDynamicAopProxy 和 Cglib2AopProxy</h4><p>上面说到 ProxyFactoryBean 会从 getObject 方法中的 getSingletonInstance 方法 成两种 AopProxy ，即 图3 中的 JdkDynamicAopProxy 和 Cglib2AopProxy 。其中 JdkDynamicAopProxy 使用动态代理为接口类型(实现接口类型)目标对象生成代理对象，而 Cglib2AopProxy 则通过第三方库可以为非接口类型目标对象生成代理对象。不过通过上一节我们知道，AopProxy 生成代理对象是通过 getProxy() 方法，<strong>所以无论  JdkDynamicAopProxy 还是 Cglib2AopProxy 我们只需要查看 getProxy() 中的代码就可以知道代理对象的生成过程了</strong>。</p><h5 id="代理对象的生成"><a href="#代理对象的生成" class="headerlink" title="代理对象的生成"></a>代理对象的生成</h5><ul><li>JdkDynamicAopProxy 生成 代理对象</li></ul><p>首先来看一下 基于 动态代理的 JdkDynamicAopProxy 是如何生成代理对象的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/***代码清单13 JdkDynamicAopProxy 生成代理对象***/</span><br><span class="line">public Object getProxy(ClassLoader classLoader) &#123;</span><br><span class="line">    if (logger.isDebugEnabled()) &#123;</span><br><span class="line">        logger.debug(&quot;Creating JDK dynamic proxy: target source is &quot; + this.advised.getTargetSource());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Class&lt;?&gt;[] proxiedInterfaces = AopProxyUtils.completeProxiedInterfaces(this.advised, true);</span><br><span class="line">    this.findDefinedEqualsAndHashCodeMethods(proxiedInterfaces);</span><br><span class="line">    //生成代理对象</span><br><span class="line">    return Proxy.newProxyInstance(classLoader, proxiedInterfaces, this);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以看到 JdkDynamicAopProxy 和 代码清单3 中的自定义动态代理类中的 blind 几乎是一样的。还可以得出一个结论 JdkDynamicAopProxy 一定实现了 InvocationHandler 接口,对，就是通过那个 this 。</p><ul><li>Cglib2AopProxy 生成代理对象</li></ul><p>具体参见 Cglib2AopProxy.getProxy() 方法，CGLIB 原理我也不是很懂，不敢瞎比比..(T_ T)。</p><h5 id="Spring-AOP-拦截器的调用"><a href="#Spring-AOP-拦截器的调用" class="headerlink" title="Spring AOP 拦截器的调用"></a>Spring AOP 拦截器的调用</h5><p>首先，一句结论 : 在 Spring AOP 通过 JdkDynamicAopProxy 或 Cglib2AopProxy 生成 代理对象的时候，相关的拦截器已经配置到代理对象中去了，拦截器在代理对象中起的作用是通过对这些方法的回调完成的。上述两种 AopProxy 拦截的方式是不一样的。</p><ul><li>拦截器、拦截器链</li></ul><p>关于什么是拦截器，实际上拦截器 就是 Spring AOP 将 Advisor 配置给代理对象起到拦截目标方法方法的对象。也就是说代理对象通过拦截器知道要对目标对象的哪些目标方法进行哪种通知。<strong>对目标方法的增强就是通过拦截器完成的</strong>。这句话可以当做结论记下来。<strong>拦截器链，就是配置的所有拦截器的集合</strong>。</p><h6 id="AopProxy-的拦截"><a href="#AopProxy-的拦截" class="headerlink" title="AopProxy 的拦截"></a>AopProxy 的拦截</h6><p>拦截，拦截什么呢？当然是拦截目标方法，实际上这个拦截的过程就是面向切面的过程。还记的原生代理类中我们在哪里对目标方法进行拦截吗？invoke 方法 。Spring  的 JdkDynamicAopProxy 也是在 invoke 方法中实现的拦截，但复杂得多。</p><ul><li>JdkDynamicAopProxy 的 invoke 拦截</li></ul><p>如果使用 JdkDynamicAopProxy 生成代理对象，则需要实现 InvocationHandler 的 invoke 方法设置拦截器的回调。这和代码清单3 中的原生 代理类是一样的。</p><href id="z2"><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">/***代码清单14 JdkDynamicAopProxy 的 invoke 回调***/</span><br><span class="line">public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line">        Object oldProxy = null;</span><br><span class="line">        boolean setProxyContext = false;</span><br><span class="line">        TargetSource targetSource = this.advised.targetSource;</span><br><span class="line">        Class&lt;?&gt; targetClass = null;</span><br><span class="line">        Object target = null;</span><br><span class="line"></span><br><span class="line">        Boolean var10;</span><br><span class="line">        try &#123;</span><br><span class="line">            if (this.equalsDefined || !AopUtils.isEqualsMethod(method)) &#123;</span><br><span class="line">                if (!this.hashCodeDefined &amp;&amp; AopUtils.isHashCodeMethod(method)) &#123;</span><br><span class="line">                    Integer var20 = this.hashCode();</span><br><span class="line">                    return var20;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                if (method.getDeclaringClass() == DecoratingProxy.class) &#123;</span><br><span class="line">                    Class var18 = AopProxyUtils.ultimateTargetClass(this.advised);</span><br><span class="line">                    return var18;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                Object retVal;</span><br><span class="line">                if (!this.advised.opaque &amp;&amp; method.getDeclaringClass().isInterface() &amp;&amp; method.getDeclaringClass().isAssignableFrom(Advised.class)) &#123;</span><br><span class="line">                    retVal = AopUtils.invokeJoinpointUsingReflection(this.advised, method, args);</span><br><span class="line">                    return retVal;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                if (this.advised.exposeProxy) &#123;</span><br><span class="line">                    oldProxy = AopContext.setCurrentProxy(proxy);</span><br><span class="line">                    setProxyContext = true;</span><br><span class="line">                &#125;</span><br><span class="line">                //1.得到目标对象</span><br><span class="line">                target = targetSource.getTarget();</span><br><span class="line">                if (target != null) &#123;</span><br><span class="line">                    targetClass = target.getClass();</span><br><span class="line">                &#125;</span><br><span class="line">                //1.通过 AdvisedSupport 获取目标方法的拦截器链。</span><br><span class="line">                List&lt;Object&gt; chain = this.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass);</span><br><span class="line">                //2.如果拦截器链是空的，则直接调用目标方法</span><br><span class="line">                if (chain.isEmpty()) &#123;</span><br><span class="line">                    Object[] argsToUse = AopProxyUtils.adaptArgumentsIfNecessary(method, args);</span><br><span class="line">                    //这里是对目标方法的调用</span><br><span class="line">                    retVal = AopUtils.invokeJoinpointUsingReflection(target, method, argsToUse);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                //3.如果有拦截器链，则将代理对象，目标对象，目标方法，方法参数，</span><br><span class="line">                //以及拦截器链封装为一个 MethodInvocation 对象</span><br><span class="line">                    MethodInvocation invocation = new ReflectiveMethodInvocation(proxy, target, method, args, targetClass, chain);</span><br><span class="line">                //4.invocation.proceed 方法会沿着拦截器链向前执行      </span><br><span class="line">                    retVal = invocation.proceed();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                Class&lt;?&gt; returnType = method.getReturnType();</span><br><span class="line">                if (retVal != null &amp;&amp; retVal == target &amp;&amp; returnType != Object.class &amp;&amp; returnType.isInstance(proxy) &amp;&amp; !RawTargetAccess.class.isAssignableFrom(method.getDeclaringClass())) &#123;</span><br><span class="line">                    retVal = proxy;</span><br><span class="line">                &#125; else if (retVal == null &amp;&amp; returnType != Void.TYPE &amp;&amp; returnType.isPrimitive()) &#123;</span><br><span class="line">                    throw new AopInvocationException(&quot;Null return value from advice does not match primitive return type for: &quot; + method);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                Object var13 = retVal;</span><br><span class="line">                return var13;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            var10 = this.equals(args[0]);</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            if (target != null &amp;&amp; !targetSource.isStatic()) &#123;</span><br><span class="line">                targetSource.releaseTarget(target);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (setProxyContext) &#123;</span><br><span class="line">                AopContext.setCurrentProxy(oldProxy);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return var10;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>代码清14 的重点有三处:</p><ol><li>当目标方法不存在拦截器链时,将直接调用目标方法。这个目标方法的调用是 <code>AopUtils.invokeJoinpointUsingReflection()</code>  方法。</li><li>拦截器链是通过 AdvisedSupport.getInterceptorsAndDynamicInterceptionAdvice()方法得到的，传入的参数是 目标方法 和 一个类加载器。</li><li>将拦截器链、目标方法、目标对象、目标方法参数作为参数，构造出一个 ReflectiveMethodInvocation 对象，在执行 MethodInvocation.proceed 方法，这个方法会按照拦截器链的方向向前执行。</li></ol><p>以上三个发现的结论是很重要的。</p><ul><li>Cglib2AopProxy 的 intercept 拦截</li></ul><p>Cglib2AopProxy 对 目标方法的拦截和 JdkDynamicAopProxy 的方式十分类似。这里就只说下区别：</p><ol><li>Cglib2AopProxy 的拦截器回调发生在 intercept 方法中。</li><li>Cglib2AopProxy 对拦截器链的调用通过构造 CglibMethodInvocation 对象完成的。</li></ol><h6 id="拦截器链的调用"><a href="#拦截器链的调用" class="headerlink" title="拦截器链的调用"></a>拦截器链的调用</h6><p>Spring AOP 对目标对象的增强的实现封装在拦截器链中，有一个个具体的拦截器来完成。那么究竟是如何实现的呢？通过上一节我们知道，无论是 JdkDynamicAopProxy 还是 Cglib2AopProxy 对拦截器链的调用都是殊途同归，通过 ReflectiveMethodInvocation 对象的 proceed 方法。一起来看一下：</p><p><href id="h15"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">/***代码清单 15 ReflectiveMethodInvocation 的 proceed 方法***/</span><br><span class="line">public Object proceed() throws Throwable &#123;</span><br><span class="line">    //0.如果拦截器链中的迭代器调用完毕，这里开始调用目标方法</span><br><span class="line">    if (this.currentInterceptorIndex == this.interceptorsAndDynamicMethodMatchers.size() - 1) &#123;</span><br><span class="line">        return this.invokeJoinpoint();</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">       //1.从拦截器链中第一个拦截器开始</span><br><span class="line">        Object interceptorOrInterceptionAdvice = this.interceptorsAndDynamicMethodMatchers.get(++this.currentInterceptorIndex);</span><br><span class="line">        if (interceptorOrInterceptionAdvice instanceof InterceptorAndDynamicMethodMatcher) &#123;</span><br><span class="line">          //2. 对拦截器进行动态判断，如果和定义的 Pointcut 一致，那么 Advice 将会执行。</span><br><span class="line">          //如果不匹配，那么递归调用 proceed， 直到所有拦截器都被运行过为止。    </span><br><span class="line">            InterceptorAndDynamicMethodMatcher dm = (InterceptorAndDynamicMethodMatcher)interceptorOrInterceptionAdvice;</span><br><span class="line">            return dm.methodMatcher.matches(this.method, this.targetClass, this.arguments) ? dm.interceptor.invoke(this) : this.proceed();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return ((MethodInterceptor)interceptorOrInterceptionAdvice).invoke(this);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></href></p><p>以上就是整个拦截器目标方法被调用的过程。有点神奇耶，我们看到ReflectiveMethodInvocation.proceed 方法会遍历拦截器链里面的所有拦截器，<strong>如果拦截器中切入点和当前要调用的匹配就执行拦截器的 invoke 方法。如果拦截器中的切入点和当前方法不匹配，则按照 ReflectiveMethodInvocation 的 proceed 方法，继续下一个拦截器</strong>。在下面会介绍拦截器的 inbvoke 方法。当所有拦截器都遍历完了，就执行目标方法！多么精巧的设计。</p><h5 id="拦截器链的生成"><a href="#拦截器链的生成" class="headerlink" title="拦截器链的生成"></a>拦截器链的生成</h5><p>上面直接讲了 拦截器链的调用 而跳过了 拦截器的生成这部分。这里来简单补充一下。</p><ol><li>首先拦截器链是由 AdvisedSupport.getInterceptorsAndDynamicInterceptionAdvice() 方法得到的(上面提到了)。</li><li>而在上述方法中生成 拦截器链 则是由配置好的生成拦截器链的工厂 DefaultAdvisorChainFactory. getInterceptorsAndDynamicInterceptionAdvice() 生成。拦截器工厂生成拦截器则需要 通知器链。一起来看一下</li></ol><href id="z4"><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">/***代码清单16 DefaultAdvisorChainFactory 生成拦截器链***/</span><br><span class="line">public List&lt;Object&gt; getInterceptorsAndDynamicInterceptionAdvice(Advised config, Method method, Class&lt;?&gt; targetClass) &#123;</span><br><span class="line">    //1.首先通过 config 得到通知器链</span><br><span class="line">    List&lt;Object&gt; interceptorList = new ArrayList(config.getAdvisors().length);</span><br><span class="line">    Class&lt;?&gt; actualClass = targetClass != null ? targetClass : method.getDeclaringClass();</span><br><span class="line">    boolean hasIntroductions = hasMatchingIntroductions(config, actualClass);</span><br><span class="line">    AdvisorAdapterRegistry registry = GlobalAdvisorAdapterRegistry.getInstance();</span><br><span class="line">    Advisor[] var8 = config.getAdvisors();</span><br><span class="line">    int var9 = var8.length;</span><br><span class="line"></span><br><span class="line">    for(int var10 = 0; var10 &lt; var9; ++var10) &#123;</span><br><span class="line">        Advisor advisor = var8[var10];</span><br><span class="line">        MethodInterceptor[] interceptors;</span><br><span class="line">        if (advisor instanceof PointcutAdvisor) &#123;</span><br><span class="line">            PointcutAdvisor pointcutAdvisor = (PointcutAdvisor)advisor;</span><br><span class="line">            if (config.isPreFiltered() || pointcutAdvisor.getPointcut().getClassFilter().matches(actualClass)) &#123;</span><br><span class="line">              //2.看到拦截器是通过 AdvisorAdapterRegistry 对象的 getInterceptors 方法让针对通知器</span><br><span class="line">              //生成拦截器的。&lt;- 这个方法很重要！</span><br><span class="line">                interceptors = registry.getInterceptors(advisor);</span><br><span class="line">                MethodMatcher mm = pointcutAdvisor.getPointcut().getMethodMatcher();</span><br><span class="line">                if (MethodMatchers.matches(mm, method, actualClass, hasIntroductions)) &#123;</span><br><span class="line">                    if (mm.isRuntime()) &#123;</span><br><span class="line">                        MethodInterceptor[] var15 = interceptors;</span><br><span class="line">                        int var16 = interceptors.length;</span><br><span class="line"></span><br><span class="line">                        for(int var17 = 0; var17 &lt; var16; ++var17) &#123;</span><br><span class="line">                            MethodInterceptor interceptor = var15[var17];</span><br><span class="line">                            interceptorList.add(new InterceptorAndDynamicMethodMatcher(interceptor, mm));</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        interceptorList.addAll(Arrays.asList(interceptors));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else if (advisor instanceof IntroductionAdvisor) &#123;</span><br><span class="line">            IntroductionAdvisor ia = (IntroductionAdvisor)advisor;</span><br><span class="line">            if (config.isPreFiltered() || ia.getClassFilter().matches(actualClass)) &#123;</span><br><span class="line">                interceptors = registry.getInterceptors(advisor);</span><br><span class="line">                interceptorList.addAll(Arrays.asList(interceptors));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            Interceptor[] interceptors = registry.getInterceptors(advisor);</span><br><span class="line">            interceptorList.addAll(Arrays.asList(interceptors));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return interceptorList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上，在代码清单16 中，最值得研究的就是利用 AdvisorAdapterRegistry 对象的 getInterceptors ，即 registry.getInterceptors(advisor) 方法 ，从通知器得到拦截器。这里用到了适配器模式。下面会详细讲解。值得注意的是，我们看到拦截器链的生成</p><ol><li>通知器链从哪里生成的？还记得 ProxyFactoryBean 的 getObject 中的 initializeAdvisorChain() 方法吗? 一起来看一下:</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">/***代码清单 17 ProxyFactoryBean 的初始化 通知器链***/</span><br><span class="line">private synchronized void initializeAdvisorChain() throws AopConfigException, BeansException &#123;</span><br><span class="line">       if (!this.advisorChainInitialized) &#123;</span><br><span class="line">           if (!ObjectUtils.isEmpty(this.interceptorNames)) &#123;</span><br><span class="line">               if (this.beanFactory == null) &#123;</span><br><span class="line">                   throw new IllegalStateException(&quot;No BeanFactory available anymore (probably due to serialization) - cannot resolve interceptor names &quot; + Arrays.asList(this.interceptorNames));</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               if (this.interceptorNames[this.interceptorNames.length - 1].endsWith(&quot;*&quot;) &amp;&amp; this.targetName == null &amp;&amp; this.targetSource == EMPTY_TARGET_SOURCE) &#123;</span><br><span class="line">                   throw new AopConfigException(&quot;Target required after globals&quot;);</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               String[] var1 = this.interceptorNames;</span><br><span class="line">               int var2 = var1.length;</span><br><span class="line"></span><br><span class="line">               for(int var3 = 0; var3 &lt; var2; ++var3) &#123;</span><br><span class="line">                   String name = var1[var3];</span><br><span class="line">                   if (this.logger.isTraceEnabled()) &#123;</span><br><span class="line">                       this.logger.trace(&quot;Configuring advisor or advice &apos;&quot; + name + &quot;&apos;&quot;);</span><br><span class="line">                   &#125;</span><br><span class="line"></span><br><span class="line">                   if (name.endsWith(&quot;*&quot;)) &#123;</span><br><span class="line">                       if (!(this.beanFactory instanceof ListableBeanFactory)) &#123;</span><br><span class="line">                           throw new AopConfigException(&quot;Can only use global advisors or interceptors with a ListableBeanFactory&quot;);</span><br><span class="line">                       &#125;</span><br><span class="line"></span><br><span class="line">                       this.addGlobalAdvisor((ListableBeanFactory)this.beanFactory, name.substring(0, name.length() - &quot;*&quot;.length()));</span><br><span class="line">                   &#125; else &#123;</span><br><span class="line">                     //这里才是重点</span><br><span class="line">                       Object advice;</span><br><span class="line">                       if (!this.singleton &amp;&amp; !this.beanFactory.isSingleton(name)) &#123;</span><br><span class="line">                     //1.看，通过 BeanFactory 获得 interceptorNames 这个 List 中的每个 Advisor</span><br><span class="line">                     //的名字,交给BeanFactory，再通过 getBean 去获取</span><br><span class="line">                           advice = new ProxyFactoryBean.PrototypePlaceholderAdvisor(name);</span><br><span class="line">                       &#125; else &#123;</span><br><span class="line">                           advice = this.beanFactory.getBean(name);</span><br><span class="line">                       &#125;</span><br><span class="line">                      //2.将得到的所有 Advisor 加入到通知链中</span><br><span class="line">                       this.addAdvisorOnChainCreation(advice, name);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           this.advisorChainInitialized = true;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>通过代码清单17 我们知道了 Advisor 的获取是通过 IoC 容器完成的，多么精巧的设定。</p><h4 id="从-Advice-通知得到-Interceptor-拦截器"><a href="#从-Advice-通知得到-Interceptor-拦截器" class="headerlink" title="从 Advice 通知得到 Interceptor 拦截器"></a>从 Advice 通知得到 Interceptor 拦截器</h4><p>前面通过 代码清单16 ，已经介绍了这个很重要的方法 AdvisorAdapterRegistry.getInterceptors 方法，会根据 Advisor 得到 拦截器 Interceptor,但具体的实现是在 DefaultAdvisorAdapterRegistry 对象中，</p><p><href id="z3"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">/***代码清单 18 DefaultAdvisorAdapterRegistry 中的适配注册 拦截器方法***/</span><br><span class="line">//这里实在 DefaultAdvisorChainFactory 中启动的 getInterceptors 的地方</span><br><span class="line">public MethodInterceptor[] getInterceptors(Advisor advisor) throws UnknownAdviceTypeException &#123;</span><br><span class="line">    List&lt;MethodInterceptor&gt; interceptors = new ArrayList(3);</span><br><span class="line">    //1.从 通知器中得到 通知</span><br><span class="line">    Advice advice = advisor.getAdvice();</span><br><span class="line">    //2.如果是 MethodInterceptor 类型通知，直接加入 interceptors 的 List 中不适配</span><br><span class="line">    if (advice instanceof MethodInterceptor) &#123;</span><br><span class="line">        interceptors.add((MethodInterceptor)advice);</span><br><span class="line">    &#125;</span><br><span class="line">    //3.得到是配置的 Adapter 迭代器，此处配置好的 Adapter 有 :</span><br><span class="line">    // MethodBeforeAdviceAdapter，AfterReturningAdviceInterceptor,ThrowsAdviceInterceptor</span><br><span class="line">    Iterator var4 = this.adapters.iterator();</span><br><span class="line"></span><br><span class="line">    while(var4.hasNext()) &#123;</span><br><span class="line">      //3.使用 AdvisorAdapter 进行适配</span><br><span class="line">        AdvisorAdapter adapter = (AdvisorAdapter)var4.next();</span><br><span class="line">      //4.从 Advice 中得到的其对应的 Adapter 适配器，再从该适配器中取出已经封装好了的 拦截器。</span><br><span class="line">        if (adapter.supportsAdvice(advice)) &#123;</span><br><span class="line">            interceptors.add(adapter.getInterceptor(advisor));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (interceptors.isEmpty()) &#123;</span><br><span class="line">        throw new UnknownAdviceTypeException(advisor.getAdvice());</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return (MethodInterceptor[])interceptors.toArray(new MethodInterceptor[interceptors.size()]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></href></p><p>看这部分的时候。一定要看 代码清单18 中的注释，DefaultAdvisorAdapterRegistry 的 getInterceptors 方法说白了通过 通知 Advisor 中的 不同通知类型，利用适配器模式生成不同类型的拦截器。不同类型的拦截器的 invoke 方法实现各有不同，用来达到以哪种形式进行增强的目的。</p><p>举个例子：Advisor 中的通知 Advice 如果是 前置通知 就生成 MethodBeforeAdviceInterceptor 拦截器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/***代码清单 19  MethodBeforeAdviceInterceptor 拦截器***/</span><br><span class="line">public class MethodBeforeAdviceInterceptor implements MethodInterceptor, Serializable &#123;</span><br><span class="line">    private MethodBeforeAdvice advice;</span><br><span class="line"></span><br><span class="line">    public MethodBeforeAdviceInterceptor(MethodBeforeAdvice advice) &#123;</span><br><span class="line">        Assert.notNull(advice, &quot;Advice must not be null&quot;);</span><br><span class="line">        this.advice = advice;</span><br><span class="line">    &#125;</span><br><span class="line">    //注意这个方法！是真正实现对目标方法增强的部分</span><br><span class="line">    public Object invoke(MethodInvocation mi) throws Throwable &#123;</span><br><span class="line">       //首先调用了advice  的前置增强</span><br><span class="line">        this.advice.before(mi.getMethod(), mi.getArguments(), mi.getThis());</span><br><span class="line">        //执行过后会让整个拦截器链向前执行</span><br><span class="line">        return mi.proceed();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Advisor 中的通知 Advice 如果是 返回通知 就生成 AfterReturningAdviceInterceptor 拦截器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/***代码清单 20 AfterReturningAdviceInterceptor 拦截器***/</span><br><span class="line">public class AfterReturningAdviceInterceptor implements MethodInterceptor, AfterAdvice, Serializable &#123;</span><br><span class="line">    private final AfterReturningAdvice advice;</span><br><span class="line"></span><br><span class="line">    public AfterReturningAdviceInterceptor(AfterReturningAdvice advice) &#123;</span><br><span class="line">        Assert.notNull(advice, &quot;Advice must not be null&quot;);</span><br><span class="line">        this.advice = advice;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Object invoke(MethodInvocation mi) throws Throwable &#123;</span><br><span class="line">        //先让拦截器链向前执行</span><br><span class="line">        Object retVal = mi.proceed();</span><br><span class="line">        //之后调用后置增强</span><br><span class="line">        this.advice.afterReturning(retVal, mi.getMethod(), mi.getArguments(), mi.getThis());</span><br><span class="line">        return retVal;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们看到不同的拦截器，首先一定要注意到 invoke() 方法，结合 <a href="#h15">代码清单15</a> 看到的 Interceptor.invoke() 的调用，再以方法前置拦截器 MethodBeforeAdviceInterceptor 中的 invoke()为例，我们看到 方法前置拦截器会首先出发 Advice.before 的回调，然后在执行 MethodInvocation.proceed ，整个拦截器链向前运行，当某个拦截器对目标方法匹配，同样会执行该拦截器的 invoke 方法，所以拦截器的 invoke 方法是真正实现切面增强的地方。啊！多么精巧的设计！！！</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>一些总结(想起什么说什么)</li></ul><p>0.一些专业术语就不总结了。打字累。<br>1.Spring AOP 中一个重要对象 Advisor 通知器。它是由 Advice 通知 和 Pointcut 切点构成。Advisor 决定了要在哪个 目标方法 进行那种类型的切面增强。Advisor 就像是一个作战计划，有了 Advisor 还不能实现真正意义上的切面增强。<br>2.AOP 实现的核心是靠动态代理生成代理对象(很多书都不把这句话说完整，歧义很大的)，Spring AOP 有两种生成代理对象的方法，使用 JDK 动态代理 的 JdkDynamicAopProxy 和 使用 第三方库的 cglib 的 Cglib2AopProxy。之所以会有两种生成代理对象的策略，是因为 JDk 动态代理只能为实现某接口的类生成代理对象，而 cglib 则可以为任何类生成代理对象。<br>3.生成代理对象的入口是 ProxyFactoryBean 的 getObject() 方法，该方法也是使用首先调用 initializeAdvisorChain() 方法，完成 通知器链的初始化，然后 调用 getSingletonInstance () 方法，获取代理对象。<br>4.getSingletonInstance()的原理是调用 AopProxy.getProxy() 生成代理对象。调用 ProxyFactoryBean.createAopProxy 返回的两种不同的 生成代理类 JdkDynamicAopProxy 和 Cglib2AopProxy。在调用这两个类的 getProxy 方法。具体操作可以。<a href="#z1">戳这里</a><br>5.Spring AOP 完成对目标方法的增强是靠拦截器，JdkDynamicAopProxy 中实现对目标方法的拦截是在 invoke 方法中。在 invoke 方法中 通过 AdvisedSupport.getInterceptorsAndDynamicInterceptionAdvice() 方法获取拦截器链。并将拦截器链配置成 MethodInvocation 对象，然后调用 MethodInvocation.proceed() 方法，实现对拦截器的向前调用。<a href="#z2">戳这里</a> 真正生成 拦截器链的 地方是 DefaultAdvisorChainFactory.getInterceptorsAndDynamicInterceptionAdvice() 方法。<a href="#z4">戳这里</a><br>6.MethodInvocation.proceed()方法首先会检查当前拦截器是否和调用的方法匹配，如果匹配，则执行该拦截器的invoke方法。拦截器的 invoke 方法是真正实现切面增强的地方。<a href="#h15">戳这里</a><br>7.至于拦截器链如何生成，拦截器是在  GlobalAdvisorAdapterRegistry 的 getInterceptors 方法生产给你目标方法的所有拦截器，这个方法需要传入一个通知器 Advisor 作为参数，即通过 Advisor 生成 目标方的所有拦截器，再将这些拦截器添加到一个 List 中，形成了拦截器链。<a href="#z4">戳这里</a><br>8.在 GlobalAdvisorAdapterRegistry.getInterceptors(advisor)方法中,使用适配器模式 为不同的通知器生成不同拦截器，不同的拦截器的 invoke 方法是不一样的，<a href="#z3">戳这里</a><br>9.ProxyFactoryBean.initializeAdvisorChain() 方法，通过 BeanFactory 从 XML 配置中获取 所有 Advisor 便将其组成 通知器链，并将其交给 AdvisedSupport 持有。通知器链为后面拦截器链的生成提供了原材料，所以 Advisor 是很重要的对象。</p><ul><li>一点感受</li></ul><p>咳咳！一个不小心写了这么长的笔记。昨晚还刷了一个夜。起初看 Spring AOP 这里我很崩溃！满脑子都再说：啥！啥！啥！这都是个啥！究其原因，是因为当时对 AOP 和动态代理 这的概念有些模糊。弄清楚 AOP 后，我已经完全被好奇心驱使，开始去看源码。没有看得那么细，但是 Spring 的命名规范，不需要一个方法一个方法的去看。了解大概意思和思想那就好了。看过这篇笔记的同学一定会发现，笔记说的最多的一句话就是 ：啊！多么精巧的设计！是的，Spring 得开发人员实在是太牛了。</p></href></href></href>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Spring的核心-——-AOP&quot;&gt;&lt;a href=&quot;#Spring的核心-——-AOP&quot; class=&quot;headerlink&quot; title=&quot;Spring的核心 —— AOP&quot;&gt;&lt;/a&gt;Spring的核心 —— AOP&lt;/h2&gt;&lt;h3 id=&quot;前言&quot;&gt;&lt;a hr
      
    
    </summary>
    
    
      <category term="Spring技术内幕" scheme="http://yoursite.com/tags/Spring%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95/"/>
    
  </entry>
  
  <entry>
    <title>Java并发编程基础.md</title>
    <link href="http://yoursite.com/2018/04/13/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"/>
    <id>http://yoursite.com/2018/04/13/Java并发编程基础/</id>
    <published>2018-04-13T11:26:20.000Z</published>
    <updated>2018-04-19T12:28:59.100Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Java-并发编程基础"><a href="#Java-并发编程基础" class="headerlink" title="Java 并发编程基础"></a>Java 并发编程基础</h2><h3 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h3><p>最近在撸 《Java并发编程的艺术》这本书，原因有二。其一，并发、线程、是一名 Java 后台人员永远无法跳过绕开的话题；其二，最近面试被所有面试官统统被问到并发，遂下定决心，用心去看一下，我并不想去刷面试题糊弄面试官。</p><h3 id="是本好书"><a href="#是本好书" class="headerlink" title="是本好书"></a>是本好书</h3><p>不得不承认 《Java并发编程的艺术》 是一本好书，与我所看过的讲解线程的博客不同，作者几乎用前三章在解释很底层的问题 —— Java 并发究竟是什么、虚拟机和系统如何让线程并发的工作。尤其是第三章 —— Java 内存模型，简直底层的不要不要的。前三章使用检视阅读看了一点，在了解了一些名词含义后毅然决然开始了第四章。</p><h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p>作者介绍了了什么是线程。这里我跳了，因为我知道什么是线程啊。<a href="https://dombro96.github.io/2018/03/11/线程" target="_blank" rel="noopener">之前还做过笔记 ，戳我跳转</a></p><h3 id="线程间的通信"><a href="#线程间的通信" class="headerlink" title="线程间的通信"></a>线程间的通信</h3><p>线程间的通信不是想象中你一言我一语的瞎唠嗑，而是一个线程可以从另一个线程中得到一些有价值有意义的东西。线程的通信可以让线程相互配合的完成工作，这会变得很有价值。所以请记住本节的关键字——<strong>通信</strong>。</p><ul><li>线程的栈空间</li></ul><p>再继续进行之前，你需要知道一件事情，<strong>每个线程都有一个自己的栈空间</strong>，按照代码一步一步的执行<br>。</p><ul><li>本地内存</li></ul><p>线程虽然共享内存，但是每个线程还是只有自己的 “私密空间” 的，这个私密空间可以用来存储共享变量的副本，我们叫这个私密空间为本地内存。本地内存只是 JMM (Java Memory Model) 中的一个抽象概念，并不真实存在的。这个本地内存可以放置共享变量的拷贝，这样做肯定是为了加速程序执行。</p><h4 id="volatile-和-sychronized"><a href="#volatile-和-sychronized" class="headerlink" title="volatile 和 sychronized"></a>volatile 和 sychronized</h4><p>本节你会看到 volatile 和 sychronized 这两个关键字是如何使线程通信的。</p><h5 id="volatile-关键字"><a href="#volatile-关键字" class="headerlink" title="volatile 关键字"></a>volatile 关键字</h5><p>是的，你可能从来没有见过这个关键字，或者从来没使用过这个关键字(我也一样 T_ T)。但是，如果告诉你 <strong>volatile 关键字是实现并发编程中扮演着重要角色</strong>，你慌不慌？</p><ul><li>一个场景&amp;问题的提出</li></ul><p>为什么要在上面介绍本地内存这样一个概念呢 ? 我们知道，每个线程为了更快速地执行程序，会把主内存中的共享变量拷贝到线程的本地内存中，然后读取本地内存中的共享变量即可。然而在多线程下，共享变量 x 有可能在主内存中被 线程A 拷贝到本地内存后，线程B 修改了主内存中的 共享变量 x，但是线程A 却并不知道 x 的值已经改变了，继续本地内存中读取 x 的拷贝，这一定会造成程序出错。<strong>因此在程序执行过程中一个线程看到的变量不一定是最新的</strong>，如何解决？</p><ul><li>volatile 的作用&amp;问题的解决</li></ul><p>上面的问题答案很好给出，只要让线程都去读取 主内存 中的共享变量不就得了。没有错 关键字volatile 就是起这个作用的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/**代码示例 1 使用 volatile 关键字修饰字段**/</span><br><span class="line">volatile boolean flag = true;</span><br></pre></td></tr></table></figure><p>像代码示例一中使用 volatile 修饰字段，就会让内存模型中所有线程在读取该变量时，在主内存中读取，从每个线程都会得到最新的共享变量值。 <strong>通过这种方法，volatile关键字让修改 线程A 读取到看了 被线程B 修改后的 共享变量x，达到了线程通信的目的。</strong> 需要注意的是，禁令避免大量使用 volatile 关键字，会影响效率。</p><h4 id="sychronized-关键字"><a href="#sychronized-关键字" class="headerlink" title="sychronized 关键字"></a>sychronized 关键字</h4><p>我想这个关键字不会像 volatile 那么陌生，同样 sychronized 也是并发编程中的重要角色，我们一般叫他同步锁。那么它是如何让线程间进行通信的呢？</p><ul><li>sychronized 通信的内容</li></ul><p>众所周知，sychronized 可以修饰用来修饰方法，也可以把使用 sychronized 同步代码块。这两种方式都可以实现同步。同步的意思可以理解为一个被同步访问的对象一次只可以被一个线程访问，其他线程需要等待。<strong>那好了， sychronized 在线程间的通信内容就是一个线程告诉另一个线程”嘿，哥们，我正在访问这个对象，你排队去!”</strong>。</p><ul><li>Monitor 监视器</li></ul><p>知道了使用 sychronized 关键字在线程间的通信内容，我们来看一下原理。虽然同步方法和同步代码块实现同步的细节不一样，但是其原理都是一样滴，<strong>本质都是线程对一个对象(被同步对象)的监视器 Monitor 进行获取，这个获取过程是排他性的，即在一个时刻只能有一个线程获取到 sychronized 保护对象的监视器</strong>。如果获取监视器失败的线程，则会进入等待队列。对了，每个对象都有自己的监听器。这个监听器是在底层实现的，你只知道有这样一个东东就可以了。</p><ul><li>感受</li></ul><p>以前从来没觉得 sychronized 是在线程通信的额范畴之内，只知道使用，知道现在才突然明白。就算是同步也要在线程通信的基础上才可以完成。</p><h4 id="等待-通知"><a href="#等待-通知" class="headerlink" title="等待/通知"></a>等待/通知</h4><p>如果一个线程改变了一个值，而另一个线程感受到了变化，然后进行相应操作，<strong>整个过程开始于一个线程，而最终执行又是另一个线程。前者是生产者，后者是消费者</strong>，这种模式隔离了”做什么”和”怎么做”，在功能上实现了解耦。在 Java 语言中使用 Object.wait() 和 Object.notify() 即等待通知来实现(这方法一定是见过的)。</p><ul><li>等待通知机制</li></ul><p>等待通知机制是指当 线程A 调用 对象O 的wait()方法进入等待状态，线程B 调用 对象O 的 notify() 或 notifyAll()，线程A 收到通知后从 wati() 方法返回执行下一步操作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 代码清单2 一个简单的等待通知的例子</span><br><span class="line"> */</span><br><span class="line">public class WaitNotify &#123;</span><br><span class="line"></span><br><span class="line">    static boolean flag = true;</span><br><span class="line">    static Object lock = new Object();</span><br><span class="line"></span><br><span class="line">    //等待的线程，等待的条件是 flag = true</span><br><span class="line">    static class Wait implements Runnable&#123;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            //在 lock 上加锁</span><br><span class="line">            synchronized (lock)&#123;</span><br><span class="line">               //当条件不满足时，继续wait()</span><br><span class="line">                while (flag)&#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        System.out.println(Thread.currentThread()+&quot;flag is true ,wait &quot;+ LocalDateTime.now().toString());</span><br><span class="line">                        lock.wait();</span><br><span class="line">                    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                     &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                //当条件满足时，完成工作</span><br><span class="line">                System.out.println(Thread.currentThread()+&quot;flag is false ,run &quot;+ LocalDateTime.now().toString());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    static class Notify implements Runnable&#123;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            synchronized (lock)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread() + &quot; hold lock . notify &quot; + LocalDateTime.now().toString());</span><br><span class="line">                //通知，但注意此时并不会释放lock的锁，即不会直接执行 wait 线程</span><br><span class="line">                lock.notifyAll();</span><br><span class="line">                //修改条件</span><br><span class="line">                flag = false;</span><br><span class="line">                try &#123;</span><br><span class="line">                    //休眠五秒</span><br><span class="line">                    Thread.sleep(5000);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            //再次加锁</span><br><span class="line">            synchronized (lock)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread()+&quot; hold lock .again sleep &quot; + LocalDateTime.now().toString());</span><br><span class="line">                //休眠五秒</span><br><span class="line">                try &#123;</span><br><span class="line">                    Thread.sleep(5000);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                 &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        Thread waitThread = new Thread(new Wait(),&quot;WaitThread&quot;);</span><br><span class="line">        waitThread.start();</span><br><span class="line"></span><br><span class="line">        TimeUnit.SECONDS.sleep(1);</span><br><span class="line"></span><br><span class="line">        Thread notifyThread = new Thread(new Notify(),&quot;NotifyThread&quot;);</span><br><span class="line">        notifyThread.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Thread[WaitThread,5,main]flag is true ,wait 2018-04-19T14:44:23.727</span><br><span class="line">Thread[NotifyThread,5,main] hold lock . notify 2018-04-19T14:44:24.711</span><br><span class="line">Thread[WaitThread,5,main]flag is false ,run 2018-04-19T14:44:29.711</span><br><span class="line">Thread[NotifyThread,5,main] hold lock .again sleep 2018-04-19T14:44:29.711</span><br></pre></td></tr></table></figure><p>运行结果的第三行和第四行顺序可能会调换。通过这个简单的例子来阐述一下等待通知的几个细节</p><p>1.使用 wait() nofity() nofityAll() 方法之前一定要先对调用对象加锁。<br>2.通知线(调用 notify() 线程)程在 nofity() 或 notifyAll() 之后，等待线程并不会从 wait() 方法返回而在通知线程退出锁之后，等待线程才有机会从 wait() 方法返回。<br>3.等待线程从 wait() 方法返回的前提是获得了调用对象的锁。</p><ul><li>等待/通知的经典范式</li></ul><p>从 代码清单2 可以推出等待通知的经典范式。<br>等待方遵循如下原则:<br>1.获取对象的锁。<br>2.如果条件不满足，那么调用 对象的wait() 方法，被通知后仍要检查条件。<br>3.条件满足执行对应逻辑。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/**代码清单3 等待方的伪代码***/</span><br><span class="line"></span><br><span class="line">synchronized(对象)&#123;</span><br><span class="line">    while(条件不满足)&#123;</span><br><span class="line">      对象.wait();</span><br><span class="line">    &#125;</span><br><span class="line">    条件满足对应的处理逻辑</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通知方遵循如下原则:<br>1.获得对象的锁。<br>2.改变条件。<br>3.通知所有等待在对象上的程序。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/***代码清单4 通知方的伪代码***/</span><br><span class="line"></span><br><span class="line">synchronized(对象)&#123;</span><br><span class="line">    改变条件</span><br><span class="line">    对象.nofityAll();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>我的发现</li></ul><p>之前就看线程时就被告知，等待/通知 都会释放锁，现在终于明白为什么了，如果和 sleep() 方法一样不释放锁，那么等待就会一直等待，不会给同样把对象加了锁的通知方执行的机会！</p><ul><li>等待/通知的实用超时范式</li></ul><p>在开发时往往会遇到下面这样的场景:调用一个方法时等待一段时间(一般来说是给定一段时间)，如果该方法在指定时间段内得到结果，那么结果立刻返回，反之，超时返回默认值。上面提到的 等待/通知经典范式无法做到超时等待。但是等待超时的加入，只需要对经典范式做出非常小的改动，改动如下。</p><p>1.设置等待持续时间 remaining ，超时时间等于 future = now + remaining 。<br>2.使用对象的 wait(remaining) 方法，在 wait(remaining) 返回后将会执行 remaining = future - now ，如果 remaining &lt; 0 表示已经超时，直接退出。否则，继续执行 wait(remaining)。所以顾名思义，等待超时就是在等待超时退出。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/***代码清单5 等待超时模式 ****/</span><br><span class="line"></span><br><span class="line">public synchronized Object get(long mills) throws InterruptedException &#123;</span><br><span class="line">           //超时时间</span><br><span class="line">           long future = System.currentTimeMillis() + mills;</span><br><span class="line">           //持续等待时间</span><br><span class="line">           long remaining = mills;</span><br><span class="line">           //当超时大于 0 并且 result 返回值不满足要求时</span><br><span class="line">           while ((result == null) &amp;&amp; remaining &gt; 0)&#123;</span><br><span class="line">               //如果在 remaining 时间段内，没有得到通知，会自动返回</span><br><span class="line">               wait(remaining);</span><br><span class="line">               remaining = future - System.currentTimeMillis();</span><br><span class="line">           &#125;</span><br><span class="line">           return result;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>可以看出来，等待超时模式就是在 等待/超时模式基础上面增加了超时控制，这使得该模式比原有范式更具有灵活性，因为即使在规定时间内没得到通知，也会按时返回，不会永久的陷入阻塞(一直等待)。</p><h4 id="ThreadLocal-的使用"><a href="#ThreadLocal-的使用" class="headerlink" title="ThreadLocal 的使用"></a>ThreadLocal 的使用</h4><p>之前听都没听过 ThreadLocal 这个家伙。 ThreadLocal ，线程变量，是一个以 ThreadLocal 对象为键，任意对象为值的存储结构。这个结构被负在线程上，也就是说一个线程的可以根据一个 ThreadLocal 对象查询到绑定在这个线程上的一个值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 代码清单6 一个测试 ThreadLocal 的工具类</span><br><span class="line"> */</span><br><span class="line">public class Pofiler &#123;</span><br><span class="line"></span><br><span class="line">    private static final ThreadLocal&lt;Long&gt; TIME_THREADLOCAL = new ThreadLocal&lt;Long&gt;()&#123;</span><br><span class="line">        //返回此线程局部变量的初始值，如果没有set值吗，则第一次 get 则会将该值获取出来</span><br><span class="line">        protected Long initialValue()&#123;</span><br><span class="line">            return System.currentTimeMillis();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public static final void begin()</span><br><span class="line">    &#123;</span><br><span class="line">        //为当前线程设置线程变量</span><br><span class="line">        TIME_THREADLOCAL.set(System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public static final long end()&#123;</span><br><span class="line">      //get() 获取当前线程的时间变量</span><br><span class="line">        return System.currentTimeMillis() - TIME_THREADLOCAL.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        Pofiler.begin();</span><br><span class="line">        TimeUnit.SECONDS.sleep(1);</span><br><span class="line">        System.out.println(&quot;Cost : &quot;+ Pofiler.end() +&quot; mills&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码清单6 中的 Profiler 可以被复用在方法调用的耗时上，在方法的入口前执行 begin() 方法，在方法的调用后执行 end() 方法，这样做的好处是这两个方法的调用不在同一个方法或类中调用。比如说 AOP 中。</p><ul><li>我的发现</li></ul><p>开始并没有在 ThreadLocal 中找到线程通信的蛛丝马迹，实际上 ThreadLocal 是在为调用的线程设置一个值。</p><h3 id="线程池技术"><a href="#线程池技术" class="headerlink" title="线程池技术"></a>线程池技术</h3><p>熟悉线程的人一定会对线程池有印象。为什么要使用线程池？如果服务端每次接到一个任务就，就创建一个线程，在原型阶段是不错的选择，当面临成千上万个任务提交到服务端时，那将创建上万个线程，将会引起大量的上下文切换，增加系统的负担，还有线程的创建和消亡都需要耗费系统资源，无疑浪费了系统资源。<strong>线程池技术能够很好地解决这个问题，线程池会预先创建若数量线程，并且不能由用户直接对线程的创建进行控制，<br>在这个前提下，重复使用固定数目线程执行完成任务的执行。</strong> 这样做的好处很明显，减少了大量线程创建和消亡线程的系统资源开销，另外面对过量任务的提交能够平缓的劣化(老实说这句话啥意思…)。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><span class="line">/***代码清单7 自定义的线程池***/</span><br><span class="line">/**</span><br><span class="line"> * 一个简单的线程池接口</span><br><span class="line"> * Task 任务</span><br><span class="line"> */</span><br><span class="line">public interface ThreadPool&lt;Task extends Runnable&gt; &#123;</span><br><span class="line"></span><br><span class="line">    //执行一个任务</span><br><span class="line">    void execute(Task task);</span><br><span class="line">    //关闭线程池</span><br><span class="line">    void shutdown();</span><br><span class="line">    //增加执行任务线程</span><br><span class="line">    void addWorkers(int num);</span><br><span class="line">    //减少执行任务线程</span><br><span class="line">    void removeWorkers(int num);</span><br><span class="line">    //得到正在等待执行的任务数量</span><br><span class="line">    int getTaskSize();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//实现 ThreadPool 的默认线程池</span><br><span class="line">public class DefaultThreadPool&lt;Task extends Runnable&gt; implements ThreadPool&lt;Task&gt; &#123;</span><br><span class="line"></span><br><span class="line">    //线程池最大线程数</span><br><span class="line">    private static final int MAX_WORKER_NUMBER = 10;</span><br><span class="line">    //线程池默认线程数</span><br><span class="line">    private static final int DEFAULT_WORKER_NUMBER = 5;</span><br><span class="line">    //线程池最小的线程数</span><br><span class="line">    private static final int MIN_WORKER_NUKBER = 1;</span><br><span class="line">    //任务列表</span><br><span class="line">    private final LinkedList&lt;Task&gt; tasks = new LinkedList&lt;&gt;();</span><br><span class="line">    //执行任务的线程</span><br><span class="line">    private final List&lt;Worker&gt; workers = Collections.synchronizedList(new ArrayList&lt;&gt;());</span><br><span class="line">    //执行任务线程数量</span><br><span class="line">    private int workerNum = DEFAULT_WORKER_NUMBER;</span><br><span class="line">    //线程编号</span><br><span class="line">    private AtomicLong threadNumber = new AtomicLong();</span><br><span class="line"></span><br><span class="line">    //默认生成5条执行任务线程</span><br><span class="line">    public DefaultThreadPool()&#123;</span><br><span class="line">        initializeWorkers(DEFAULT_WORKER_NUMBER);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public DefaultThreadPool(int num)&#123;</span><br><span class="line">        workerNum = num &gt; MAX_WORKER_NUMBER ? MAX_WORKER_NUMBER : num &lt; MIN_WORKER_NUKBER ? MIN_WORKER_NUKBER : num;</span><br><span class="line">        initializeWorkers(num);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //初始化完成执行任务线程</span><br><span class="line">    private void initializeWorkers(int num) &#123;</span><br><span class="line">        for (int i = 0;i &lt; num;i++)&#123;</span><br><span class="line">            Worker worker = new Worker();</span><br><span class="line">            workers.add(worker);</span><br><span class="line">            Thread workerThread = new Thread(worker,&quot;ThreadPool-Worker-&quot;+threadNumber.incrementAndGet());</span><br><span class="line">            workerThread.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void execute(Task task) &#123;</span><br><span class="line">        //如果任务不为空，向任务列表中添加 task 然后进行通知 -&gt; 通知会使该任务执行</span><br><span class="line">        if (task != null)&#123;</span><br><span class="line">            synchronized (tasks)&#123;</span><br><span class="line">                tasks.add(task);</span><br><span class="line">                tasks.notify();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void shutdown() &#123;</span><br><span class="line">        for (Worker worker : workers)&#123;</span><br><span class="line">            worker.shutdown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void addWorkers(int num) &#123;</span><br><span class="line">        synchronized (tasks)&#123;</span><br><span class="line">            if (this.workerNum + num &gt; MAX_WORKER_NUMBER)&#123;</span><br><span class="line">                num = MAX_WORKER_NUMBER - this.workerNum;</span><br><span class="line">            &#125;</span><br><span class="line">            initializeWorkers(num);</span><br><span class="line">            this.workerNum += num;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void removeWorkers(int num) &#123;</span><br><span class="line">         synchronized (tasks)&#123;</span><br><span class="line">             if (num &gt;= this.workerNum)&#123;</span><br><span class="line">                 throw new  IllegalArgumentException(&quot;beyond workerNumber&quot;);</span><br><span class="line">             &#125;</span><br><span class="line">             //按照给定的数量停止 Worker</span><br><span class="line">             int count = 0;</span><br><span class="line">             while (count &lt; num)&#123;</span><br><span class="line">                 Worker worker = workers.get(count);</span><br><span class="line">                 if (workers.remove(worker))&#123;</span><br><span class="line">                     worker.shutdown();</span><br><span class="line">                      count++;</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int getTaskSize() &#123;</span><br><span class="line">        return tasks.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    class Worker implements Runnable&#123;</span><br><span class="line">        //是否工作</span><br><span class="line">        private volatile boolean running = true;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            while (running)&#123;</span><br><span class="line">                Task task = null;</span><br><span class="line">                synchronized (tasks)&#123;</span><br><span class="line">                    //如果任务列表是空的则一直等待</span><br><span class="line">                    while (tasks.isEmpty())&#123;</span><br><span class="line">                        try &#123;</span><br><span class="line">                            tasks.wait();</span><br><span class="line">                        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                            Thread.currentThread().interrupt();</span><br><span class="line">                            return;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    task = tasks.removeFirst();</span><br><span class="line">                &#125;</span><br><span class="line">                //取出链表中的第一个任务并执行</span><br><span class="line">                if (task != null)&#123;</span><br><span class="line">                    task.run();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        public void shutdown()&#123;</span><br><span class="line">            running = false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一起来看一下这个线程池实现<br>1.ThreadPool 定义了线程池的基本操作，执行任务、关闭线程池等。<br>2.自定义的线程池 DefaultThreadPool 是由两个重要的数据结构组成 任务链表 LinkedList<task> tasks 以及 执行任务线程列表 List<worker> workers 组成(注意这个线程列表时线程安全的)。<br>3.再看一下初始化方法 initializeWorkers 将 执行任务的线程 进行初始化,传入参数表示生成的线程数量。<br>4.Worker 是用来循环执行 Task 的，当任务列表不为空，且拿出来的任务不为空就调用任务的 run() 方法，为空则等待。<br>5.execute 方法是添加一个任务，他要做两件事，首先将任务添加到任务列表中，其次唤醒等待的线程(即执行任务的线程)。<br>6.注意到在对任务进行操作时，都会对任务列表上锁，这保证了任务执行的安全性。<br>7.关闭线程池的方法很简单，只要让 所有执行任务的线程不在执行任务就可以啦！<br>8.可以看到，数据结构+算法的威力。</worker></task></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>笔记没有介绍线程API的基本知识，而是重点介绍了线程之间的通信，之所以会出现多线程编程，主要就是因为Java在底层实现的线程通信机制。另外也介绍了线程池的基本实现，希望通过这个自定义线程池，让大家对多线程加深印象。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Java-并发编程基础&quot;&gt;&lt;a href=&quot;#Java-并发编程基础&quot; class=&quot;headerlink&quot; title=&quot;Java 并发编程基础&quot;&gt;&lt;/a&gt;Java 并发编程基础&lt;/h2&gt;&lt;h3 id=&quot;引子&quot;&gt;&lt;a href=&quot;#引子&quot; class=&quot;head
      
    
    </summary>
    
    
      <category term="Java并发" scheme="http://yoursite.com/tags/Java%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>AVL树和红黑树</title>
    <link href="http://yoursite.com/2018/03/26/AVL%E6%A0%91%E5%92%8C%E7%BA%A2%E9%BB%91%E6%A0%91/"/>
    <id>http://yoursite.com/2018/03/26/AVL树和红黑树/</id>
    <published>2018-03-26T02:55:50.000Z</published>
    <updated>2018-03-27T06:48:52.675Z</updated>
    
    <content type="html"><![CDATA[<h3 id="平衡树"><a href="#平衡树" class="headerlink" title="平衡树"></a>平衡树</h3><p>标题中的AVL树和红黑树都是二叉查找树，二叉查找树不熟的可以看一下<a href="https://dombro96.github.io/2017/12/29/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/" target="_blank" rel="noopener">这篇博客</a>。<br>二叉搜索树的出现是为了解决线性访问时间太慢的问题，平均访问时间为O(logN)。但如果二叉搜索树以顺序的元素插入如 1,2,3,4,5,6 不难想象此时二叉树又会变成一个链式的线性结构，导致访问效率变慢。这是一个极端的例子，怎么破？</p><p>就引出了平衡树的概念，<strong>平衡树就是带有平衡条件的二叉查找树</strong>。根据平衡树的平衡条件，可以在树插入元素后如果树不符合平衡条件，则对树进行一个调整使树重新平衡。AVL树和红黑树(redblackTree)都是平衡树。</p><h3 id="为什么要平衡"><a href="#为什么要平衡" class="headerlink" title="为什么要平衡"></a>为什么要平衡</h3><p>上面已经说出来了，平衡就是为了要保证树的 O(logN) 的访问速度。即，任何节点的深度不会过深。</p><h3 id="AVL树"><a href="#AVL树" class="headerlink" title="AVL树"></a>AVL树</h3><p>AVL树是带有平衡条件的二叉查找树。AVL树是最古老的平衡树。他保证树的深度必须是O(logN)。</p><h4 id="AVL树平衡条件"><a href="#AVL树平衡条件" class="headerlink" title="AVL树平衡条件"></a>AVL树平衡条件</h4><p>一颗AVL树是其 <strong>每个节点的左子树和右子树的高度最多差1</strong> 的二叉查找树。(空树高度定义为-1)。</p><p><img src="http://p0bl99g4r.bkt.clouddn.com/ds_avltree.PNG" alt=""></p><p>AVL树并不值得注意的是AVL树并不是在根节点处平衡的，如下图只是一颗坏的二叉树。</p><p><img src="http://p0bl99g4r.bkt.clouddn.com/ds_brokenbrinary.PNG" wight="30%" height="30%"></p><h4 id="树的旋转"><a href="#树的旋转" class="headerlink" title="树的旋转"></a>树的旋转</h4><p>再进行插入操作时，我们需要更新通向根节点路径上哪些节点的所有平衡信息，而插入操作的隐含的困难在于，插入一个节点可能破坏AVL树的特性，变得不再平衡。例如，上方右侧非AVL树中，插入7后树变的不再平衡。事实上，这总可以通过对树进行简单修正来做到，我们称其为旋转。</p><blockquote><p>再插入完成后，只有那些从插入点到根节的路径上的节点的平衡可能被改变，因为只有这些节点的子树发生变化。——《Java数据结构》</p></blockquote><p>现在我们约定把出现不平衡的节点叫做α，由于任意节点最多有两个儿子，因此出现高度不平就需要α点的两颗子树高度差是2。容易看出，这种你不平衡可能出现在下面四种情况中。</p><ul><li>1.对α的左儿子的左子树进行一次插入，我们叫他左-左情况</li><li>2.对α的左儿子的右子树进行一次插入，我们叫他左-右情况</li><li>3.对α的右儿子的左子树进行一次插入，我们叫他右-左情况</li><li>4.对α的右儿子的右子树进行一次插入，我们叫他右-右情况</li></ul><p>四种情况中 1和4是对称的镜像情况，2和3是对称的镜像情况。</p><h4 id="单旋转"><a href="#单旋转" class="headerlink" title="单旋转"></a>单旋转</h4><p>第一种情况是插入发生在外边的情况（即左-左情况或左-右情况），遇到该情况通过对树的单旋转（即一次旋转使树平衡）完成调整。下面是发挥你想象例的时刻</p><p><img src="http://p0bl99g4r.bkt.clouddn.com/ds_avlrotate.png" wight="60%" height="60%"></p><p>如图分别演示了左-左和右-右单旋转过程，实际上旋转要做的无非就是把高的子树向上提一层，闭上双眼想一下这个动作，找到非平衡节点K2向较低的子树那一边用力下拉，这时K3就会被拽上来，而K3的较低子树也应该成为K2的左/右子树以满足二叉树的条件。我们 <strong>按照旋转的方向，左-左情况的旋转叫做右旋转，右-右情况的旋转叫做左旋转</strong>。</p><p>####　双旋转</p><p>下面说说比较麻烦的双旋转，双旋转的使用场景是左-右情况或右-左情况，顾名思义他需要转两下。</p><p>来看一种情况，下图属于左-右情况(右-左情况也一样)，在K2处右旋转，显然树并未平衡。这是由于左旋和右旋只会将边上的子树上提。</p><p><img src="http://p0bl99g4r.bkt.clouddn.com/ds_avlrotetefailed.png" alt=""></p><p>和单旋转一样，我们的想办法把最高的子树向上提。上图中显然不能把K2当做根了，而把K3当做根有解决不了问题，那我们就只有把K1当做根，要想把K1当做根，可以预见K1就要是K3的父节点，这样K1就可以轻松的右旋。来试一下</p><p><img src="http://p0bl99g4r.bkt.clouddn.com/ds_doublerotate.png" alt=""></p><p>看到了吧，所谓的双旋转就是两个单旋转组成的，它的过程是找到不平衡节点的内侧儿子，以内侧儿子节点为支点单旋转(方向右-左视情况和左-右情况而定)，旋转后再以该不平衡节点为支点进行单旋转。总之你要记住的是，我们的目的是把树变得平衡呀！</p><h4 id="调整的时机"><a href="#调整的时机" class="headerlink" title="调整的时机"></a>调整的时机</h4><p>说完旋转以后，AVL树的精髓部分已经说完了，实际上所说的旋转就是对平衡树的调整。可以研究一AVL树的调整时机。事实上你会发现在每次insert后都要调整(一个很重要的特点)，原因就是上面引用《Java数据结构》的那句话，每次插入都有可能改变树的平衡性，所以AVL树的插入方法比二叉查找树在最后要多一个balance平衡方法。那删除一个节点呢？由于二叉树查找的删除本身就是一个比插入复杂的事（要考虑三种情况），删除一个节点有可能会引起树得不平衡，你可能会担心。实际上，为保证删除一个节点后AVL树依旧平衡，在二叉查找树的删除方法最后加上平衡函数是可行的！因为我们的平衡函数是从根节点开始判断的，也就是站在整颗AVL树的平衡性！</p><h4 id="AVL节点"><a href="#AVL节点" class="headerlink" title="AVL节点"></a>AVL节点</h4><p>由于AVL树需要比较子树之间的高度，所以AVL节点会有一个记录节点高度的height域，空节点的高度是-1，父节点的高度是较高儿子节点高度加一。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><p>在代码中我们会计算节点子树的高度差，这个高度差不能大于一，若大于一就需要调整平衡。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * AVL树的简单实现</span><br><span class="line"> */</span><br><span class="line">public class BinaryAvlTree&lt;AnyType extends Comparable&lt;? super AnyType&gt;&gt; &#123;</span><br><span class="line"></span><br><span class="line">    //AVL节点</span><br><span class="line">    private static class AvlNode&lt;AnyType&gt;&#123;</span><br><span class="line"></span><br><span class="line">        public AvlNode(AnyType element, AvlNode&lt;AnyType&gt; left, AvlNode&lt;AnyType&gt; right) &#123;</span><br><span class="line">            this.element = element;</span><br><span class="line">            this.left = left;</span><br><span class="line">            this.right = right;</span><br><span class="line">            this.height = 0;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public AvlNode(AnyType element)&#123;</span><br><span class="line">            this(element,null,null);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        AnyType element;</span><br><span class="line">        AvlNode&lt;AnyType&gt; left;</span><br><span class="line">        AvlNode&lt;AnyType&gt; right;</span><br><span class="line">        //节点的高度，默认初始化时根节点跟读为0</span><br><span class="line">        int height;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //根节点引用</span><br><span class="line">    public AvlNode&lt;AnyType&gt; root;</span><br><span class="line">    //平衡的高度差(指节点左右子树高度差)</span><br><span class="line">    private static final int ALLOWED_IMBALANCE = 1;</span><br><span class="line"></span><br><span class="line">    public BinaryAvlTree() &#123;</span><br><span class="line">        root = null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public AvlNode&lt;AnyType&gt; insert(AnyType x)&#123;</span><br><span class="line">      //插入从根节点插入</span><br><span class="line">        return insert(x,root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //返回节点的高度</span><br><span class="line">    private int high(AvlNode&lt;AnyType&gt; t)&#123;</span><br><span class="line">        return (t == null) ? -1:t.height;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public AvlNode&lt;AnyType&gt; insert(AnyType x,AvlNode&lt;AnyType&gt; t)&#123;</span><br><span class="line">        //插入节点步骤</span><br><span class="line">        //1.首次插入从根节点插入</span><br><span class="line">        //2.插入后调用平衡函数</span><br><span class="line">        if (t == null)&#123;</span><br><span class="line">            t = new AvlNode&lt;AnyType&gt;(x);</span><br><span class="line">        &#125;</span><br><span class="line">        //与根节点比较大小，若小递归从根节点左子树插入，若大递归从根节点右子树插入</span><br><span class="line">        int compareResult =  x.compareTo(t.element);</span><br><span class="line">        if (compareResult &lt; 0 )&#123;</span><br><span class="line">            t.left = insert(x,t.left);</span><br><span class="line">        &#125;else if (compareResult &gt; 0)&#123;</span><br><span class="line">            t.right = insert(x,t.right);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        //调用平衡函数</span><br><span class="line">         return  balance(t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //平衡方法</span><br><span class="line">    private AvlNode&lt;AnyType&gt; balance(AvlNode&lt;AnyType&gt; t) &#123;</span><br><span class="line">        if (t == null)&#123;</span><br><span class="line">            return t;</span><br><span class="line">        &#125;</span><br><span class="line">        if (high(t.left)-high(t.right) &gt; ALLOWED_IMBALANCE)&#123;</span><br><span class="line">            //如果左子树高于右子树判断是左-左还是左-右 ；左-左 情况(向结点左儿子的左子树插入点使得树不平衡)，进行左侧单旋转</span><br><span class="line">            if (high(t.left.left)&gt;=high(t.left.right))&#123;</span><br><span class="line">                t = rotateWithLeftChild(t);</span><br><span class="line">            &#125;else &#123;</span><br><span class="line">                //左-右 情况(向结点左儿子的右子树插入使得树不平衡)，进行右侧单旋转</span><br><span class="line">                t = doubleWithLeftChild(t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //下面代码判段右-左与右-右的情况，与上面代码属于镜像关系</span><br><span class="line">        else if (high(t.right)-high(t.left) &gt; ALLOWED_IMBALANCE)&#123;</span><br><span class="line">            //右-右情况 进行右侧单旋转</span><br><span class="line">            if (high(t.right.right)&gt;=high(t.right.left))&#123;</span><br><span class="line">                t = rotateWithRightChild(t);</span><br><span class="line">            //右-左 情况进行右侧双旋转</span><br><span class="line">            &#125;else &#123;</span><br><span class="line">                t = doubleWithRightChild(t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //t的高度为左右较高子树加一</span><br><span class="line">        t.height = Math.max(high(t.left),high(t.right))+1;</span><br><span class="line">        return t;</span><br><span class="line">    &#125;</span><br><span class="line">    //右-左双旋转</span><br><span class="line">    private AvlNode&lt;AnyType&gt; doubleWithRightChild(AvlNode&lt;AnyType&gt; k3) &#123;</span><br><span class="line">         //右侧双旋转与左侧双旋转城镜像关系</span><br><span class="line">        /**</span><br><span class="line">         * 右侧双旋转步骤；即右-左情况</span><br><span class="line">         * 1.对k3的右子节点做左侧单旋转操作，</span><br><span class="line">         * 2.在对k3节点做右侧单旋转</span><br><span class="line">         */</span><br><span class="line">         rotateWithLeftChild(k3.right);</span><br><span class="line">         return rotateWithRightChild(k3);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //右-右单旋转</span><br><span class="line">    private AvlNode&lt;AnyType&gt; rotateWithRightChild(AvlNode&lt;AnyType&gt; k2) &#123;</span><br><span class="line">        //与左侧单旋转是镜像关系</span><br><span class="line">        /**</span><br><span class="line">         * 1.k1为k2的右儿子节点，k1的左孩子作为k2的右孩子</span><br><span class="line">         * 2.k2作为k1的左孩子</span><br><span class="line">         */</span><br><span class="line">        AvlNode&lt;AnyType&gt; k1 = k2.right;</span><br><span class="line">        k2.right = k1.left;</span><br><span class="line">        k1.left = k2;</span><br><span class="line">        k1.height = Math.max(k2.height,high(k1.right))+1;</span><br><span class="line">        k2.height = Math.max(high(k2.left),high(k2.right))+1;</span><br><span class="line">        return k1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //左-右双旋转</span><br><span class="line">    private AvlNode&lt;AnyType&gt; doubleWithLeftChild(AvlNode&lt;AnyType&gt; k3) &#123;</span><br><span class="line">        /**</span><br><span class="line">         * 左侧双旋转步骤：左侧双旋转是对应左-右情况的策略所以要先对左儿子的右子树进行右侧单旋转，在对该节点进行左侧单旋转</span><br><span class="line">         * 1.对k3节点左k1儿子的右子树右侧单旋转</span><br><span class="line">         * 2.对节点k3进行左侧单旋转</span><br><span class="line">         */</span><br><span class="line">        rotateWithRightChild(k3.left);</span><br><span class="line">        return rotateWithLeftChild(k3);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //左-左单旋转</span><br><span class="line">    private AvlNode&lt;AnyType&gt; rotateWithLeftChild(AvlNode&lt;AnyType&gt; k2) &#123;</span><br><span class="line">        /**</span><br><span class="line">         * 左侧单旋转步骤：k1不平衡节nk2的左孩子</span><br><span class="line">         * 1.将 k1的右孩子变为k2的左孩子</span><br><span class="line">         * 2.将节点k2变为其左k1的右孩子 即 k1 处在原不平衡节点的 k2 位置。</span><br><span class="line">         * 3.重新计算k1 k2 的高度</span><br><span class="line">         * 4.返回k1</span><br><span class="line">         */</span><br><span class="line">        AvlNode&lt;AnyType&gt; k1 = k2.left;</span><br><span class="line">        k2.left = k1.right;</span><br><span class="line">        k1.right = k2;</span><br><span class="line">        k1.height = Math.max(high(k1.left),k2.height)+1;</span><br><span class="line">        k2.height = Math.max(high(k2.left),high(k2.right))+1;</span><br><span class="line">        return k1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //删除操作</span><br><span class="line">    public AvlNode&lt;AnyType&gt; remove(AnyType x,AvlNode&lt;AnyType&gt; t)&#123;</span><br><span class="line">        if (t == null)&#123;</span><br><span class="line">            return t;</span><br><span class="line">        &#125;</span><br><span class="line">        int compareResult = x.compareTo(t.element);</span><br><span class="line">        if (compareResult &lt; 0)&#123;</span><br><span class="line">            t.left = remove(x,t.left);</span><br><span class="line">        &#125;else if(compareResult &gt; 0)&#123;</span><br><span class="line">            t.right = remove(x,t.right);</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            if (t.left != null &amp;&amp; t.right != null)&#123;</span><br><span class="line">                t.element = findMin(t.right).element;</span><br><span class="line">                t.right = remove(t.element,t.right);</span><br><span class="line">            &#125;else &#123;</span><br><span class="line">                t = (t.left == null) ? t.left:t.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return balance(t);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 从根节点查找最小节点</span><br><span class="line">     * 由于二叉搜索树根节点左侧均比根节点小,</span><br><span class="line">     *</span><br><span class="line">     */</span><br><span class="line">    private AvlNode&lt;AnyType&gt; findMin(AvlNode&lt;AnyType&gt; t)&#123;</span><br><span class="line">        if (t != null)&#123;</span><br><span class="line">            while (t.left != null)&#123;</span><br><span class="line">                t = t.left;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //与查找最小值类似</span><br><span class="line">    private  AvlNode&lt;AnyType&gt; findMax(AvlNode&lt;AnyType&gt; t)&#123;</span><br><span class="line">        if (t != null)&#123;</span><br><span class="line">            while (t.right != null)&#123;</span><br><span class="line">                t = t.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总的来说AVL树可以有效的解决二叉查找树出现线性存储查找效率低的状况。那AVL树就没有缺点了吗？当然不是AVL树每次插入都需要再次平衡，我们用的还是递归…这就影响了AVL树插入的速率。</p><h3 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h3><p>上面说到AVL树频繁平衡操作的影响了插入速率。之所以频繁的平衡是因为AVL树的平衡条件太单一了，没啥内涵。这就引出了今天的第二主角红黑树。那么红黑树是什么树呢？红黑树是AVL树的流行变种，最坏的操作情形下花费O(logN)的时间，他的插入和删除速度都很快。</p><h4 id="红黑树特点"><a href="#红黑树特点" class="headerlink" title="红黑树特点"></a>红黑树特点</h4><p>红黑树是具有下列着色性质的二叉查找树(四规则)：</p><ul><li>1.每一颗节点或者是红色，或者是黑色。</li><li>2.根节点是黑色的。</li><li>3.如果一个节点是红色的，他的子节点必须是黑色的。</li><li>4.从一个节点到null引用的每一条路径必须包含相同数目的黑色节点。</li></ul><p><em>着色法则的一个结论是，红黑树的高度最多是2log(N+1)，因此保证查找操作是一种对树操作。</em></p><p><img src="http://p0bl99g4r.bkt.clouddn.com/ds_redblacktree.png" wight="50%" height="50%"></p><p><em>默认没有儿子的节点连接的都是null</em>。</p><h4 id="插入节点"><a href="#插入节点" class="headerlink" title="插入节点"></a>插入节点</h4><p>根据上面红黑树四规定，可以确定插入的节点颜色一定是红色。这不是偶然的,因为如果新插入节点是黑色在，那势必会违背规则四。但如果插入红色节点只有半几率违反规则三，就算违反了也更容易修改。但是就算是插入红色新节点也还是会有可能破坏平衡性的。</p><h3 id="红黑树的节点"><a href="#红黑树的节点" class="headerlink" title="红黑树的节点"></a>红黑树的节点</h3><p>根据红黑树的着色特点，要有一个boolean值表示颜色。另外红黑树插入过程中需要获得其父亲节点进行颜色的判断，所以还要有一个父节点的引用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">private static class RedBlackNode&lt;AnyType&gt;&#123;</span><br><span class="line">       AnyType element;</span><br><span class="line">       RedBlackNode&lt;AnyType&gt; left;</span><br><span class="line">       RedBlackNode&lt;AnyType&gt; right;</span><br><span class="line">       RedBlackNode&lt;AnyType&gt; parent;</span><br><span class="line">       boolean color;</span><br><span class="line"></span><br><span class="line">       public RedBlackNode(AnyType element, RedBlackNode&lt;AnyType&gt; left,</span><br><span class="line">         RedBlackNode&lt;AnyType&gt; right,RedBlackNode&lt;AnyType&gt; parent,boolean color) &#123;</span><br><span class="line">           this.element = element;</span><br><span class="line">           this.left = left;</span><br><span class="line">           this.right = right;</span><br><span class="line">           this.parent = parent;</span><br><span class="line">           this.color = color;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="平衡性修正"><a href="#平衡性修正" class="headerlink" title="平衡性修正"></a>平衡性修正</h4><p> 红-黑树主要通过三种方式对平衡进行修正，改变节点颜色、左旋和右旋。这看起来有点抽象。其中左旋和右旋在AVL树的旋转小节已经解释过了，唯一的区别不是红黑树只靠着旋转就可以达到平衡的，其他原理都是一样的。</p><ul><li><p>变色</p><p>变色其实也很好理解，由于违背了规则三，所以自然的就将节点颜色改变一下。比如插入节点的父节点也是红色，就将父节点的颜色变为黑色(当然情况可能会更加复杂一点)。</p></li></ul><ul><li>旋转</li></ul><p>上面说了左旋右旋的原理和AVL树中的旋转是一样的，只不过由于多了parent的引用。代码会有点变化。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">//以t为支点右旋操作</span><br><span class="line">    private void rightRotate(RedBlackNode&lt;AnyType&gt; t) &#123;</span><br><span class="line">        RedBlackNode&lt;AnyType&gt; leftNode = t.left;</span><br><span class="line">        t.left = leftNode.right;</span><br><span class="line">        if (leftNode.right != null)&#123;</span><br><span class="line">            leftNode.right.parent = t;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        leftNode.parent = t.parent;</span><br><span class="line">        if (t.parent == null)&#123;</span><br><span class="line">            this.root = leftNode;</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            if (t == t.parent.right)&#123;</span><br><span class="line">                t.parent.right = leftNode;</span><br><span class="line">            &#125;else &#123;</span><br><span class="line">                t.parent.left = leftNode;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        leftNode.right = t;</span><br><span class="line">        t.parent = leftNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //以t为支点左旋操作</span><br><span class="line">    private void leftRotate(RedBlackNode&lt;AnyType&gt; t) &#123;</span><br><span class="line">        RedBlackNode&lt;AnyType&gt; rightNode = t.right;</span><br><span class="line">        t.right = rightNode.left;</span><br><span class="line">        if (rightNode.left != null)&#123;</span><br><span class="line">            rightNode.left.parent = t;</span><br><span class="line">        &#125;</span><br><span class="line">        rightNode.parent = t.parent;</span><br><span class="line">        //如果 parent 没有父节点说明 parent 是根节点</span><br><span class="line">        if (t.parent == null)&#123;</span><br><span class="line">            this.root = rightNode;</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            //判断parent是左子树还是右子树</span><br><span class="line">            if (t == t.parent.left)&#123;</span><br><span class="line">                t.parent.left = rightNode;</span><br><span class="line">            &#125;else &#123;</span><br><span class="line">                t.parent.right = rightNode;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        rightNode.left = t;</span><br><span class="line">        t.parent = rightNode;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="节点的插入"><a href="#节点的插入" class="headerlink" title="节点的插入"></a>节点的插入</h4><p>和AVL树一样，再插入新结点后如果树出现了不平衡，还是要对树进行一个平衡调整。所谓修正也就是分情况讨论合适变色，何时左旋何时右旋。</p><p>如果是第一次插入，由于原树为空，只会违反规则二，所以只要把根节点涂黑即可；如果插入节点的父节点是黑色的，那不违反任何规则，什么也不做；但是若遇到下列三种情况，就一当要进行修正了：</p><p>1.插入节点的父节点何其叔叔节点均为红色<br>2.插入节点的父节点是红色，叔叔节点是黑色且插入节点是其父节点的右子节点<br>3.插入节点的父节点是红色，叔叔节点是黑色且插入节点是其父节点的左子节点</p><p>情况一：将当前节点的父节点和叔叔节点涂黑，将祖父节点涂红。将当新节点(即当前节点)指向其祖父节点。此时情况变为情况二(插入节点的父节点是红色，叔叔节点是黑色，且插入节点是父节点的左孩子)。</p><p>情况二：以当前节点的父节点作为新的节点，以新的节点作为支点做左旋操作。此时情况变为情况三（插入节点的父节点是红色，叔叔是黑色节点且插入节点是父节点右节点）。</p><p>情况三：将当前节点的父节点涂黑，将其祖父节点涂红，在祖父节点为支点左右旋操作。<br>     最后把根节点涂黑，整个红黑树恢复平衡。</p><p>ps:这里的图我实在画不动了们可以看一下这个博主写的红黑树，很全面很细致是我见过总结最到位的，<a href="https://blog.csdn.net/eson_15/article/details/51144079#t9" target="_blank" rel="noopener">包教包会</a>。</p><p>下图是调整的流程图(自己画的)</p><p><img src="http://p0bl99g4r.bkt.clouddn.com/ds_rbtree_insertfix.png" alt=""></p><ul><li>代码</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">//插入后重新调整为红黑树</span><br><span class="line">   private void insertFixUp(RedBlackNode&lt;AnyType&gt; t) &#123;</span><br><span class="line">       //父节点，祖父节点</span><br><span class="line">       RedBlackNode&lt;AnyType&gt; parent ,grand;</span><br><span class="line">       //1.需要调整条件，父节点存在，且父节点颜色为红</span><br><span class="line">       while ((parent = getParent(t)) != null &amp;&amp; parent.color == RED)&#123;</span><br><span class="line">       //获取祖父节点</span><br><span class="line">               grand = getParent(parent);</span><br><span class="line">        //2.如果父节点是祖父节点的左儿子</span><br><span class="line">       if (parent == grand.left)&#123;</span><br><span class="line">           //获取叔叔节点</span><br><span class="line">           RedBlackNode&lt;AnyType&gt; uncle = grand.right;</span><br><span class="line">           //情况一：叔叔节点也是红色</span><br><span class="line">           if(uncle != null &amp;&amp; uncle.color == RED)&#123;</span><br><span class="line">               //将父节点和叔叔节点涂黑</span><br><span class="line">               parent.color = BLACK;</span><br><span class="line">               uncle.color = BLACK;</span><br><span class="line">               grand.color = RED;</span><br><span class="line">               //将当前节点位置放到祖父节点</span><br><span class="line">               t = grand;</span><br><span class="line">               continue;</span><br><span class="line">           &#125;</span><br><span class="line">           //情况二：叔叔节点是黑色，且当前节点是右子节点</span><br><span class="line">           if (t == parent.right)&#123;</span><br><span class="line">               //从父节点处左旋</span><br><span class="line">               leftRotate(parent);</span><br><span class="line">               //以当前父节点和自己调换，作为新节点，为右旋做准备</span><br><span class="line">               RedBlackNode&lt;AnyType&gt; temp = parent;</span><br><span class="line">               parent = t;</span><br><span class="line">               t = temp;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           //情况三：叔叔节点是黑色，且当前节点是左子节点</span><br><span class="line">           //将当前节点的父节点涂黑，将其祖父涂红</span><br><span class="line">           parent.color = BLACK;</span><br><span class="line">           grand.color = RED;</span><br><span class="line">           rightRotate(grand);</span><br><span class="line">           //与上面对称</span><br><span class="line">       &#125;else &#123;</span><br><span class="line">           //3.如果父节点是祖父节点的右子节点，与上面完全相反，本质一样</span><br><span class="line">           RedBlackNode&lt;AnyType&gt; uncle = grand.left;</span><br><span class="line">           //情况一：叔叔节点也是红色</span><br><span class="line">           if (uncle != null &amp;&amp; uncle.color == RED)&#123;</span><br><span class="line">               parent.color = BLACK;</span><br><span class="line">               uncle.color = BLACK;</span><br><span class="line">               grand.color = RED;</span><br><span class="line">               t = grand;</span><br><span class="line">               continue;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           //情况二：叔叔节点是黑色的，且当前节点是左子节点</span><br><span class="line">           if (t == parent.left)&#123;</span><br><span class="line">               rightRotate(parent);</span><br><span class="line">               RedBlackNode&lt;AnyType&gt; temp = parent;</span><br><span class="line">               parent = t;</span><br><span class="line">               t = temp;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           //情况三：叔叔节点是黑色，且当前节点是右子节点</span><br><span class="line">           parent.color = BLACK;</span><br><span class="line">           grand.color = RED;</span><br><span class="line">           leftRotate(grand);</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       this.root.color = BLACK;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="节点的删除"><a href="#节点的删除" class="headerlink" title="节点的删除"></a>节点的删除</h3><p>上面探讨完了红-黑树的插入操作，接下来讨论删除。红黑树的删除分成两部分走</p><h4 id="第一步删除节点"><a href="#第一步删除节点" class="headerlink" title="第一步删除节点"></a>第一步删除节点</h4><p>第一步就把红黑树当成二叉树进行删除。二叉树的删除要考虑三种情况：<br>1.如果待删除节点没有子节点，那么直接删掉即可<br>2.如果待删除节点只有一个子节点，那么直接删除，并用其子节点去顶替他。<br>3.如果待删除节点有两个子节点，找出他的后继节点，处理后继节点和被删除节点父节点的关系，最后处理后继节点子节点和被删除节点子节点的关系。</p><p><em>后继节点：删除一个节点后用来代替该删除位置的节点，当删除节点有两个子节点时，后继节点是删除节右子树中最小的节点。</em></p><h4 id="第二步删除调整"><a href="#第二步删除调整" class="headerlink" title="第二步删除调整"></a>第二步删除调整</h4><p>删除调整的内容有些抽象，并且非常复杂。</p><p>在第一步删除节点后，可能会违背红黑树的特性需要修复包括下面两个因素：</p><p>1.删除黑色节点导致违背规则4。<br>2.删除节点的儿子和父亲相连时，都是红色违背规则3。</p><p>所以就需要通过旋转和变色来修正红黑树。删除修复的总体思想是从兄弟节点借调黑色节点使树保持局部平衡，如果局部平衡达到了，就看整体的树是否平衡，如果不平衡纠结着向上调整。</p><ul><li>真正要删除的节点</li></ul><p>当删除一节点时，如果该节点有左右儿子节点，<strong>我们会找到被删除节点的后继节点来替代他，所以这个要删除的节点并不会引起红黑树不平衡，引起不平衡的是那个真正被删除的后继节点</strong>。所以如果我们把要删除的节点叫做”将要删除的节点”，那”真正要删除的节点”实际上则是他的后继。这个概念是很好理解的。我们判断的删除节点需要修复的两个关键因素是根据这个”真正要删除的节点的”。</p><p><em>如果要删除的节点不存在后继即只有一个或没有子节点，那这个要删除的节点就是真正要删除的节点</em>。</p><ul><li>删除修复的四种情况(不含镜像对称)</li></ul><p>约定:空的节点是黑色，当前节指 <strong>真正被删除节点</strong> 的子节点</p><p>1.当前节点是黑色的，且兄弟节点是红色的(那么父节点和兄弟节点的子节点肯定是黑色的)<br>2.当前节点是黑色的，且兄弟节点是黑色的，且兄弟节点的两个子节点是黑色的<br>3.当前节点四黑色的，且兄弟节点是黑色的，且兄弟节点的左子节点是红色的，右子节点是黑色的<br>4.当前节点是黑色的，且兄弟节点是黑色的，且兄弟节点的右子节点是红色的，左子节点任意颜色</p><p>情况一：将父节点涂红，然后将当前节点父节点作为作为支撑左旋，于是当前节点的兄弟变为黑色。此时可能变为情况二三四的任意一种。<br>情况二：将兄弟节点涂红，将当前节点指向其父节点，将其父节点指向当前节点的祖父节点。<br>情况三：当前节点的兄弟节点涂红，把兄弟节点的左子节点涂黑，然后以兄弟节点作为支点左右旋操作。然后兄弟节点就变成黑色，且兄弟节点右子节点变成红色。<br>情况四：把兄弟节点涂成父节点的颜色，再把父节点涂黑，把兄弟节点的右子节点涂黑，然后以当前节点的父节点为支点做左旋操作。</p><p><img src="http://p0bl99g4r.bkt.clouddn.com/ds_removefix.png" alt=""></p><blockquote><p>我们可以看出，如果是从情况一开始发生的，可能情况二、三、四的一种：如果是情况二，就不可能再出现三和四；如果是情况三，必然会导致情况四的出现；如果二和三都不是，那必然是四。当然咯，实际中可能不一定会从情况一发生，这要看具体情况了</p></blockquote><ul><li>代码</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">    *  红黑树删除调整方法</span><br><span class="line">    * @param node 真正删除节点的子节点表示待修正的节点，即带修正的节点</span><br><span class="line">    * @param parent</span><br><span class="line">    */</span><br><span class="line">    private void removeFix(RedBlackNode&lt;AnyType&gt; node, RedBlackNode&lt;AnyType&gt; parent) &#123;</span><br><span class="line">           RedBlackNode&lt;AnyType&gt; other = null;</span><br><span class="line"></span><br><span class="line">           while ((node == null || node.color == BLACK) &amp;&amp; (node != this.root)) &#123;</span><br><span class="line">               //当node是左子节点</span><br><span class="line">               if (parent.left == node) &#123;</span><br><span class="line">                   //兄弟节点</span><br><span class="line">                   other = parent.right;</span><br><span class="line">                   //情况一：node的兄弟节点other是红色</span><br><span class="line">                   if (other != null &amp;&amp; other.color == RED) &#123;</span><br><span class="line">                       other.color = BLACK;</span><br><span class="line">                       parent.color = RED;</span><br><span class="line">                       leftRotate(parent);</span><br><span class="line">                       other = parent.right;</span><br><span class="line">                   &#125;</span><br><span class="line">                   //情况二：node的兄弟节点other是黑色的且other的两个子节点也都是黑色</span><br><span class="line">                   if ((other.left == null || other.left.color == BLACK)</span><br><span class="line">                           &amp;&amp; (other.right == null || other.right.color == BLACK)) &#123;</span><br><span class="line">                       other.color = RED;</span><br><span class="line">                       node = parent;</span><br><span class="line">                       parent = getParent(node);</span><br><span class="line">                   &#125; else &#123;</span><br><span class="line">                       //情况三:node的兄弟节点other是黑色，且other的左子节点是红色，右子节点是黑色</span><br><span class="line">                       if (other.right == null || other.right.color == BLACK) &#123;</span><br><span class="line">                           other.left.color = BLACK;</span><br><span class="line">                           other.color = RED;</span><br><span class="line">                           rightRotate(other);</span><br><span class="line">                           other = parent.right;</span><br><span class="line">                       &#125;</span><br><span class="line"></span><br><span class="line">                       //情况四：node的兄弟节点other是黑色的，且other的右子节点是红色，左子节点任意颜色</span><br><span class="line">                       boolean parentColor = parent.color;</span><br><span class="line">                       other.color = parentColor;</span><br><span class="line">                       parent.color = BLACK;</span><br><span class="line">                       other.right.color = BLACK;</span><br><span class="line">                       leftRotate(parent);</span><br><span class="line">                       node = this.root;</span><br><span class="line">                       break;</span><br><span class="line">                       //与上面对称</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125; else &#123;</span><br><span class="line">                   other = parent.left;</span><br><span class="line">                   if (other.color == RED)&#123;</span><br><span class="line">                       other.color = BLACK;</span><br><span class="line">                       parent.color = RED;</span><br><span class="line">                       rightRotate(parent);</span><br><span class="line">                       other = parent.left;</span><br><span class="line">                   &#125;</span><br><span class="line"></span><br><span class="line">                   if ((other.left == null || other.left.color == BLACK) &amp;&amp;</span><br><span class="line">                           (other.right == null) || other.right.color == BLACK)&#123;</span><br><span class="line">                       other.color = RED;</span><br><span class="line">                       node = parent;</span><br><span class="line">                       parent = node.parent;</span><br><span class="line">                   &#125;else &#123;</span><br><span class="line">                       if (other.left == null || other.left.color == BLACK)&#123;</span><br><span class="line">                           other.right.color = BLACK;</span><br><span class="line">                           other.color = RED;</span><br><span class="line">                           leftRotate(other);</span><br><span class="line">                           other = parent.left;</span><br><span class="line">                       &#125;</span><br><span class="line">                       //情况四：node的兄弟节点other是黑色的，且other的右子节点是红色，左子节点任意颜色</span><br><span class="line">                       boolean parentColor = parent.color;</span><br><span class="line">                       other.color = parentColor;</span><br><span class="line">                       parent.color = BLACK;</span><br><span class="line">                       other.right.color = BLACK;</span><br><span class="line">                       leftRotate(parent);</span><br><span class="line">                       node = this.root;</span><br><span class="line">                       break;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           if (node != null)&#123;</span><br><span class="line">               node.color = BLACK;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>ps:<br>红黑树的删除操作是非常难得，即使我看懂了第一遍，第二遍还是会有地方不通。多画几遍图吧，删除这里我也崩溃了两天。(T T !) 同样可以看一下这篇文章 <a href="https://blog.csdn.net/eson_15/article/details/51144079#t9" target="_blank" rel="noopener">包教包会</a></p><p>####　红黑树代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br></pre></td><td class="code"><pre><span class="line">package cn.dombro.datastructures.tree;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 红黑树简单例子</span><br><span class="line"> */</span><br><span class="line">public class RedBlackTree&lt;AnyType extends Comparable&lt;? super AnyType&gt;&gt; &#123;</span><br><span class="line"></span><br><span class="line">    private static class RedBlackNode&lt;AnyType&gt;&#123;</span><br><span class="line">        AnyType element;</span><br><span class="line">        RedBlackNode&lt;AnyType&gt; left;</span><br><span class="line">        RedBlackNode&lt;AnyType&gt; right;</span><br><span class="line">        RedBlackNode&lt;AnyType&gt; parent;</span><br><span class="line">        boolean color;</span><br><span class="line"></span><br><span class="line">        public RedBlackNode(AnyType element, RedBlackNode&lt;AnyType&gt; left, RedBlackNode&lt;AnyType&gt; right, RedBlackNode&lt;AnyType&gt; parent,boolean color) &#123;</span><br><span class="line">            this.element = element;</span><br><span class="line">            this.left = left;</span><br><span class="line">            this.right = right;</span><br><span class="line">            this.parent = parent;</span><br><span class="line">            this.color = color;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private RedBlackNode&lt;AnyType&gt; root;</span><br><span class="line"></span><br><span class="line">    private static final boolean RED =  false;</span><br><span class="line"></span><br><span class="line">    private static final boolean BLACK = true;</span><br><span class="line"></span><br><span class="line">    //插入红黑树操作</span><br><span class="line">    public void insert(AnyType x)&#123;</span><br><span class="line">        //插入新节点的颜色都为红色</span><br><span class="line">        RedBlackNode&lt;AnyType&gt; node = new RedBlackNode&lt;AnyType&gt;(x,null,null,null,RED);</span><br><span class="line">        if (node != null)</span><br><span class="line">            insert(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void insert(RedBlackNode&lt;AnyType&gt; t)&#123;</span><br><span class="line">        //从根节点插入</span><br><span class="line">        RedBlackNode&lt;AnyType&gt; parent = null;</span><br><span class="line">        RedBlackNode&lt;AnyType&gt; node = this.root;</span><br><span class="line">        //找到插入位置</span><br><span class="line">        while (node != null)&#123;</span><br><span class="line">            parent = node;</span><br><span class="line">            int comparableResult = t.element.compareTo(node.element);</span><br><span class="line">            if (comparableResult &lt; 0)&#123;</span><br><span class="line">                node = node.left;</span><br><span class="line">            &#125;else if (comparableResult &gt; 0)&#123;</span><br><span class="line">                node = node.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //找到插入的父亲结点</span><br><span class="line">        t.parent = parent;</span><br><span class="line">        //判断 t 插在左还是插在右</span><br><span class="line">        if (parent != null)&#123;</span><br><span class="line">            int comparableResult = t.element.compareTo(parent.element);</span><br><span class="line">            if (comparableResult &lt; 0)&#123;</span><br><span class="line">                parent.left = t;</span><br><span class="line">            &#125;else &#123;</span><br><span class="line">                parent.right = t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            this.root = t;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        insertFixUp(t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //插入后重新调整为红黑树</span><br><span class="line">    private void insertFixUp(RedBlackNode&lt;AnyType&gt; t) &#123;</span><br><span class="line">        //父节点，祖父节点</span><br><span class="line">        RedBlackNode&lt;AnyType&gt; parent ,grand;</span><br><span class="line">        //1.需要调整条件，父节点存在，且父节点颜色为红</span><br><span class="line">        while ((parent = getParent(t)) != null &amp;&amp; parent.color == RED)&#123;</span><br><span class="line">        //获取祖父节点</span><br><span class="line">                grand = getParent(parent);</span><br><span class="line">         //2.如果父节点是祖父节点的左儿子</span><br><span class="line">        if (parent == grand.left)&#123;</span><br><span class="line">            //获取叔叔节点</span><br><span class="line">            RedBlackNode&lt;AnyType&gt; uncle = grand.right;</span><br><span class="line">            //情况一：叔叔节点也是红色</span><br><span class="line">            if(uncle != null &amp;&amp; uncle.color == RED)&#123;</span><br><span class="line">                //将父节点和叔叔节点涂黑</span><br><span class="line">                parent.color = BLACK;</span><br><span class="line">                uncle.color = BLACK;</span><br><span class="line">                grand.color = RED;</span><br><span class="line">                //将当前节点位置放到祖父节点</span><br><span class="line">                t = grand;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            //情况二：叔叔节点是黑色，且当前节点是右子节点</span><br><span class="line">            if (t == parent.right)&#123;</span><br><span class="line">                //从父节点处左旋</span><br><span class="line">                leftRotate(parent);</span><br><span class="line">                //以当前父节点和自己调换，作为新节点，为右旋做准备</span><br><span class="line">                RedBlackNode&lt;AnyType&gt; temp = parent;</span><br><span class="line">                parent = t;</span><br><span class="line">                t = temp;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            //情况三：叔叔节点是黑色，且当前节点是左子节点</span><br><span class="line">            //将当前节点的父节点涂黑，将其祖父涂红</span><br><span class="line">            parent.color = BLACK;</span><br><span class="line">            grand.color = RED;</span><br><span class="line">            rightRotate(grand);</span><br><span class="line">            //与上面对称</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            //3.如果父节点是祖父节点的右子节点，与上面完全相反，本质一样</span><br><span class="line">            RedBlackNode&lt;AnyType&gt; uncle = grand.left;</span><br><span class="line">            //情况一：叔叔节点也是红色</span><br><span class="line">            if (uncle != null &amp;&amp; uncle.color == RED)&#123;</span><br><span class="line">                parent.color = BLACK;</span><br><span class="line">                uncle.color = BLACK;</span><br><span class="line">                grand.color = RED;</span><br><span class="line">                t = grand;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            //情况二：叔叔节点是黑色的，且当前节点是左子节点</span><br><span class="line">            if (t == parent.left)&#123;</span><br><span class="line">                rightRotate(parent);</span><br><span class="line">                RedBlackNode&lt;AnyType&gt; temp = parent;</span><br><span class="line">                parent = t;</span><br><span class="line">                t = temp;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            //情况三：叔叔节点是黑色，且当前节点是右子节点</span><br><span class="line">            parent.color = BLACK;</span><br><span class="line">            grand.color = RED;</span><br><span class="line">            leftRotate(grand);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        this.root.color = BLACK;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void remove(AnyType x)&#123;</span><br><span class="line">        RedBlackNode&lt;AnyType&gt; node = search(x);</span><br><span class="line">        remove(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //t删除节点</span><br><span class="line">    private void remove(RedBlackNode&lt;AnyType&gt; t)&#123;</span><br><span class="line">        //child是最终被删除节点的替代孩子，parent是最终被删除节点的父亲</span><br><span class="line">        RedBlackNode&lt;AnyType&gt; child ,parent;</span><br><span class="line">        boolean color;</span><br><span class="line">        //被删除节点左右孩子都不为空</span><br><span class="line">        if ((t.left != null) &amp;&amp; (t.right != null))&#123;</span><br><span class="line">            //被真正删除节点的后继节点</span><br><span class="line">            RedBlackNode&lt;AnyType&gt; replace = t;</span><br><span class="line">            replace = replace.right;</span><br><span class="line">            //找到其右子树中最小节点</span><br><span class="line">            replace = findMin(replace);</span><br><span class="line">            if (getParent(t) != null)&#123;</span><br><span class="line">                //用后继节点代替要删除的节点</span><br><span class="line">                 if (t == getParent(t).left)&#123;</span><br><span class="line">                    getParent(t).left = replace;</span><br><span class="line">                &#125;else &#123;</span><br><span class="line">                    getParent(t).right = replace;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;else &#123;</span><br><span class="line">                //否则删除的节点时根节点，直接为根节点赋值，只有根节点没有父节点</span><br><span class="line">                this.root = replace;</span><br><span class="line">            &#125;</span><br><span class="line">            //后继节点肯定不存在左子节点，child为后继节点的右孩子</span><br><span class="line">            child = replace.right;</span><br><span class="line">            parent = getParent(replace);</span><br><span class="line">            color = replace.color;</span><br><span class="line">            //若后继结点是要删除节点的儿子，则直接代替</span><br><span class="line">            if (parent == t)&#123;</span><br><span class="line">                parent = replace;</span><br><span class="line">            &#125;else &#123;</span><br><span class="line">                //如果replace存在右孩子</span><br><span class="line">                if (child != null) &#123;</span><br><span class="line">                    //此处真正删除了replace</span><br><span class="line">                    child.parent = parent;</span><br><span class="line">                    parent.left = child;</span><br><span class="line">                    replace.right = t.right;</span><br><span class="line">                    t.right.parent = replace;</span><br><span class="line">                &#125;</span><br><span class="line">                replace.parent = t.parent;</span><br><span class="line">                //保持原来颜色</span><br><span class="line">                replace.color = t.color;</span><br><span class="line">                replace.left = t.left;</span><br><span class="line">                t.left.parent = replace;</span><br><span class="line">                //如果后继节点(真正要删除的节点)的颜色是黑色，重新调整红黑树</span><br><span class="line">                if (color == BLACK) &#123;</span><br><span class="line">                    removeFix(child, parent);</span><br><span class="line">                &#125;</span><br><span class="line">                t = null;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; //被删除</span><br><span class="line"></span><br><span class="line">        //如果被删除的节点只有一个儿子</span><br><span class="line">        if (t.left != null)&#123;</span><br><span class="line">            child = t.left;</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            child = t.right;</span><br><span class="line">        &#125;</span><br><span class="line">        parent = t.parent;</span><br><span class="line">        color = t.color;</span><br><span class="line">        //如果唯一的孩子不为空</span><br><span class="line">        if (child != null)&#123;</span><br><span class="line">            child.parent = parent;</span><br><span class="line">        &#125;</span><br><span class="line">        //如果要删除的节点不是根节点</span><br><span class="line">        if (parent!=null)&#123;</span><br><span class="line">            if (parent.left == t)&#123;</span><br><span class="line">                parent.left = child;</span><br><span class="line">            &#125;else &#123;</span><br><span class="line">                parent.right = child;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            this.root = child;</span><br><span class="line">        &#125;</span><br><span class="line">        //如果删除节点的颜色是黑色，则要调用平衡方法</span><br><span class="line">        if (color = BLACK)&#123;</span><br><span class="line">            removeFix(child,parent);</span><br><span class="line">        &#125;</span><br><span class="line">        t = null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     *  红黑树删除调整方法</span><br><span class="line">     * @param node 后继子节点的子节点，即带修正的节点</span><br><span class="line">     * @param parent</span><br><span class="line">     */</span><br><span class="line">    private void removeFix(RedBlackNode&lt;AnyType&gt; node, RedBlackNode&lt;AnyType&gt; parent) &#123;</span><br><span class="line">            RedBlackNode&lt;AnyType&gt; other = null;</span><br><span class="line"></span><br><span class="line">            while ((node == null || node.color == BLACK) &amp;&amp; (node != this.root)) &#123;</span><br><span class="line">                //当node是左子节点</span><br><span class="line">                if (parent.left == node) &#123;</span><br><span class="line">                    //兄弟节点</span><br><span class="line">                    other = parent.right;</span><br><span class="line">                    //情况一：node的兄弟节点other是红色</span><br><span class="line">                    if (other != null &amp;&amp; other.color == RED) &#123;</span><br><span class="line">                        other.color = BLACK;</span><br><span class="line">                        parent.color = RED;</span><br><span class="line">                        leftRotate(parent);</span><br><span class="line">                        other = parent.right;</span><br><span class="line">                    &#125;</span><br><span class="line">                    //情况二：node的兄弟节点other是黑色的且other的两个子节点也都是黑色</span><br><span class="line">                    if ((other.left == null || other.left.color == BLACK)</span><br><span class="line">                            &amp;&amp; (other.right == null || other.right.color == BLACK)) &#123;</span><br><span class="line">                        other.color = RED;</span><br><span class="line">                        node = parent;</span><br><span class="line">                        parent = getParent(node);</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        //情况三:node的兄弟节点other是黑色，且other的左子节点是红色，右子节点是黑色</span><br><span class="line">                        if (other.right == null || other.right.color == BLACK) &#123;</span><br><span class="line">                            other.left.color = BLACK;</span><br><span class="line">                            other.color = RED;</span><br><span class="line">                            rightRotate(other);</span><br><span class="line">                            other = parent.right;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        //情况四：node的兄弟节点other是黑色的，且other的右子节点是红色，左子节点任意颜色</span><br><span class="line">                        boolean parentColor = parent.color;</span><br><span class="line">                        other.color = parentColor;</span><br><span class="line">                        parent.color = BLACK;</span><br><span class="line">                        other.right.color = BLACK;</span><br><span class="line">                        leftRotate(parent);</span><br><span class="line">                        node = this.root;</span><br><span class="line">                        break;</span><br><span class="line">                        //与上面对称</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    other = parent.left;</span><br><span class="line">                    if (other.color == RED)&#123;</span><br><span class="line">                        other.color = BLACK;</span><br><span class="line">                        parent.color = RED;</span><br><span class="line">                        rightRotate(parent);</span><br><span class="line">                        other = parent.left;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    if ((other.left == null || other.left.color == BLACK) &amp;&amp;</span><br><span class="line">                            (other.right == null) || other.right.color == BLACK)&#123;</span><br><span class="line">                        other.color = RED;</span><br><span class="line">                        node = parent;</span><br><span class="line">                        parent = node.parent;</span><br><span class="line">                    &#125;else &#123;</span><br><span class="line">                        if (other.left == null || other.left.color == BLACK)&#123;</span><br><span class="line">                            other.right.color = BLACK;</span><br><span class="line">                            other.color = RED;</span><br><span class="line">                            leftRotate(other);</span><br><span class="line">                            other = parent.left;</span><br><span class="line">                        &#125;</span><br><span class="line">                        //情况四：node的兄弟节点other是黑色的，且other的右子节点是红色，左子节点任意颜色</span><br><span class="line">                        boolean parentColor = parent.color;</span><br><span class="line">                        other.color = parentColor;</span><br><span class="line">                        parent.color = BLACK;</span><br><span class="line">                        other.right.color = BLACK;</span><br><span class="line">                        leftRotate(parent);</span><br><span class="line">                        node = this.root;</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (node != null)&#123;</span><br><span class="line">                node.color = BLACK;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public RedBlackNode&lt;AnyType&gt; search(AnyType x)&#123;</span><br><span class="line">        return search(x,root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private RedBlackNode&lt;AnyType&gt; search(AnyType x,RedBlackNode&lt;AnyType&gt; t)&#123;</span><br><span class="line">        while (t != null)&#123;</span><br><span class="line">            int comparableResult = x.compareTo(t.element);</span><br><span class="line">            if (comparableResult &lt; 0 )&#123;</span><br><span class="line">                t = t.left;</span><br><span class="line">            &#125;else if (comparableResult &gt; 0)&#123;</span><br><span class="line">                t = t.right;</span><br><span class="line">            &#125;else &#123;</span><br><span class="line">                return t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //以t为支点右旋操作</span><br><span class="line">    private void rightRotate(RedBlackNode&lt;AnyType&gt; t) &#123;</span><br><span class="line">        RedBlackNode&lt;AnyType&gt; leftNode = t.left;</span><br><span class="line">        t.left = leftNode.right;</span><br><span class="line">        if (leftNode.right != null)&#123;</span><br><span class="line">            leftNode.right.parent = t;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        leftNode.parent = t.parent;</span><br><span class="line">        if (t.parent == null)&#123;</span><br><span class="line">            this.root = leftNode;</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            if (t == t.parent.right)&#123;</span><br><span class="line">                t.parent.right = leftNode;</span><br><span class="line">            &#125;else &#123;</span><br><span class="line">                t.parent.left = leftNode;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        leftNode.right = t;</span><br><span class="line">        t.parent = leftNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //以t为支点左旋操作</span><br><span class="line">    private void leftRotate(RedBlackNode&lt;AnyType&gt; t) &#123;</span><br><span class="line">        RedBlackNode&lt;AnyType&gt; rightNode = t.right;</span><br><span class="line">        t.right = rightNode.left;</span><br><span class="line">        if (rightNode.left != null)&#123;</span><br><span class="line">            rightNode.left.parent = t;</span><br><span class="line">        &#125;</span><br><span class="line">        rightNode.parent = t.parent;</span><br><span class="line">        //如果 parent 没有父节点说明 parent 是根节点</span><br><span class="line">        if (t.parent == null)&#123;</span><br><span class="line">            this.root = rightNode;</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            //判断parent是左子树还是右子树</span><br><span class="line">            if (t == t.parent.left)&#123;</span><br><span class="line">                t.parent.left = rightNode;</span><br><span class="line">            &#125;else &#123;</span><br><span class="line">                t.parent.right = rightNode;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        rightNode.left = t;</span><br><span class="line">        t.parent = rightNode;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public RedBlackNode&lt;AnyType&gt; getParent(RedBlackNode&lt;AnyType&gt; t)&#123;</span><br><span class="line">        return (t != null)? t.parent :null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public RedBlackNode&lt;AnyType&gt; findMin(RedBlackNode&lt;AnyType&gt; t)&#123;</span><br><span class="line"></span><br><span class="line">        if (t == null)&#123;</span><br><span class="line">           while (t.left != null)&#123;</span><br><span class="line">                   t = t.left;</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line">         return t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public RedBlackNode&lt;AnyType&gt;  findMax(RedBlackNode&lt;AnyType&gt; t)&#123;</span><br><span class="line">         if (t != null)&#123;</span><br><span class="line">             while (t.right != null)&#123;</span><br><span class="line">                 t = t.right;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">        return t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h6><p><a href="https://blog.csdn.net/eson_15/article/details/51144079" target="_blank" rel="noopener">eson_15 的 csdn</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;平衡树&quot;&gt;&lt;a href=&quot;#平衡树&quot; class=&quot;headerlink&quot; title=&quot;平衡树&quot;&gt;&lt;/a&gt;平衡树&lt;/h3&gt;&lt;p&gt;标题中的AVL树和红黑树都是二叉查找树，二叉查找树不熟的可以看一下&lt;a href=&quot;https://dombro96.github.
      
    
    </summary>
    
    
      <category term="数据结构 Data Structures" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-Data-Structures/"/>
    
  </entry>
  
  <entry>
    <title>几种基本排序</title>
    <link href="http://yoursite.com/2018/03/19/%E5%87%A0%E7%A7%8D%E5%9F%BA%E6%9C%AC%E6%8E%92%E5%BA%8F/"/>
    <id>http://yoursite.com/2018/03/19/几种基本排序/</id>
    <published>2018-03-19T12:18:22.000Z</published>
    <updated>2018-03-21T07:24:28.606Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>大二的时候，一位学长跟我说他找的实习笔试就考了几个排序。当时想，嗨一个排序有什么难的。昨个打算靠自己的记忆 “背”出几个排序，然而对着纸笔看了半天也就只有几个名词能想的起来，冒泡、插入、快排…至于怎么排的全都忘了。在嫌弃自己记忆力的同时，也知道在当初学的时候就没有好好理解每种排序的思想，这东西就不是死记硬背可以吃的透的。好好的看了一天书，总结了七中常见的排序方法，日后一定勤于钻研，每日默写2333…</p><h3 id="约定"><a href="#约定" class="headerlink" title="约定"></a>约定</h3><p>往下看以前约法几章</p><ul><li>下面的几种排序都是属于内部排序，即适用数据相对较小的数组。</li><li>规定 N 代表数组的规模。</li><li>数组的类型默认使用较好理解的整型。</li><li>我不想在排序这种基本算法博客上画太多的图，除了比较难理解的排序，不会有太多图片演示。毕竟程序员还是要练习一下空间想象力的。主要也是懒..</li></ul><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><p>首先说插入排序，为什么上来说插入排序呢？因为我喜欢…<br>1) 插入排序是由 N-1 趟排序组成的,如果用 p 表示趟数，则一共从 p=1 趟到 p = N-1 趟。<br>2) 插入排序每要做的就是，在第 p 趟，将位置 p 上的元素向左移动（你也可以理解为向左插入），直到前 p+1 个元素是有序的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">/**插入排序算法思想:</span><br><span class="line">/1.要进行N-1(Ｎ为数组规模)趟排序排序 。</span><br><span class="line">/2.对于 p=1　到　p = N-１趟，每趟排序要确保 array[0] 到   array[p] 变为有序。(p为元素位置索引)</span><br><span class="line">/3.每趟排序从位置 p 开始，将array[p]向左移动，直到寻找 array[p] 的合适位置，即前 p+1 个元素为有序的。</span><br><span class="line">*/</span><br><span class="line">public static void insertionSort(int[] array)&#123;</span><br><span class="line">    int j;</span><br><span class="line">    //要有</span><br><span class="line">    for (int p = 1; p &lt; array.length; p++)&#123;</span><br><span class="line">        //temp 用来保存 array[p] 的值</span><br><span class="line">        int temp = array[p];</span><br><span class="line">        //每一趟的排序算法</span><br><span class="line">        for (j = p; j &gt; 0 &amp;&amp; temp &lt; array[j-1];j--)&#123;</span><br><span class="line">            array[j] = array[j-1];</span><br><span class="line">        &#125;</span><br><span class="line">        array[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该算法之所以可行，是因为下一趟趟排序前，前面的元素都已经有序,你只需要在每趟排序为 位置p 上的元素找到合适位置即可，就像将该元素插入到前 p+1 个元素中。插入已排序的平均时间复杂度是 O(N<sup>2</sup>)。</p><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><p>冒泡排序真的不想再多说了，冒泡排序一共要进行 N 趟排序，每趟排序会把本趟找到的最大的值放到数组的末尾。就像气泡上升一样一样。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">    * 冒泡排序算法思路</span><br><span class="line">    * 1.是很简单且效率很低的排序</span><br><span class="line">    * 2.一共要进行N趟排序</span><br><span class="line">    * 3.每趟排序比较相邻元素大小，发现前一个数毕后一个数大交换，确保每趟排序将最大值放至末尾</span><br><span class="line">    */</span><br><span class="line">   public static void bubbleSort(int[] array)&#123;</span><br><span class="line">       //一共进行N趟排序</span><br><span class="line">       for (int i = 0;i &lt; array.length-1;i++)&#123;</span><br><span class="line">           //内层循环同时决定了比较的下界，即每趟排序的最大值会是上一趟排序最大值的上一个元素</span><br><span class="line">           for (int j = 0;j &lt; array.length - i;j++)&#123;</span><br><span class="line">               //发现逆序就交换</span><br><span class="line">               if (j+1 &lt; array.length &amp;&amp; array[j] &gt; array[j+1])&#123;</span><br><span class="line">                   int temp = array[j];</span><br><span class="line">                   array[j] = array[j+1];</span><br><span class="line">                   array[j+1] = temp;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>很明显冒泡排序的平均时间复杂度是 O(N<sup>2</sup>)。</p><h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><p>选择排序也要进行 N 趟排序，思路是每趟排序从数组中随机找一个元素chosen和其他元素比较，找出比chosen元素小的就用该较小值代替，这样每趟排序都会找出该趟的最小值，放到前面。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">    * 选择排序算法思想：</span><br><span class="line">    * 1.该算需要进行N趟排序</span><br><span class="line">    * 2.每趟排序选择出一个元素，比较数组中比该元素小且最小的元素，</span><br><span class="line">    *   即每趟选择都会挑选出剩余元素中最小的。这点和冒泡排序正好相反。</span><br><span class="line">    */</span><br><span class="line">   public static void selectionSort(int[] array)&#123;</span><br><span class="line"></span><br><span class="line">       for (int i = 0; i &lt; array.length; i++) &#123;</span><br><span class="line">           int chosen = i;</span><br><span class="line">           for (int j = i+1;j &lt; array.length;j++)&#123;</span><br><span class="line">               if (array[j] &lt; array[chosen])&#123;</span><br><span class="line">                   chosen = j;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           if (i != chosen)&#123;</span><br><span class="line">               int temp = array[chosen];</span><br><span class="line">               array[chosen] = array[i];</span><br><span class="line">               array[i] = temp;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>很明显选择排序的平均时间复杂度是 O(N<sup>2</sup>)。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>我们看到无论插入排序、选择排序、冒泡排序的时间复杂度都是可怕的  O(N<sup>2</sup>) 。这是为什么呢？答案很简单上面的三种排序都交换了相邻元素。</p><blockquote><p>定理：通过交换相邻元素进行排序的人和算法平均时间都需要 Ω(N<sup>2</sup>)。</p></blockquote><p>由此需要找到另外的排序方案，即可以对相对距离较远的元素进行比较的排序。</p><h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><p>希尔排序通过比较一定间隔的元素来工作，各趟比较所用的距离随算法的进行而减小，直到只比较相邻元素的最后一趟排序为止。</p><ul><li>增量序列</li></ul><blockquote><p>希尔排序是使用一个增量序列 h<sub>1</sub>，h<sub>2</sub> h<sub>3</sub>…h<sub>k</sub> 叫做增量序列。只要 h<sub>1</sub> = 1 ，任何增量序列都是可行的，不过合理的选择增量序列会影响希尔排序的效率。</p></blockquote><p>希尔排序比较的趟数取决于增量序列，有几个增量就会比较几趟，在使用增量 h<sub>k</sub> 的一趟排序后，对于每一个i都会有a[i] &lt;= a[i+h<sub>k</sub>]。这句话的意思是数组中只要相隔 h<sub>k</sub> 的元素就会被比较。</p><p><img src="http://p0bl99g4r.bkt.clouddn.com/ds_hellsort.png" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * 希尔排序算法思想:</span><br><span class="line">     * 1.通过比较一定间隔的元素进行工作。</span><br><span class="line">     * 2.比较的间隔按照一定增量序列  h1,h2...ht 决定。</span><br><span class="line">     * 3.各趟比较的间隔随算法的进行而减小，直到只比较相邻元素的最后一趟（即增量为1）。</span><br><span class="line">     * 4.每趟比较下来，都会得到 a[i] &lt;= a[i+ht]。</span><br><span class="line">     * 5.希尔排序的效率和增量的选择有很大的关系</span><br><span class="line">     */</span><br><span class="line">    public static void hellSort(int[] array)&#123;</span><br><span class="line">        int j;</span><br><span class="line">        int gap;</span><br><span class="line">        //gap即增量，这里定义增量</span><br><span class="line">        for (gap = array.length/2; gap &gt; 0;gap /= 2 );</span><br><span class="line">        //每一趟的排序算法</span><br><span class="line">            for (int i = gap; i &lt; array.length; i++)&#123;</span><br><span class="line">                int temp = array[i];</span><br><span class="line">                //比较增量内的两个元素,必要时交换</span><br><span class="line">                for (j = i; j &gt;= gap &amp;&amp; temp &lt; array[j - gap] ;j -= gap)&#123;</span><br><span class="line">                    array[j] = array[j-gap];</span><br><span class="line">                &#125;</span><br><span class="line">                array[j] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>你会注意到增量的选择是取 length/2 ，而后的增量则是上一增量 除2 得到，这样选是一个比较这种的办法，也是算法发明者希尔他老人家推荐的。希尔排序的最差效率是O(N<sup>2</sup>)，但其平均效率性能在实践中是完全可以接受的。</p><h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><p>堆排序是一个很有意思的排序，它用到了所谓的变治法，给出了目前为止最佳大O时间，O (NlogN)。那么它是如何变治的呢？这是我非常喜欢的一个算法。由于之前写过一个关于<a href="https://dombro96.github.io/2017/12/04/%E5%A0%86%E6%8E%92%E5%BA%8F-HeapSort/" target="_blank" rel="noopener">变治法堆排序的博客</a>，不过我真的是太喜欢这个算法了，再唠叨一遍。</p><ul><li>堆与大顶堆</li></ul><p>堆 : 就是逻辑上的二叉树，就是把一个数组想象成二叉树，但数据结构还是线性的。索引为 i 的父节点元素的左孩子和右孩子分别是索引为 2<em>i+1 和 2</em>i+2 索引的元素。<br>大顶堆 : 大顶堆就是堆中的节点都不小于其孩子节点，也就是说大顶堆中的根节点(索引为0的元素)是最大的。</p><ul><li>算法思路</li></ul><p>根据上面所说大顶堆的根节点是最大的，如果我们每次都能取到大顶堆的最大元素…整个排序就迎刃而解了！<br>1.首先将数组初始化成堆，这样数组的首元素就变成了最大的。<br>2.将数组首元素和尾元素交换位置。<br>3.<strong>将除目前尾元素的数组堆化</strong>(即不在考虑当前堆中最后一个元素)，重复 2 、 3 步骤，知道堆中只剩下一个元素。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * 堆排序算法思想</span><br><span class="line">     * 1.首先将规模为 n的数组 array 变成大顶推。</span><br><span class="line">     * 2.其次将该大顶堆中最后一个元素 array[n-1] 与一个元素 array[0] 交换位置，得到的 array[n-1] 便是最大元素。</span><br><span class="line">     * 3.在调整剩余元素为大顶堆,再将剩余元素最后一个与第一个元素交换，直到堆的大小为 1 时。</span><br><span class="line">     */</span><br><span class="line">    public static void heapsort(int[] array) &#123;</span><br><span class="line">        for (int i = array.length / 2; i &gt; 0; i--) &#123;</span><br><span class="line">            buildHeap(array, i, array.length);</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = array.length - 1; i &gt; 0; i--) &#123;</span><br><span class="line">            int temp = array[i];</span><br><span class="line">            array[i] = array[0];</span><br><span class="line">            array[0] = temp;</span><br><span class="line">            buildHeap(array, 0, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 堆排序的堆化函数</span><br><span class="line">     *</span><br><span class="line">     * @param array</span><br><span class="line">     * @param parent</span><br><span class="line">     * @param length</span><br><span class="line">     */</span><br><span class="line">    public static void buildHeap(int[] array, int parent, int length) &#123;</span><br><span class="line">        int child;</span><br><span class="line">        int temp;</span><br><span class="line">        for (temp = array[parent]; liftChild(parent) &lt; length; parent = child) &#123;</span><br><span class="line">            System.out.println(temp + &quot;,&quot;);</span><br><span class="line">            child = liftChild(parent);</span><br><span class="line">            //挑选其右孩子</span><br><span class="line">            if (child != length - 1 &amp;&amp; array[child + 1] &gt; array[child]) &#123;</span><br><span class="line">                child = child + 1;</span><br><span class="line">            &#125;</span><br><span class="line">            if (temp &lt; array[child]) &#123;</span><br><span class="line">                array[parent] = array[child];</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        array[parent] = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 堆排序获取一个节点的左孩子在数组中的位置</span><br><span class="line">     */</span><br><span class="line">    public static int liftChild(int parent) &#123;</span><br><span class="line">        return 2 * parent + 1;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><p>归并排序也是一个很好玩的排序，使用了递归的方式。归并排序最有特点的就是使用了分治法种思想，将原数组进行合并排序，很多递归程序都使用了</p><ul><li>合并排序</li></ul><p>合并排序就是将两个有序数组进行排序。排序的方式很简单，需要利用一个中间数组。<br>1.将两个有序数组A、B的中的元素进行比较，若 A[0] &lt; B[0] 则把 A[0] 放入 中间数组中，比较 A[1] 和 B[0]，如果一个数组比较完后另一个数组还有剩余则将该数组剩余元素放入中间数组中，这样中间数组就是一个有序的数组啦。</p><p><img src="http://p0bl99g4r.bkt.clouddn.com/ds_mergeSort.png" alt=""></p><p>由上面的图可以看到，合并两个有序的数组时间是线性的，因为最多进行 N-1 次比较。</p><ul><li>算法思路</li></ul><p>根据合并排序，使原数组变为有序的方法就是 <strong>原数组变为两个有序数组，在使用合并排序</strong>，可是要怎样使两个数组变为有序呢？你既然可以想出原数组变为有序的方法，那一半的怎么可能不会？递归呀！！</p><p>1.递归求得前后两部分元素的有序数组。<br>2.前后两部分数组进行合并排序。就是这么简单。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * 归并排序算法思想:</span><br><span class="line">     * 1.利用递归将数组前半部分和后半部分数据各自归并排序。</span><br><span class="line">     * 2.再将排好序的两部分数组合并排序。</span><br><span class="line">     * 3.算法属于分治策略，他将问题分成小为题然后递归求解。</span><br><span class="line">     * 4.归并排序是所有流行比较里面比较次数最少的。</span><br><span class="line">     */</span><br><span class="line">    /**</span><br><span class="line">     * @param array 传入数组</span><br><span class="line">     */</span><br><span class="line">    public static void mergeShort(int[] array) &#123;</span><br><span class="line">        int[] tempArray = new int[array.length];</span><br><span class="line">        mergeShort(array, tempArray, 0, array.length - 1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @param array     传入要排序的数组</span><br><span class="line">     * @param tempArray 用来保存将前后两部分数组合并后的数组</span><br><span class="line">     * @param left      array 数组的首个元素索引</span><br><span class="line">     * @param right     array 数组最后一个元素索引</span><br><span class="line">     */</span><br><span class="line">    public static void mergeShort(int[] array, int[] tempArray, int left, int right) &#123;</span><br><span class="line">        //递归的出口是数组元素大于一</span><br><span class="line">        if (left &lt; right) &#123;</span><br><span class="line">            int center = (left + right) / 2;</span><br><span class="line">            //首先对前后两半数组分别排序，使其成为</span><br><span class="line">            mergeShort(array, tempArray, left, center);</span><br><span class="line">            mergeShort(array, tempArray, center + 1, right);</span><br><span class="line">            merge(array, tempArray, left, center + 1, right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 该方法为合并排序，合并排序用来对两个有序数组进行排序，本例子中该有序数组是传入数组的前后两半部分。</span><br><span class="line">     *</span><br><span class="line">     * @param array     传入的要合并排序的数组</span><br><span class="line">     * @param tempArray 用来保存两数组排序后元素的数组</span><br><span class="line">     * @param leftPos   记录前一半数组元素首个元素位置</span><br><span class="line">     * @param rightPos  记录后一半数组元素首个元素位置</span><br><span class="line">     * @param rightEnd  后一半数组最后元素索引</span><br><span class="line">     */</span><br><span class="line">    public static void merge(int[] array, int[] tempArray, int leftPos, int rightPos, int rightEnd) &#123;</span><br><span class="line"></span><br><span class="line">        int liftEnd = rightPos - 1;</span><br><span class="line">        //tempArray首个元素索引,用于记录当前位置索引</span><br><span class="line">        int tempPos = leftPos;</span><br><span class="line">        //比较两半部分数组中元素大小，将小的放入tempArray数组中，直到其中一个数组元素都比较完毕</span><br><span class="line">        while (leftPos &lt;= liftEnd &amp;&amp; rightPos &lt;= rightEnd) &#123;</span><br><span class="line">            if (array[leftPos] &lt;= array[rightPos]) &#123;</span><br><span class="line">                tempArray[tempPos++] = array[leftPos++];</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                tempArray[tempPos++] = array[rightPos++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //当发现数组没有比较完，说明该数组剩下元素可以直接放入tempArray中</span><br><span class="line">        while (leftPos &lt;= liftEnd) &#123;</span><br><span class="line">            tempArray[tempPos++] = array[leftPos++];</span><br><span class="line">        &#125;</span><br><span class="line">        while (rightPos &lt;= rightEnd) &#123;</span><br><span class="line">            tempArray[tempPos++] = array[rightPos++];</span><br><span class="line">        &#125;</span><br><span class="line">        //将排序结果放回到原数组中</span><br><span class="line">        for (int i = 0; i &lt; array.length; i++, rightEnd--) &#123;</span><br><span class="line">            array[rightEnd] = tempArray[rightEnd];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>算法效率</li></ul><p>归并排序的运行时间是 O(NlogN)，但他有一个明显的问题，即合并两个已排序表用到的附加线性内存。但是归并排序是流行的排序算法中最少比较次数的，因此是使用 Java 语言通用的排序算法中上好的选择。事实上，他就是标准Java类库泛型排序使用的默认排序。</p><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p>快速排序同样用到了递归，我认为他是对归并排序的一种改进,因为归并排序用到了中间数组，产生了多余的空间。快速排序并没有用到中间数组，他的思路同样清晰：</p><p>1.在一个数组中选择一个元素叫他枢纽，对数组元素进行比较，前面的元素都比枢纽小，后面的元素都比枢纽大。<br>2.这样数组就变成了三部分，大数集，小数集，还有枢纽。<br>3.对大数集和小数集递归使用快速排序。</p><p><img src="http://p0bl99g4r.bkt.clouddn.com/ds_quickSort.png" alt=""></p><ul><li>枢纽元素的选取</li></ul><p>通过图片你会发现枢纽的选取是一门学问。虽然快速排序中选取那个元素作为枢纽都会完成工作，但是很明显有些选择更优。推荐一种选取枢纽的方法 —— 三数中值分割法。这里说的三数分别是数组首元素 array[0] 、中间元素 array[length/2]、数组尾元素 array[length-1] 的中值。</p><ul><li>分割策略</li></ul><p>快速排序再找到枢纽后会对数组作一个分割。分割要做的就是把所有小的元素移到数组的左边而把所有大的元素移到数组的右边。当然小和大是相对于枢纽而言。<br>1.首先要将枢纽选取时的三个元素放在合适位置，最大的放在数组末尾，最小的放在数组开头，而枢纽则放在尾元素的前一位(这样保证比枢纽大的元素在枢纽右侧)。<br>2.有两个指针i、j，i 从首元素下一元素开始，只要array[i] &lt; 枢纽则 i 向右移 ; j 从枢纽前一个元素开始,只要array[j] &gt; 枢纽则 j 向左移，移动直到 i 和 j 交错，即 j &lt; i 指针移动停止。</p><p><img src="http://p0bl99g4r.bkt.clouddn.com/ds_quickSort2.png" alt=""></p><p>这个例子举得不是特别好…有意思的是快速排序平均效率虽然为O(NlogN)，但如果数组规模不到20，那么它的效率还没有插入排序好,所以快速排序对规模较大的数组有较好的效率。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * 快速排序算法思想(较难理解)：</span><br><span class="line">     * 1.在传入数组中找出一个枢纽元素(利用三数中值法)，使用分割法将数组分为两部分，比该枢纽大的元素部分，个比该枢纽元素小的部分。</span><br><span class="line">     * 2.在对 1 中两个部分数组进行递归的快排序。</span><br><span class="line">     * 3.对数组不足20的数组使用插入排序，因为数组规模较小时使用插入排序效率更高。</span><br><span class="line">     */</span><br><span class="line">    public static void quickSort(int[] array) &#123;</span><br><span class="line">        quickSort(array, 0, array.length - 1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @param array 传入数组</span><br><span class="line">     * @param left  首元素索引</span><br><span class="line">     * @param right 尾元素素银</span><br><span class="line">     */</span><br><span class="line">    private static void quickSort(int[] array, int left, int right) &#123;</span><br><span class="line"></span><br><span class="line">        if (right - left &gt; 20) &#123;</span><br><span class="line">            //获取枢纽元素</span><br><span class="line">            int pivot = median3(array, left, right);</span><br><span class="line">            int i = left + 1;</span><br><span class="line">            int j = right - 2;</span><br><span class="line">            //使用分割法</span><br><span class="line">            //１.i 从 第二个元素 开始向右移，j 从 枢纽元素前一个元素向左移，当 i 指向的元素比枢纽元素大时 i 停止移动；</span><br><span class="line">            //当 j 指向的元素比枢纽元素小时 j 停止移动，</span><br><span class="line">            //２.当 i 和 j都停止移动时交换　ｉ　和　ｊ　所 对指向的元素。该过程直到 ｉ 大于 ｊ 为止，此时保证所有比枢纽元素小的元素都在 i　的左边。</span><br><span class="line">            //３.最后一步将枢纽元素和ｉ所指的元素交换</span><br><span class="line">            for (; ; ) &#123;</span><br><span class="line">                while (array[i] &lt; array[pivot]) i++;</span><br><span class="line">                while (array[j] &gt; array[pivot]) j--;</span><br><span class="line">                if (i &lt; j) &#123;</span><br><span class="line">                    swapReferences(array, i, j);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            swapReferences(array, i, right - 1);</span><br><span class="line">            //递归的将比枢纽元素小的数组和比枢纽元素大的数组进 快速排序</span><br><span class="line">            quickSort(array, left, i - 1);</span><br><span class="line">            quickSort(array, i + 1, right);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            //如果数组规模较小则使用插入排序</span><br><span class="line">            insertionSort(array);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //交换数组中两元素位置方法，没什么技高含量</span><br><span class="line">    private static void swapReferences(int[] array, int item1, int item2) &#123;</span><br><span class="line">        int temp = array[item1];</span><br><span class="line">        array[item1] = array[item2];</span><br><span class="line">        array[item2] = temp;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>算法效率</li></ul><p>上面是介绍了快速排序的平均大O时间是 O(NlogN) ，但是当数组规模不大时，建议使用插入排序。实际上该算法之所以快是因为非常精炼和高度优化的内部循环。在Java和C++中快速排序是基本类型的标准库排序。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>事实上每种排序都有自己的合适使用场景，比如归并并排序不适合规模较大的数组排序，而给出的时间复杂度也只是一个平均值。算法这东西重在理解和自身的感受，我觉得写完这篇笔记后对这几种简单排序又有了新的理解。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;大二的时候，一位学长跟我说他找的实习笔试就考了几个排序。当时想，嗨一个排序有什么难的。昨个打算靠自己的记忆 “背”出几个排序，然而对着纸笔看
      
    
    </summary>
    
    
      <category term="算法algorithm" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95algorithm/"/>
    
  </entry>
  
  <entry>
    <title>线程</title>
    <link href="http://yoursite.com/2018/03/11/%E7%BA%BF%E7%A8%8B/"/>
    <id>http://yoursite.com/2018/03/11/线程/</id>
    <published>2018-03-11T03:16:03.000Z</published>
    <updated>2018-03-14T06:00:14.720Z</updated>
    
    <content type="html"><![CDATA[<h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>如果你穿越到三十年前，网络并不普及，在Internet只有几百万用户而不是现在的数十亿时，你会发现网站比现在的更加拥堵。这个问题在于，当时大多数FTP服务器会为每个连接创建一个进程，意味着100个并发用户就要处理额外的100个进程。由于进程是相当重量级的，太多进程会很快让服务器吃不消。因此人们想到了一个解决方案——使用线程。</p><h3 id="什么是线程"><a href="#什么是线程" class="headerlink" title="什么是线程"></a>什么是线程</h3><blockquote><p>一个程序执行多个任务，每一个任务就是一个线程。它是线程控制的简称，可以同时运行一个以上线程的程序称作多线程程序。  ——《Java核心技术卷一》</p></blockquote><ul><li>线程 VS 进程</li></ul><p>回到最开始的例子，为什么使用线程替代进程就可以解决网站拥堵的问题呢？这得从他们各自的特点说起,每个进程都拥有自己的一块内存，拥有自己的一套变量(资源)。而线程则在一个进程中运行，在一块内存中共享变量(资源)。想象一下当使用多线程处理网站请求时，在一块内存中的线程处理不同的请求一定比为每个处理请求开辟新进程更加高效。</p><blockquote><p>使用线程来代替进程，可以让你的服务器性能提升三倍。如果重用线程池，在同样的硬件和网络连接条件下，服务器的运行可以快九倍多。           ——《Java网络编程》</p></blockquote><p><em>注：实际上在处理网站拥堵问题上，还有一种重用进程的解决方案，即在服务器启动时就创建固定数量的进程，处理请求不时在新建进程而重用那些处理完请求但未销毁的进程。</em></p><h3 id="多线程编程"><a href="#多线程编程" class="headerlink" title="多线程编程"></a>多线程编程</h3><p>在 Java 中 Thread 是 java.lang.Thread 类的一个实例。Java 作为面向对象语言的大佬，用 Thread对象 来与虚拟机中的线程(thread)对应。这一节会你看到是Java如何启动线程，以及线程的运行。</p><h4 id="Java-线程的启动"><a href="#Java-线程的启动" class="headerlink" title="Java 线程的启动"></a>Java 线程的启动</h4><p>在初次接触线程时，感觉很奇怪（大概所有习惯单线程编程的程序员都会有些奇怪），有些茫然不知所措，不知道我写的线程究竟有没有运行。Java 线程的启动，要构造一个 Thread 实例，调用它的 start() 方法:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Thread t = new Thread();</span><br><span class="line">t.start();</span><br></pre></td></tr></table></figure><p>这个线程并没啥意思，因为他什么都没有做。要想让线程完成一些任务，可以继承Thread类覆盖其run()方法。也可以实现Runnable接口，将 Runnable 对象传递给Thread构造函数 。实际上 run()方法封装了线程的工作，线程结束在于run()方法是否完成。</p><h4 id="派生Thread"><a href="#派生Thread" class="headerlink" title="派生Thread"></a>派生Thread</h4><p>要想让线程做一些任务，就一定要在run()方法中实现。下面介绍通过派生Thread类，重写run()方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class PrintThread extends Thread &#123;</span><br><span class="line"></span><br><span class="line">    private String name;</span><br><span class="line"></span><br><span class="line">    public PrintThread(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        System.out.println(name);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        for (String name:args)&#123;</span><br><span class="line">            PrintThread printThread = new PrintThread(name);</span><br><span class="line">            printThread.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这段代码，mian()方法从命令行读取参数，针对每个参数都会启动一个 PrintThread 线程，这个线程的工作实际上是在run()方法中完成的，即每个线程很简单的打印参数。<strong>请务必记住如果对Thread派生子类,就应当只覆盖run()方法。</strong></p><blockquote><p>并且由于run()方法签名是固定的，无法向其中传递参数和返回值。因此需要其他方法向线程传递信息和从中获取信息。传递信息最简单的方法是向构造构造函数中传递参数，这会设置Thread子类中的字段。   ——《Java网络编程》</p></blockquote><h4 id="实现Runnable接口"><a href="#实现Runnable接口" class="headerlink" title="实现Runnable接口"></a>实现Runnable接口</h4><p>实现Runnable接口实际上就是在实现run()方法，实现这个接口的类都必须要提供这个方法，要启动执行Runnable任务的一个线程，可以把这个Runnable对象传入Thread构造函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class PrintRunnable implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">    private String name;</span><br><span class="line"></span><br><span class="line">    public PrintRunnable(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        System.out.println(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        for (String name:args)&#123;</span><br><span class="line">            PrintRunnable runnable = new PrintRunnable(name);]</span><br><span class="line">            Thread thread = new Thread(runnable);</span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然并不认为实现Runnable接口一定比派生Thread方式好，毕竟在不同使用场景下二者优势各有不同。但我更倾向于使用Runnable接口，因为这会更加清楚的将线程完成的任务和线程本身分开。</p><h2 id="从线程返回信息"><a href="#从线程返回信息" class="headerlink" title="从线程返回信息"></a>从线程返回信息</h2><p>把这个部分单拿出来是因为，习惯传统单线程模型的程序员在转向多线程环境时，最难掌握的一点就是如何从线程返回信息(此处的信息一般是在线程结束或者快要结束时获取)。</p><blockquote><p>从结束的线程获取而信息，这是多线程编程中最常被误解的方面之一。 ——《Java网络编程》</p></blockquote><p>之所以出现上述情况是因为，无论是start()方法还是run()方法都不会返回任何值。无法从线程中直接获得返回信息，也就不知道这个线程是否执行完毕。</p><p>###一般错误方法</p><p>你可能会想到在线程对象中增加一个标识，在 run()方法中给标识赋值，在线程启动后，通过该对象获取这个标识就可以在从线程返回信息，<strong>但是这确实一个在多线程操作中大错而特错的思路</strong>！</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class ErrorThread extends Thread&#123;</span><br><span class="line">    //标识</span><br><span class="line">    String digest;</span><br><span class="line"></span><br><span class="line">    public void run()&#123;</span><br><span class="line">        //在线程中为标识赋值</span><br><span class="line">        digest = &quot;Just test thread&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //获取该标识</span><br><span class="line">    public String getDigest() &#123;</span><br><span class="line">        return digest;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ErrorThread err = new ErrorThread();</span><br><span class="line">        err.start();</span><br><span class="line">        //通过线程获取该标识</span><br><span class="line">        System.out.println(err.getDigest());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码的返回结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">null</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure><p>可能会觉得奇怪，怎么会是 null ? 明明为 digest 赋值了。问题在于在单线程的程序中，线程的执行是按照代码顺序的，但是在多线程中，以上面代码为例，在主线程(即main方法)调用err.getDigest()方法之前，被调用的线程有可能还没有结束(即run方法还未执行完)，所以获取到的标识就会是一个null。当然有时候可能在启动线程之前，err.getDigest()就已经执行结束了，那样就会报一个空指针异常。总之，这是一个单线程程序员很容易掉进的坑。</p><h3 id="回调"><a href="#回调" class="headerlink" title="回调"></a>回调</h3><p>回调可以有效的从线程中返回信息。</p><blockquote><p>回调是通过调用主类（即启动这个线程的类）中的一个方法来做到的。这被称为回调（callback），因为线程在完成是反过来调用其创建者。这样一来，主程序就可以等待线程结束期间休息，而不会占用运行线程的时间。  ——《Java网络编程》</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">public class CallbackRunnable implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">    //一个被主类的引用</span><br><span class="line">    private CallbackUserInterface callback;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public CallbackRunnable(CallbackUserInterface callback) &#123;</span><br><span class="line">        this.callback = callback;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        String digest = &quot;Test Callback&quot;;</span><br><span class="line">        //在线程要结束时，回调主类中方法</span><br><span class="line">        callback.receiveDigest(digest);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//调用线程即主类</span><br><span class="line">public class CallbackUserInterface &#123;</span><br><span class="line"></span><br><span class="line">    //标识</span><br><span class="line">    private String digest = &quot;&quot;;</span><br><span class="line">    //接收标识</span><br><span class="line">    public void receiveDigest(String receive)&#123;</span><br><span class="line">        this.digest += &quot;线程返回的信息是:&quot;+receive;</span><br><span class="line">        System.out.println(this.digest);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void calculateDigest()&#123;</span><br><span class="line">        CallbackRunnable cb = new CallbackRunnable(this);</span><br><span class="line">        //启动线程</span><br><span class="line">        Thread thread = new Thread(cb);</span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        CallbackUserInterface userInterface = new CallbackUserInterface();</span><br><span class="line">        userInterface.calculateDigest();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码返回结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">线程返回的信息是:Test Callback</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure><p>神奇吗？可以正常显示。不要觉得神奇，相比于有主程序询问每个线程来寻找答案，而是有每个线程告知主程序答案。就好像那句”上来自己动”，让人觉得舒服。至于为什么不会显示 null 或者空指针异常，也是一个很好理解的，在run方法中告知主线程这个标记，虽然调用了主类对象方法，但还是在线程的程序执行顺序中，所以无论主线程运行顺序如何，都不影响线程的正常执行完毕。唯一要注意的是调用主类方法一定要在线程快要结束工作时进行，否则回调的这个标记就没有意义了。</p><h3 id="Future、Callable和Executor"><a href="#Future、Callable和Executor" class="headerlink" title="Future、Callable和Executor"></a>Future、Callable和Executor</h3><p>如果觉得回调方式麻烦，Java 5 引入了更简单的处理回调的方式。</p><blockquote><p>不再是直接创建一个线程，你要创建一个ExecutorService，他会根据需要为你创建线程。可以向ExecutorService提交Callable任务，对于每个Callable任务，会分别得到一个Future。可以向Future请求得到任务结果。如果结果已经准备就绪，就会立即得到这个结果。如果结果还没准备好，轮询线程会阻塞，知道结果准备就绪。    ——《Java网络编程》</p></blockquote><p>Callable ——提交到——&gt; ExecutorService ——得到——&gt; Future ——查看——&gt; Callable 结果</p><p>Callable 接口定义了一个call()方法,可以返回任意类型，而 Future 可以查看的 Callable 结果就是这个call返回的值。下面是使用多线程快速找到最大值的例子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">//Callable相当于一个任务</span><br><span class="line">public class FindMax implements Callable&lt;Integer&gt;&#123;</span><br><span class="line"></span><br><span class="line">    private int[]data;</span><br><span class="line">    private int start;</span><br><span class="line">    private int end;</span><br><span class="line"></span><br><span class="line">    public FindMax(int[] data, int start, int end) &#123;</span><br><span class="line">        this.data = data;</span><br><span class="line">        this.start = start;</span><br><span class="line">        this.end = end;</span><br><span class="line">    &#125;</span><br><span class="line">    //call 方法可以有任意的返回类型</span><br><span class="line">    @Override</span><br><span class="line">    public Integer call() throws Exception &#123;</span><br><span class="line">        int max = Integer.MIN_VALUE;</span><br><span class="line">        for (int i = start; i &lt; end; i++)&#123;</span><br><span class="line">            if (data[i] &gt; max)</span><br><span class="line">                max = data[i];</span><br><span class="line">        &#125;</span><br><span class="line">        return max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class MaxFinder &#123;</span><br><span class="line"></span><br><span class="line">    public static int max(int[] data) throws IllegalArgumentException, ExecutionException, InterruptedException &#123;</span><br><span class="line">        if (data.length == 1)&#123;</span><br><span class="line">            return data[0];</span><br><span class="line">        &#125;else if (data.length == 0)&#123;</span><br><span class="line">            throw new IllegalArgumentException();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //将任务分解为两个部分</span><br><span class="line">        FindMax task1 = new FindMax(data,0,data.length/2);</span><br><span class="line">        FindMax task2 = new FindMax(data,data.length/2,data.length);</span><br><span class="line"></span><br><span class="line">        //创建两个线程</span><br><span class="line">        ExecutorService service = Executors.newFixedThreadPool(2);</span><br><span class="line">        //分别提交两个线程，并由Future启动</span><br><span class="line">        Future&lt;Integer&gt; future1 = service.submit(task1);</span><br><span class="line">        Future&lt;Integer&gt; future2 = service.submit(task2);</span><br><span class="line">        //通过Future.get()得到Callable的结果</span><br><span class="line">        return Math.max(future1.get(),future2.get());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面例子，将一个数组分成两部分，利用两个线程分别找出这两个部分的最大值，再找出这两个值中最大的。这种办法几乎会同时搜索两个子数组，运行速度几乎可以达到原来的两倍。</p><p><em>尽管可以直接调用call()方法，但这并不是本来目的。而是要通过Future来启动线程并获取call()的返回值，来确定线程是否执行完毕</em>。</p><h2 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h2><p>在图书馆中的书，每个人都可以去借阅，这样可以省下自己的钱去买书。但如果你想看的书不幸被借走了，就只能申请这本书归还时为我保留。同时你也不是能在书上做标记。从图书馆借书而不是自己买，在时间和方便性会有很大的损失，但能够节约钱和存储时间。   </p><blockquote><p>线程就像图书馆的借阅者，它从一个中心资源池中借阅。线程通过共享内存、文件句柄、sokect和其他资源使得程序更高效。只要两个线程不同时使用相同资源，多线程程序就比多进程程序高效得多。             ——《Java网络编程》</p></blockquote><p>多线程的缺点是，如果两个线程同时访问同一个资源，其中一个就必须等待另一个结束。如果其中一个没有等待，资源就有可能会被破坏。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public class PrintRunnable implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">    private String name;</span><br><span class="line"></span><br><span class="line">    public PrintRunnable(String name) &#123;</span><br><span class="line">         this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        name += &quot;: dasdasfafasdsadasdasdsadas&quot;;</span><br><span class="line">        System.out.println(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        String[] strings = &#123;&quot;hello&quot;,&quot;china&quot;,&quot;good&quot;,&quot;how&quot;&#125;;</span><br><span class="line">        for (String string:strings)&#123;</span><br><span class="line">            PrintRunnable runnable = new PrintRunnable(string);</span><br><span class="line">            Thread t = new Thread(runnable);</span><br><span class="line">            t.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这段代码执行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hello: dasdasfafasdsadasdasdsadas</span><br><span class="line">china: dasdasfafasdsadasdasdsadas</span><br><span class="line">good: dasdasfafasdsadasdasdsadas</span><br><span class="line">how: dasdasfafasdsadasdasdsadas</span><br></pre></td></tr></table></figure><p>根据执行结果可以看到，将 name 作为保存变量在线程打印时，这四个线程并行运行，每个线程会在控制台打印一行。但如果打印的不是保存结果的name，而是将中间结果可用时就直接打印在控制台</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//只修改 run方法</span><br><span class="line">@Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line"></span><br><span class="line">        System.out.print(name + &quot;: dasdasfafasdsadasdasdsadas&quot;);</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>执行结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hello: dasdasfafasdsadasdasdsadashow: dasdasfafasdsadasdasdsadaschina: dasdasfafasdsadasdasdsadas</span><br><span class="line">//下面是两个空行</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">good: dasdasfafasdsadasdasdsadas</span><br></pre></td></tr></table></figure><p>可以看到线程结果都混在一起了，造成这种现象的原因是 System.out 是由4个不同的线程共享。如果一个线程通过多个System.out语句向控制台输出，有可能他还没有完成所有写入，就有另一个线程插进来，开始他的输入。至于哪个线程会抢先于其他线程,具体顺序无法确定。</p><p>需要有一种办法能够指定一个共享资源只能由一个线程独占访问来执行一个特定的语句序列。在上面的例子中共享资源是 System.out 而需要独占访问的语句是:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">System.out.print(name + &quot;: dasdasfafasdsadasdasdsadas&quot;);</span><br><span class="line">System.out.println();</span><br></pre></td></tr></table></figure><h3 id="同步块"><a href="#同步块" class="headerlink" title="同步块"></a>同步块</h3><p>为了指示这两行代码应当一起执行，要把它们包围在 sychronized 块中，他会对 System.out 对象同步，使用同步块的run方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">   public void run() &#123;</span><br><span class="line">       synchronized (System.out)&#123;</span><br><span class="line">           System.out.print(name + &quot;: dasdasfafasdsadasdasdsadas&quot;);</span><br><span class="line">           System.out.println(&quot;&quot;);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>执行结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hello: dasdasfafasdsadasdasdsadas</span><br><span class="line">china: dasdasfafasdsadasdasdsadas</span><br><span class="line">good: dasdasfafasdsadasdasdsadas</span><br><span class="line">how: dasdasfafasdsadasdasdsadas</span><br></pre></td></tr></table></figure><blockquote><p>一旦线程开始打印这些值，所有其他线程在打印他们得知之前就必须停止，需要等待这个线程结束。同步要求在同一个对象上同步的所有代码要连续地运行，而不能并行运行。                                     ——《Java网络编程》</p></blockquote><ul><li>注意</li></ul><p>需要注意的是，对不用对象同步的代码或者根本不同步的代码仍然可以与这个代码并行运行。 Java并没有提供任何方法来组织其他线程使用共享资源。他只能防止对同一个对象同步的其他现线程使用这个共享资源。(这段话的意思是如果另一线程中使用了本线程中的同步对象，但是同步的对象与本线程中不一致，也不会影响另一个线程与该线程代码并行运行。)</p><p><strong>只有当两个线程都拥有相同对象的引用时，同步才成为问题。</strong> 同步块就是将可能与其他线程共享的资源用锁包裹起来，这样其他线程在当前线程运行时，就不能对该资源操作。与同步块对应的还有同步方法，同步方法是对当前对象(this引用)同步整个方法。</p><h4 id="举个例子"><a href="#举个例子" class="headerlink" title="举个例子"></a>举个例子</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">//该类向文件中写入数据</span><br><span class="line">public class WriterFile &#123;</span><br><span class="line"></span><br><span class="line">    private Writer out;</span><br><span class="line"></span><br><span class="line">    public WriterFile(File file) throws IOException &#123;</span><br><span class="line">        FileWriter writer = new FileWriter(file);</span><br><span class="line">        this.out = new BufferedWriter(writer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void writeEntry(String message) throws IOException &#123;</span><br><span class="line">        out.write(message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void close() throws IOException &#123;</span><br><span class="line">        out.flush();</span><br><span class="line">        out.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//线程类，要在线程中调用 WriterFile 的方法</span><br><span class="line">public class WriteRunnable implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">    private WriterFile writerFile;</span><br><span class="line"></span><br><span class="line">    private String message;</span><br><span class="line"></span><br><span class="line">    //在构造方法中为 WriterFile域 赋值</span><br><span class="line">    public WriteRunnable(WriterFile writerFile,String messasge) &#123;</span><br><span class="line">        this.writerFile = writerFile;</span><br><span class="line">        this.message = messasge;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">          //在run()方法中会调用写入数据方法</span><br><span class="line">            writerFile.writeEntry(message);</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//主类</span><br><span class="line">public class Test &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line"></span><br><span class="line">        WriterFile writerFile = new WriterFile(new File(&quot;C:\\Users\\18246\\Desktop\\thread.txt&quot;));</span><br><span class="line">        //向两个线程中传入同一个WriterFile对象</span><br><span class="line">        WriteRunnable runnable1 = new WriteRunnable(writerFile,&quot;我来自第一个线程&quot;);</span><br><span class="line">        WriteRunnable runnable2 = new WriteRunnable(writerFile,&quot;我来自第二个线程&quot;);</span><br><span class="line">        Thread t1 = new Thread(runnable1);</span><br><span class="line">        Thread t2 = new Thread(runnable2);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面例子中，在主类中向线程传入同一个WriterFile对象，这肯定是要出问题的，因为在run()方法中会调用WriterFile写入数据方法，一个线程在写入过程中另一个线程完全有可能会打断，这就会出现写入问题。有三种解决办法：</p><ul><li>第一种使用上面提到的同步块对Writer对象out同步</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public void writeEntry(String message) throws IOException &#123;</span><br><span class="line">        synchronized (out)&#123;</span><br><span class="line">            out.write(message);</span><br><span class="line">            out.write(&quot;\r\n&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这是由于使用这个WriterFile对象的线程也会使用属于这个WriterFile的同一个对象out。</p><ul><li>第二种是对WriterFile对象本身同步，这很简单只需要用到this关键字</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public void writeEntry(String message) throws IOException &#123;</span><br><span class="line">        synchronized (this)&#123;</span><br><span class="line">            out.write(message);</span><br><span class="line">            out.write(&quot;\r\n&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>第三种是Java提供的一个快捷方式，同步方法，即在方法声明添加修饰符</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public synchronized void writeEntry(String message) throws IOException &#123;</span><br><span class="line">            out.write(message);</span><br><span class="line">            out.write(&quot;\r\n&quot;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>同步这里说的比较多，比较啰嗦，是因为在平时写单线程代码很少遇到这种资源共享情况。但是同步也有一定弊端，比如降低性能，还会造成死锁，<strong>最关键的一点是同步可能并不会保护真正需要保护的对象。</strong> 上面例子中 out 是真正要被保护的对象，但如果其他与 WriterFile 完全不相关的类有 out 的引用，那么 out  也会写入失败。不过上面例子中，由于out是一个私有变量，由于没有提供这个对象的引用，所以其他对象也没有办法调用这个对象啦。</p><h3 id="同步的替代方法"><a href="#同步的替代方法" class="headerlink" title="同步的替代方法"></a>同步的替代方法</h3><p>同步是为了保护某个可以共用的资源，那么避免同步就要想办法避免使用这种共用资源。下面有三种同步的替代方法。</p><ul><li>局部变量代替字段</li></ul><blockquote><p>局部变量不存在同步问题。每次进入一个方法时，虚拟机将为这个方法创建一组全新的局部变量。这些变量是外部不可见的，而且方法退出时将被撤销。因此一个局部变量不可能有两个不同的线程共享。     ——《Java网络编程》</p></blockquote><p>所以上面的例子中 writeEntry() 方法可以写成</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public void writeEntry(String message) throws IOException &#123;</span><br><span class="line">    //out作为局部变量</span><br><span class="line">    Writer out = new BufferedWriter(new FileWriter(file));</span><br><span class="line">    out.write(message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在自己的类中利用不可变性</li></ul><blockquote><p>要使一个对象不可变，只要将其所有字段声明为 private 和 final ，而且不要编写任何能改变他们的方法。  ——《Java网络编程》</p></blockquote><ul><li>将非线程安全的类用作为线程安全类的一个私有字段</li></ul><blockquote><p>只要包含类只以线程安全的方式访问这个非安全类，而且只要永远不让这个私有字段的引用泄露到另一个对象中，那么这个类就是安全的。                  ——《Java网络编程》</p></blockquote><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p>上面说同步可能会导致一个问题：死锁。如果两个线程需要独占访问相同的资源集，而每个线程又分别有这些资源的不同子集的锁，就会发生死锁。这就好像大黄和小黄都要写毕设，他们都需要两本书《Java编程思想》和《前端开发》，而大黄借到了一本，小黄借到了第二本，同时他们有都不愿意放弃自己借到的书，那么都将无法完成毕设。这就是死锁问题。</p><blockquote><p>糟糕的是死锁可能是偶发性 bug ,很难检测。死锁通常取决于不可预知的时间问题。(作者的意思是无法提前判断这个bug)     ——《Java网络编程》</p></blockquote><p>要防止死锁，最重要的技术就是要避免不必要的同步。同步应当是确保线程安全的最后一道防线，如果必须要同步，要保持同步块尽可能小，而且尽量不要一次同步多个对象。</p><h2 id="线程调度"><a href="#线程调度" class="headerlink" title="线程调度"></a>线程调度</h2><p>当多个线程可以同时运行时，必须考虑线程调度问题。<strong>要确保所有重要线程至少得到一些时间来运行，更重要的线程要得到更多的时间</strong>。同时你还要保证线程以合理的顺序执行。</p><h3 id="线程优先级"><a href="#线程优先级" class="headerlink" title="线程优先级"></a>线程优先级</h3><p>不是每个线程创建时都可以均等的。每个线程都是有一个优先级，指定为一个从0到10的整数。在Java中，10是最高优先级，0是最低优先级。</p><p>在Thread类中指定了三个命名常量（1、5和10）分别代表三和优先级</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public final static int MIN_PRIORITY = 1;</span><br><span class="line">public final static int NORM_PRIORITY = 5;</span><br><span class="line">public final static int MAX_PRIORITY = 10;</span><br></pre></td></tr></table></figure><p>线程的优先级可以用 Thread.setPriority()方法来改变</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">PrintThread printThread = new PrintThread(name);</span><br><span class="line">//设置该线程优先级为8</span><br><span class="line">printThread.setPriority(8);</span><br><span class="line">printThread.start();</span><br></pre></td></tr></table></figure><blockquote><p>在优先级的设置上，与用户交互的线程应当获得非常高的优先级，这样就能感觉到响应非常快。另一方面，在后台完成计算的线程应当获得低优先级。很快技术的任务应当有高优先级，将花费很长时间的任务应当有低优先级，这样就不会妨碍其他任务。——《Java网络编程》</p></blockquote><p><em>不过一般情况下要避免对线程实用太高优先级，因为这要冒一定风险，可能使其他低优先级线程陷入饥饿</em>。</p><h2 id="抢占"><a href="#抢占" class="headerlink" title="抢占"></a>抢占</h2><p>每个虚拟机都有自己的线程调度器，确定在给定的时刻运行那个线程。线程的调度主要有两种:抢占式和协作式。抢占式线程调度器确定一个线程正常的轮到其cpu时间，会暂停这个线程，将cpu控制权交给另一个线程。协作式线程调度器再将CPU控制权交给其他线程前，会等待正在运行的线程自己暂停。</p><p><img src="http://p0bl99g4r.bkt.clouddn.com/se_thread.png" alt=""></p><p>由此可见，抢占式线程不会像协作式线程那样容易陷入饥饿，协作式线程会让高级的线程独占cpu。<strong>因此所有Java虚拟机都确保在不同优先级之间使用抢占式线程调度</strong>。</p><blockquote><p>当一个低优先级线程正在运行，而一个高优先级线程准备运行时，虚拟机或早或晚会暂停这个低优先级进程，让高优先级进程运行。高优先级进程就抢占了低优先级进程。             ——《Java网络编程》</p></blockquote><h3 id="暂停线程"><a href="#暂停线程" class="headerlink" title="暂停线程"></a>暂停线程</h3><p>Java虚拟机使用抢占式来调度线程，让当前线程暂停，使其他线程有机会运行。那么如何具体暂停线程呢？大概有下面方法可以暂停线程或指示他准备暂停。</p><ul><li>对 I/O 阻塞</li></ul><p>当线程必须停下来等待他没有的资源的时候，就会发生阻塞。</p><p><em>阻塞：当等待一个未到的资源时，程序会暂停，下面的代码不会执行，直到资源到达。</em></p><blockquote><p>要让网络程序中的线程自动放弃CPU控制权，最常见的方式是对I/O的阻塞。    ——《Java网络编程》</p></blockquote><p>很好理解的，比如当前线程要使用流读取一个文件时，在读取文件的那几毫秒就发生了阻塞，可偏偏就是这几毫秒就够其他线程完成一些重要任务。</p><ul><li>对同步对象阻塞</li></ul><p>线程在进入一个同步方法或代码块时也会阻塞。如果这个线程没有所同步对象的锁，而其他线程拥有这个锁，这个线程就会暂停,直到锁被释放。</p><p><em>无论是I/O阻塞还是堆锁阻塞，都不会释放线程已经拥有的锁。</em></p><ul><li>放弃</li></ul><p>要让线程显示的放弃控制权，线程可以通过调用 Thread.yeled() 静态方法。这将通知虚拟机，如果有另一个线程准备就绪，可以运行该线程。<strong>放弃不会释放这个线程拥有的锁，</strong> 因此在线程放弃时，不应该做任何同步。</p><blockquote><p>一个线程放弃时，如果等待运行的其他线程都是因为这个线程的所拥有的同步资源而阻塞，那么这些线程将不能运行。       ——《Java网络编程》</p></blockquote><p>在实际中让一个线程放弃非常简单。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public void run()&#123;</span><br><span class="line">  //完成线程的工作</span><br><span class="line">  Thread.yield();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意的是：放弃只会使其他有相同优先级的线程有机会运行！！所以在没有必要放弃的情况下，这种防范措施效果不太明显。</p><ul><li>休眠</li></ul><p>休眠是更有力的放弃方式。放弃只是表示线程愿意暂停，其他相同优先级的线程有机会运行。而进入休眠的线程，不管有没有其他线程准备运行，休眠线程都会暂停。这样，不只是其他有相同优先级的线程的大机会，还会给更低优先级线程运行的机会。<strong>进入休眠的线程依然拥有这个线程的锁，</strong> 因此要避免在同步方法或块内让线程休眠。使用静态方法 Thread.sleep(),让线程休眠，在该方法中传入想让线程休眠的时间。</p><p>使让一个线程休眠也非常简单。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public void run()&#123;</span><br><span class="line">   while(true)&#123;</span><br><span class="line">    //完成线程工作</span><br><span class="line">    try&#123;</span><br><span class="line">      //休眠5分钟</span><br><span class="line">      Thread.sleep(300000);</span><br><span class="line">    //如果其他线程唤醒该线程，该线程会抛出InterruptedException  </span><br><span class="line">    &#125;catch(InterruptedException)</span><br><span class="line">     break;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>向人一样，线程可以休眠，就可以被唤醒。如果在线程休眠时间内想让该线程提前继续运行，可以调用该线程的 interrup()方法将该线程唤醒。</p><p><em>一个线程休眠并不意味着其他醒着的线程不能处理这个相应线程的Thread对象，当另一个线程唤醒休眠线程后，会让休眠中的线程得到一个InterruptedException异常。休眠线程会被唤醒并并正常执行。</em></p><ul><li>连接线程</li></ul><p>可以通过 Thread 对象的 join()方法，join()方法允许一个线程再继续执行之前等待另一个线程结束。但是该方法已经不常用。略过。</p><ul><li>等待一个对象</li></ul><p>线程可以等待一个它锁定的对象。在等待时，它会释放这个对象的锁并暂停，直到他得到其他线程的通知。另一个线程以某种方式修改这个对象，通知等待对象的线程，然后继续执行。并不要求等待线程等待线程和通知线程在另一个线程继续前必须结束。</p><blockquote><p>这个方式并不太出名，因为他并不涉及Thread类的任何方法。实际上，要等待某个特定的对象，希望暂停的线程首先必须使用synchronized获得这个对象的锁，然后调用是重载的 wait()方法。  ——《Java网络编程》</p></blockquote><p> 上面说的三个wait方法在 java.lang.Object中，也就是说任何类的任何对象都可以调用这个方法。当对象调用wait()方法时，调用该对象的线程会释放掉等待该对象的锁（但不是释放等待其他对象的锁），并进入休眠。线程会保持休眠直到：<br> 1）时间到期 : 即 wait() 方法中时间参数到期，该进程会唤醒，线程会紧挨着wait()调用之后向下继续执行。<br> 2）线程被中断 ： 与 sleep() 工作方式相同，当其他线程调用这个线程额interrup()方法，将该进程手动唤醒。<br> 3) 对象得到通知 : 这是个新方法。在其他线程在这个线程所等待的对象上调用notify()或notifyAll()方法时，就会发生通知，这两个方法都在java.lang.Object中。</p><blockquote><p>这两个方法都必须在线程所等待的对象上调用，而不是在Thread本身调用。再通知一个对象之前，线程必须首先使用同步方法或同步块获得这个对象的锁。 notify() 会随机通知一个正在的等待该对象的线程，并唤醒它。notifyAll()唤醒等待指定对象的每一个线程。一旦线程得到通知，它就会试图重新获得所等待对象的锁。成功就继续顺着wait()向下执行，失败，他就会陷入阻塞，知道可以得到锁。——《Java网络编程》</p></blockquote><p> <em>当多线程希望可以等待同一个对象时，等待和通知会更常用。</em></p><ul><li><p>结束</p><p>最后一个让线程暂停的方式，就是结束。即 run()方法结束。</p></li></ul><h2 id="线程池和Executor"><a href="#线程池和Executor" class="headerlink" title="线程池和Executor"></a>线程池和Executor</h2><p>想程序中添加多个线程会极大的提升性能，尤其是I/O首先程序，比如大多数网络程序。但是，线程自身也存在开销。线程需要虚拟机做大量工作，最后，虽然线程有利于更高效利用计算机有限CPU资源，但是资源毕竟是有限的！</p><blockquote><p>如果并发线程数达到 4000 至 20000 时，大多数虚拟机可嗯呢过会由于内存耗尽而无法承受。不故意通过使用线程池而不是为每个连接生成新线程，服务器每分钟就可以用不到100个线程来处理数千个短连接。 ——《Java网络编程》</p></blockquote><p>由此可见，线程池的使用场景一般是：<br>1）有大量 I/O 操作程序如网络程序。<br>2）每个线程的任务量很大，会消耗大量cpu资源。</p><p>遇到上面两种情况的多线程程序都可以考虑使用线程池。</p><ul><li>线程池的使用</li></ul><p>利用 java.lang.concurrent 中的Executors类(executor是执行的意思)，可以很容易的建立一个线程池。只需要将各个任务作为 Runnable 对象提交给这个线程池，你就会得到一个 Future 对象，可以用来检查任务进度。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">//一个Runnable</span><br><span class="line">public class FileRunnable implements Runnable&#123;</span><br><span class="line">    public void run()&#123;</span><br><span class="line">       ....</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class TestPool&#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">      //创建线程池，并设置线程数为 4</span><br><span class="line">      ExectorService pool = Exectors.newFixedThreadPool(4);</span><br><span class="line">      for(int i = 0;i&lt;args.length;i++)&#123;</span><br><span class="line">        FileRunnable task = new FileRunnable();</span><br><span class="line">        //将任务提交</span><br><span class="line">        pool.submit(task);</span><br><span class="line">      &#125;</span><br><span class="line">      pool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>shutdown()</li></ul><p>要说一下这个shutdown()方法，这个方法不是终止等待中的工作。他只是通知线程池已经更多的任务需要增加到它的内部队列了，而且一旦完成了所有等待工作，就应当关闭。像上面程序中，可以这样关闭是因为他有一个终点，即只处理args.lenth个任务，所以可以使用pool.shutdown()。</p><ul><li>shutdownNow()</li></ul><p>而在一些不知道确定任务终点的线程池，如果想在运行时终止线程池的任务。可以使用 shutdownNow() 方法 。该方法会终止线程池中正在执行的任务，并忽略所有等待任务。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pool.shutdownNow();</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>1.线程比进程轻量级，线程在进程中运行，共用一块内存、以及变量等资源。</p><p>2.你可以根据需要使用继承Thread类和实现Runnable接口作为参数传给Thread构造方法两种方案创建进程。</p><p>3.线程通过 Thread 对象的start()方法开启，线程的任务封装在 run()方法中。扩展Thread类时尽量只重写其run()方法，其他方法不要动。</p><p>4.若想从线程返回信息可以使用回调的方式。回调就是被调用线程调用主类(调用该线程的程序)中的方法，回调返回信息尽量在run()方法快执行完时返回。</p><p>5.使用Callable、Executors和Future也可以从线程返回信息，Callable 中的 call()方法可以返回任意类型，将 Callable 对象提交给 ExectorService 线程池可以执行该任务，并得到一个Future对象，该对象可以得到对应任务对象的 call()方法返回值。</p><p>6.同步是为了让线程中的共享对象（资源）可以得到保护的一种机制，即当一个线程操作共享对象（资源）时另一个线程不可以对该对象进行操作。同步的策略有同步块、同步方法、同步对象三种。在编写代码时要避免不必要的同步。</p><p>7.当两个线程都需要同一个资源集，但有都不愿意放弃各自手中的资源时，两个线程就会陷入等待程序无法正常运行，从而形成死锁。所以死锁可以理解为线程得不到需要的资源(被占用的资源)。要避免死锁解决方案还是要避免不必要的同步。</p><p>8.线程要按照一定的规则轮番运行，这个规则就是线程的优先级，多个线程同时运行时，虚拟机通常只运行优先级最高的。</p><p>9.线程优先级分为10各等级，Java 中 依次按 0 -10 优先级递增。使用 Thread 对象的setPriority(优先级)为线程设置优先级。 合理分配优先级，一般不要给一个线程过高的优先级，这会让优先级较低的线程陷入饥饿。</p><p>10.在虚拟机的线程调度器中，按照抢占式的线程调度对线程进行调度。抢占式调度在某线程到了运行是时间会暂停当前运行线程，将cpu控制权交给另外的线程。</p><p>11.Java中主要有四种让线程暂停，是其他线程获得运行机会的方式。</p><p>12.对I/O阻塞或对同步对象阻塞，这种可以算作是一种，他们都会在等待资源(文件、对象)陷入阻塞时让另外的线程得到运行的机会。对I/O阻塞或对同步对象阻塞都不会放弃已经拥有的锁，即对同步对象阻塞可能会引起死锁。</p><p>13.放弃，让线程放弃控制权。使用Thread.yield()方法，会通知虚拟机如果另一个优先级相同的线程准备就绪就可以运行。放弃也不会释放已经拥有的锁，所以在放弃时不应该做任何同步。</p><p>14.休眠，为更有力的方式。与放弃的区别是休眠可以让较低线程优先级的线程运行。使用Thread.sleep()方法使线程休眠，也还以设置休眠时间。休眠同样不会释放他的锁。</p><p>15.使用休眠线程对象的 interrupt() 方法可以唤醒休眠线程，被唤醒的线程会抛出一个InterruptedException 异常，所以在使用 sleep()方法时，如果要对该线程唤醒，就要捕获sleep()方法的InterruptedException。</p><p>16.等待对象，等待一个被锁的对象。任何同步对象都可以被等待。一个线程如果需要另一个线程对同步对象做一些改动，该线程会释放这个对象的锁并暂停，在改动之后该线程继续执行。值得一提的是等待对象的方法是在Object.wait()，这会让该线程暂停，而对该对象改动的线程可以使用 Object对象的notify()方法，通知等待线程等待结束，可以继续运行。</p><p>17.线程池可以减少过多线程对虚拟机性能的影响，在遇到过多I/O操作和每个线程的任务量很大，会消耗大量cpu资源的情况可以使用线程池。将 Runnable 对象提交给Executors 会得到 Future　对象用来获得线程执行结果。</p><p>18.Executors对象的shutdown()方法不是停止等待的任务，而是告诉连接池全部任务已提交完毕，当所有任务完成后就关闭连接池；shutdownNow()方法则是关闭所有目前进行的任务，并忽略所有等待的任务。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;线程&quot;&gt;&lt;a href=&quot;#线程&quot; class=&quot;headerlink&quot; title=&quot;线程&quot;&gt;&lt;/a&gt;线程&lt;/h2&gt;&lt;p&gt;如果你穿越到三十年前，网络并不普及，在Internet只有几百万用户而不是现在的数十亿时，你会发现网站比现在的更加拥堵。这个问题在于，当时大
      
    
    </summary>
    
    
      <category term="JavaSE" scheme="http://yoursite.com/tags/JavaSE/"/>
    
  </entry>
  
  <entry>
    <title>散列</title>
    <link href="http://yoursite.com/2018/01/26/%E6%95%A3%E5%88%97/"/>
    <id>http://yoursite.com/2018/01/26/散列/</id>
    <published>2018-01-26T08:17:01.000Z</published>
    <updated>2018-02-01T07:15:04.125Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><p>散列 (hashing)是常见的数据结构之一。它是以常数平均时间执行插入、删除和查找的技术。而与排序有关操作——查找最大最小值、按大小顺序打印等操作不被支持。</p><h2 id="一些概念"><a href="#一些概念" class="headerlink" title="一些概念"></a>一些概念</h2><p>在 <a href="#概览">概览</a> 简单介揭开了散列的面纱。下面通过一些概念介绍散列。</p><h3 id="关键字-key"><a href="#关键字-key" class="headerlink" title="关键字(key)"></a>关键字(key)</h3><p>关键字的英文就是很常见的 key 。通常我们所说的查找，查找的是查找项的某一部分(即数据域)，而这一部分就叫做关键字(key)。</p><h3 id="散列"><a href="#散列" class="headerlink" title="散列"></a>散列</h3><p>散列(散列表)简单来说就是一个包含一些项的具有固定大小的数组。如果散列表的大小是 size,则让散列表从 0 到 size-1 变化。<strong>每个关键字被映射到从 0 到 size-1 这个范围中的某个数，并被放到合适的单元中</strong>，这个映射就叫做<a href="#散列函数">散列函数</a>。如下图就是一个散列表</p><p><img src="http://p0bl99g4r.bkt.clouddn.com/ds_hash.PNG" alt=""></p><p>在图中 tom 散列到 1 ，sim 散列到 2 ，mike 散列到 4 。</p><h3 id="冲突"><a href="#冲突" class="headerlink" title="冲突"></a>冲突</h3><p>散列在理想条件下，要保证任何两个不同关键字映射到不同的单元,(如上图中的散列表就是一个理想的散列表) 但是这是不可能的，因为<strong>单元数目是有限的，而关键字实际上是用不完的</strong>！如果两个关键字散列到同一个值时，这就出现了冲突！而当冲突出现时要做什么就是我们下面要研究的问题之一。</p><h3 id="装填因子"><a href="#装填因子" class="headerlink" title="装填因子"></a>装填因子</h3><p>装填因子 λ ，代表散列表中元素与表大小的比。</p><h2 id="散列函数"><a href="#散列函数" class="headerlink" title="散列函数"></a>散列函数</h2><p>散列函数单独拿出来作为一节内容，当然是因为它的重要性。不夸张的说正是因为散列函数，散列表这种数据结构才得以实现。散列函数要做的就是帮助关键字找到<strong>合适的单元</strong>存储。而这个合适单元一般就是指 0 到 size-1 这个范围中的某个数。</p><h3 id="合理的散列函数"><a href="#合理的散列函数" class="headerlink" title="合理的散列函数"></a>合理的散列函数</h3><h4 id="简单散列函数"><a href="#简单散列函数" class="headerlink" title="简单散列函数"></a>简单散列函数</h4><p>一般合理的散列函数是 key mod size 。若果关键字 key 是整数则直接返回 key mod size 即可，但如果 key 字符串，可以计算出该字符串每个字符的ASCⅡ码值加起来。实现如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">publlic static int hash(String hash,int size)&#123;</span><br><span class="line"></span><br><span class="line">    int hashVal = 0;</span><br><span class="line"></span><br><span class="line">    for(int i = 0; i &lt; size;i++ ) &#123;</span><br><span class="line">      hashVal += hash.cahrAt(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    retuen hashVal % size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="散列表大小-size-选取"><a href="#散列表大小-size-选取" class="headerlink" title="散列表大小(size)选取"></a>散列表大小(size)选取</h4><p>表的大小 size 的选取具有一定学问，为什么呢？例如表的大小是 10 ，而关键字都是十的倍数，则经过散列函数的映射取余后所有的关键字都会映射到 0 单元，这显然不合理。<strong>好的办法是散列表大小尽量是素数，这样的散列函数不仅计算起来简单而且关键字分配也较均匀</strong>。     </p><h4 id="好的散列函数"><a href="#好的散列函数" class="headerlink" title="好的散列函数"></a>好的散列函数</h4><p>什么是好的散列函数？无非就是要保证每个关键字均匀的分配在散列表的单元中，上面推荐了散列表大小尽量是素数这样的策略，但即使这样也还是有一定缺陷。考虑这样一种情况，假设每个关键字字符串均包含8个字符串，且表大小 size 为 10007(素数)。ASCⅡ字符的值最多为127，则8个字符表示最大的数为 8*127=1016,按照<a href="#简单散列函数">简单散列函数</a>的算法，所有字符串都会被映射在 0 和 1016 单元之间。显然这不是一个好的散列函数！<br>下面介绍一种好的散列函数,该函数利用到了 Horner 法则。这个函数就表的分布来说并不是最好的，但确实是简单高效的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">publlic static int hash(String hash,int size)&#123;</span><br><span class="line"></span><br><span class="line">    int hashVal = 0;</span><br><span class="line"></span><br><span class="line">    for(int i = 0; i &lt; hash.length(); i++ ) &#123;</span><br><span class="line">      hashVal =  37 * hashVal + keyn.cahrAt(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    hashVal %= size;</span><br><span class="line">    if(hashVal &lt; 0)</span><br><span class="line">      hashVal += size;</span><br><span class="line">    retuen hashVal % size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="解决冲突"><a href="#解决冲突" class="headerlink" title="解决冲突"></a>解决冲突</h2><p>如果当一个元素被插入时，与一个已经插入的元素散列到一个相同的单元，那么就产生一个冲突，这个冲突需要消除。解决冲突的方法有好几种介绍最简单的两种：分离链接法和开放定址法。</p><h3 id="分离链接法"><a href="#分离链接法" class="headerlink" title="分离链接法"></a>分离链接法</h3><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>分离链接法做法是<strong>将散列到同一个单元的所有元素保留到一个表中</strong>。</p><p><img src="http://p0bl99g4r.bkt.clouddn.com/ds_separate.PNG" alt=""></p><p>上图中(该图不是一个好的例子，表的大小没有被设计成素数)关键字 0,20,30 都被散列到 0 单元，产生了冲突，但将这几个冲突的关键字放置在同一个链表中就解决了冲突。这个结构直观感受起来比描述起来更简单对吧！</p><h4 id="查找过程"><a href="#查找过程" class="headerlink" title="查找过程"></a>查找过程</h4><p>使用分离链表法在进行查找时，需要使用散列函数确定关键字在哪个链表(即找到关键字对应所在单元)中，然后再被确定的链表中执行一次查找。</p><h4 id="插入过程"><a href="#插入过程" class="headerlink" title="插入过程"></a>插入过程</h4><p>插入过程同样需要散列函数找到该关键字应插入单元的链表，如该关键字是一个新元素，那他将被插入到链表的前端。</p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p>由上所述，分离链接法解决散列冲突，<strong>散列表需要存储一个链表数组，用链表数组的索引代表散列表的单元。前面提到的散列表的大小 size 就是该链表数组的规模</strong>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">public class SeparateChainingHashTable&lt;AnyType&gt; &#123;</span><br><span class="line">    //指定散列表默认大小</span><br><span class="line">    private static final int DEFAULT_TABLE_SIZE = 101;</span><br><span class="line">    //基于分离链表法实现，需要储存一个表的数组</span><br><span class="line">    private List&lt;AnyType&gt;[] theLists;</span><br><span class="line">    //当前散列表中插入关键字个数</span><br><span class="line">    private int currentSize;</span><br><span class="line">    //使用构造方法对 theLists 初始化</span><br><span class="line">    public SeparateChainingHashTable(int size) &#123;</span><br><span class="line">        theLists = new LinkedList[size];</span><br><span class="line">        for (int i = 0;i &lt; theLists.length;i++)&#123;</span><br><span class="line">            theLists[i] = new LinkedList&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public SeparateChainingHashTable() &#123;</span><br><span class="line">        this(DEFAULT_TABLE_SIZE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void makeEmpty()&#123;</span><br><span class="line">        for (int i = 0; i &lt; theLists.length; i++)&#123;</span><br><span class="line">            theLists[i].clear();</span><br><span class="line">        &#125;</span><br><span class="line">        currentSize = 0;</span><br><span class="line">    &#125;</span><br><span class="line">    //散列函数</span><br><span class="line">    private int myhash(AnyType x)&#123;</span><br><span class="line">        int hashVal = x.hashCode();</span><br><span class="line">        hashVal %= hashVal/theLists.length;</span><br><span class="line">        if (hashVal &lt; 0)&#123;</span><br><span class="line">            hashVal += theLists.length;</span><br><span class="line">        &#125;</span><br><span class="line">        return hashVal;</span><br><span class="line">    &#125;</span><br><span class="line">    //判断散列表中是否包含某关键字</span><br><span class="line">    public boolean contains(AnyType x)&#123;</span><br><span class="line">        List&lt;AnyType&gt; whichList = theLists[myhash(x)];</span><br><span class="line">        return whichList.contains(x);</span><br><span class="line">    &#125;</span><br><span class="line">    //插入过程</span><br><span class="line">    public void insert(AnyType x)&#123;</span><br><span class="line">        List&lt;AnyType&gt; whichList = theLists[myhash(x)];</span><br><span class="line">        if ( !whichList.contains(x))&#123;</span><br><span class="line">            whichList.add(x);</span><br><span class="line">             if (++currentSize &gt; theLists.length)</span><br><span class="line">                 rehash();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //删除关键字</span><br><span class="line">    public void remove(AnyType x)&#123;</span><br><span class="line">        List&lt;AnyType&gt; whichList = theLists[myhash(x)];</span><br><span class="line">        if ( whichList.contains(x))&#123;</span><br><span class="line">            whichList.remove(x);</span><br><span class="line">            currentSize--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void rehash() &#123;</span><br><span class="line">      //代码见下一节</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h4><p>分离链接法简单易懂。它的效率也很好计算，查找一次所需要的时间是计算散列函数所需要的常数时间和遍历链表所需时间。一般来说使用分离链接法的使用原则是预料的元素与表大小(链表数组长度)相等即 <a href="#装填因子">装填因子</a>λ ≈ 1，如果元素个数超过了表大小，则调用177行的rehash()方法，这个方法在<a href="#分离链接法的再散列函数">再散列小节</a>研究。分离链接法的缺点是使用了一些链表：给新单元分配地址需要时间，这使得算法速度有些慢，同时还要使用第二种数据结构实现(链表)，散列表本身就是一种数据结构。</p><h3 id="无链表的散列表"><a href="#无链表的散列表" class="headerlink" title="无链表的散列表"></a>无链表的散列表</h3><p>上面提到分离链接法的缺点就是用到了另一种数据结构——链表，不用链表解决冲突的方法是尝试将产生冲突的元素散列到另一些空的单元，也就说明所有的关键字都要放入散列表内，所以散列表的大小也要比分离链接法更大。一般来说对于不使用分离链接的散列表来说  <a href="#装填因子">装填因子</a>λ应该低于0.5，这样的表叫做探测散列表。探测列表通常有三种解决方案。</p><h4 id="冲突函数"><a href="#冲突函数" class="headerlink" title="冲突函数"></a>冲突函数</h4><p>探测散列表中，会使用冲突函数f(i) 解决冲突问题</p><h4 id="线性探测法"><a href="#线性探测法" class="headerlink" title="线性探测法"></a>线性探测法</h4><p>听起来有点高大上，不要害怕。跟住思路，线性探测法的散列公式(即关键字插入到散列表某个单元的公式) 是 h~i~(x) = hash(x) + f(i) 其中 f(i) = i 。不难理解公式中的 f(i) = i 是冲突函数，使用hash()找到关键字应该在的散列表中单元后，如果发生冲突则从该单元开始探测逐个单元，以查找出一个空单元。</p><p><img src="http://p0bl99g4r.bkt.clouddn.com/ds_probing_hash1.PNG" alt=""></p><p>上图这个例子中，基于<a href="#简单散列函数">简单散列函数</a>进行散列，我找了三个极端的例 0、11、22 他们对size(本例中为11)取余均为0。具体过程图片中以给出。简单来说线性探测法在遇到冲突时会一直向下寻找下一个(可以回绕)不冲突的单元。<br>线性探测的使用场景是预计的插入元素(关键字)要小于散列表的大小，否则线性探测的效率是很低的。<br>还有一个问题值得注意，0,11,22与10中间隔了一大片空白，使用线性探测会出现这种小范围聚集的现象，被称为一次聚集，使得散列表元素分配不够均匀。为了改善这种一次聚集现象，使用平方探测法解决冲突是一个很好的选择。</p><h4 id="平方探测法"><a href="#平方探测法" class="headerlink" title="平方探测法"></a>平方探测法</h4><p>平方探测是消除线性探测中一次聚集的冲突解决方法。平方探测是将 h~i~(x) = hash(x) + f(i) 中的 冲突函数 f(i) 为二次的方法。流行的选择是 f(i) = i^2^。</p><p><img src="http://p0bl99g4r.bkt.clouddn.com/ds_probing_hash2.PNG" alt=""></p><p>由上图所示，使用平方探测法解决冲突， 改善了一次聚集的情况，使散列表元素的分布更加均匀。</p><ul><li>平方探测定理</li></ul><blockquote><p>如果使用平方探测，且表的大小是素数，那么当表至少有一半至少是空时候，总能插入一个新元素。</p></blockquote><h5 id="平方探测法具体实现"><a href="#平方探测法具体实现" class="headerlink" title="平方探测法具体实现"></a>平方探测法具体实现</h5><ul><li>基本策略</li></ul><p>1.基于数组实现散列表结构，即关键字插入到该数组中。<br>2.删除元素时使用惰性删除，即将元素的 isActive 设为false</p><ul><li>实现代码</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line">public class QuadraticProbingHashTable&lt;AnyType&gt; &#123;</span><br><span class="line"></span><br><span class="line">    private static final int DEFAULT_TABLE_SIZE = 11;</span><br><span class="line">    private HashEntry&lt;AnyType&gt;[] array;</span><br><span class="line">    private int currentSize;</span><br><span class="line"></span><br><span class="line">    public QuadraticProbingHashTable() &#123;</span><br><span class="line">        this(DEFAULT_TABLE_SIZE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public QuadraticProbingHashTable(int size) &#123;</span><br><span class="line">        allocateArray(size);</span><br><span class="line">        makeEmpty();</span><br><span class="line">     &#125;</span><br><span class="line">     //置空散列表</span><br><span class="line">     public void makeEmpty()&#123;</span><br><span class="line">         currentSize = 0;</span><br><span class="line">         for (int i = 0;i &lt; array.length;i++)&#123;</span><br><span class="line">             array[i] = null;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     //初始化 HashEntry 数组</span><br><span class="line">    private void allocateArray(int arraySize)&#123;</span><br><span class="line">        array = new HashEntry[arraySize];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean contains(AnyType x)&#123;</span><br><span class="line">        int currentPos = findPos(x);</span><br><span class="line">        return isActive(currentPos);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //判断散列表中元素是否有意义</span><br><span class="line">    private boolean isActive(int currentPos) &#123;</span><br><span class="line">        return array[currentPos] != null &amp;&amp; array[currentPos].isActive;</span><br><span class="line">    &#125;</span><br><span class="line">    //探测函数，找到关键字应插入位置</span><br><span class="line">    public int findPos(AnyType x)&#123;</span><br><span class="line">        int offset = 1;</span><br><span class="line">        int currentPos = myhash(x);</span><br><span class="line">        while (array[currentPos] != null &amp;&amp; !array[currentPos].element.equals(x))&#123;</span><br><span class="line">            currentPos += offset;</span><br><span class="line">            offset += 2;</span><br><span class="line">            if (currentPos &gt;= array.length)&#123;</span><br><span class="line">                currentPos -= array.length;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return currentPos;</span><br><span class="line">    &#125;</span><br><span class="line">    //删除，这里是惰性删除</span><br><span class="line">    public void remove(AnyType x)&#123;</span><br><span class="line">        int currentPos = findPos(x);</span><br><span class="line">        if (isActive(currentPos))&#123;</span><br><span class="line">            array[currentPos].isActive = false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //将关键字插入散列表中</span><br><span class="line">    public void insert(AnyType x)&#123;</span><br><span class="line">        //找到插入单元</span><br><span class="line">        int currentPos = findPos(x);</span><br><span class="line">        //如果x已存在与散列表则什么也不做</span><br><span class="line">        if (isActive(currentPos))&#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        array[currentPos] = new HashEntry&lt;AnyType&gt;(x,true);</span><br><span class="line">        if (currentSize &gt; array.length/2)&#123;</span><br><span class="line">            rehash();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void rehash() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    private int myhash(AnyType x)&#123;</span><br><span class="line">        int hashVal = x.hashCode();</span><br><span class="line">        hashVal %= array.length;</span><br><span class="line">        if (hashVal &lt; 0)&#123;</span><br><span class="line">            hashVal += array.length;</span><br><span class="line">        &#125;</span><br><span class="line">        return hashVal;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //嵌套类，isActive属性判断元素在散列表中是否存在于散列表</span><br><span class="line">    private static class HashEntry&lt;AnyType&gt;&#123;</span><br><span class="line"></span><br><span class="line">        public AnyType element;</span><br><span class="line">        public boolean isActive;</span><br><span class="line">        public  HashEntry(AnyType e)&#123;</span><br><span class="line">            this(e,true);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public HashEntry(AnyType e,boolean i)&#123;</span><br><span class="line">            element = e;</span><br><span class="line">            isActive = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>值得一提的是　findPos 方法，这个方法用于探测到元素应该插入的位置，你可能会奇怪并没有看到平方，实际上平方探测法就是为了使元素之间具有一段距离，通过 offset+2 也可以达到一样的效果，并且由于没有使用乘法，它探测的速度更快！同样rehash方法也在<a href="#探测列表法的在散列函数">再散列小节</a>研究</p><h2 id="再散列"><a href="#再散列" class="headerlink" title="再散列"></a>再散列</h2><p>再散列 rehash 可以说是一个过程。例如，如果使用平方探测法，散列表中元素添加超过一半的单元，那么插入和查找的效率就很慢(对于分离链接法来说是插入元素等于单元个数时)，<strong>解决办法是建一个两倍大小的表，并扫描整个原始散列表，计算每个未删除元素的的新散列值并插入到新表中</strong>。也就是要达到下图的效果</p><p><img src="http://p0bl99g4r.bkt.clouddn.com/ds_reshash.PNG" alt=""></p><p>rehash 之后表的长度是 2*原表长 后的第一个素数。</p><h3 id="分离链接法的再散列函数"><a href="#分离链接法的再散列函数" class="headerlink" title="分离链接法的再散列函数"></a>分离链接法的再散列函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">private void rehash() &#123;</span><br><span class="line"></span><br><span class="line">       List&lt;AnyType&gt;[] oldLists = theLists;</span><br><span class="line">       theLists = new List[2*theLists.length];</span><br><span class="line">       for (int i = 0; i &lt; theLists.length;i++)&#123;</span><br><span class="line">           theLists[i] = new LinkedList&lt;&gt;();</span><br><span class="line">       &#125;</span><br><span class="line">       currentSize = 0;</span><br><span class="line">       for (int j = 0; j &lt; oldLists.length; j++)&#123;</span><br><span class="line">           for (AnyType item:oldLists[j])&#123;</span><br><span class="line">               insert(item);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="探测列表法的在散列函数"><a href="#探测列表法的在散列函数" class="headerlink" title="探测列表法的在散列函数"></a>探测列表法的在散列函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">private void rehash() &#123;</span><br><span class="line">      HashEntry&lt;AnyType&gt; [] oldArray = array;</span><br><span class="line">      allocateArray(2*array.length);</span><br><span class="line">      currentSize = 0;</span><br><span class="line">      for (int i = 0; i &lt; oldArray.length;i++)&#123;</span><br><span class="line">          if (oldArray[i] != null &amp;&amp; oldArray[i].isActive)&#123;</span><br><span class="line">              insert(oldArray[i].element);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="Java-标准库中的散列表"><a href="#Java-标准库中的散列表" class="headerlink" title="Java 标准库中的散列表"></a>Java 标准库中的散列表</h2><p>Java标准库包括 Set 和 Map 的散列表实现，即 HashSet 和 HashMap。在 HashSet 中的项必须提供 equals 方法 和 hashCode 方法。HashSet 和 HashMap 通常是使用分离链接散列实现的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概览&quot;&gt;&lt;a href=&quot;#概览&quot; class=&quot;headerlink&quot; title=&quot;概览&quot;&gt;&lt;/a&gt;概览&lt;/h2&gt;&lt;p&gt;散列 (hashing)是常见的数据结构之一。它是以常数平均时间执行插入、删除和查找的技术。而与排序有关操作——查找最大最小值、按大小顺序打
      
    
    </summary>
    
    
      <category term="数据结构 Data Structures" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-Data-Structures/"/>
    
  </entry>
  
  <entry>
    <title>别了，2017</title>
    <link href="http://yoursite.com/2018/01/01/happy-new-year/"/>
    <id>http://yoursite.com/2018/01/01/happy-new-year/</id>
    <published>2018-01-01T08:26:30.000Z</published>
    <updated>2018-01-01T13:57:08.329Z</updated>
    
    <content type="html"><![CDATA[<h1 id="别了，2017"><a href="#别了，2017" class="headerlink" title="别了，2017"></a>别了，2017</h1><p>　今儿元旦。不管舍不舍得吧，2017年就这么过去了。本心是想写点什么不一样的，在这么盯着屏幕看估计再有一会就睡着了，所以随便写写吧，正好憋着一泡尿。<br>　上网查2017年的大事件合集，这些事件中竟然没有我的名字，我想一定是写错了，后来一想有我名字才写错了。大事没邀请我参与，但一年之中总有些事儿值得记录。我比较喜欢先苦后甜的方式。<br>　先说说遗憾，最遗憾的事情就是亲人的离去，太奶在92岁这年走了。活这么大岁数去了在外人看来挺正常的，遗憾的就是她活的太久深深的刻在我们每个人的记忆里，我时常回想起她，想起跟她躺在她的小床上我问她以前的事，日本鬼子是啥样的，老家是啥样的…想起她九十岁还给我摊鸡蛋，虽然糊了哈哈哈，想起小时候我说她活不到我考大学那天她生气的样子…我跟她是隔了三代的人，给我的感觉却如同奶奶一样，她对每个人都太好了。再说说伤心吧，当然不是失恋，让我最伤心的是我科目二考试第三次挂了，在考场半个月晒得猴子一样，结果又挂了，这是我大学的噩梦，缓了好久。不找理由了，这只是漫长生活中的小小挫折，我是不会放弃的，我一定会回来的（ＴＴ）！ 再来是有成就感的事情，跟朋友一起合作了一个完整项目(这个完整很重要)，写了两个月，一起加班，一起讨论，一起改bug,并不是项目有多完美，而是这次经历让我成长。所以真的要好好感谢上帝，同时也要感谢小伙伴可以容忍我很多愚蠢的失误。如果你看这篇博客的话，谢谢啦！想起来很开心的事情，找到了一个每天在微信上闲唠嗑的人，虽然很多时候跟不上她/他的节奏，有时候还睡着了，你如果看这篇博客的话，我真的非常开心跟你唠嗑！欣慰的事，大概就是走这么远还有这么多朋友，和几个老朋友在2017年还那么铁，最铁的当然是田新猪，啥都跟我比比。身边这些朋友秀一下名单反正他们也不会看：兆旭、丞相、祥瑞、老爷、坤哥、查哥、黄猪、陈建、阿桑、吾孜等等吧，感谢上帝把你们这些天使送到我身边。满足的事情，前段时间跟高中同学聊天得知他父母和爷爷奶奶在他上大学这几年相继离开了，他说完之后我震惊的五秒钟没说出话，下一刻想起当爸妈不再年轻，父母健康是一件多么令人满足的事。<br>　写了一堆流水账，自己都不到写的是什么。我才不会说有什么后悔的事情，因为后悔没有用，一个哲人说过种一棵树最好的时间是十年前和现在。过去的就 let it go 吧。2018 还有好多事呢！收拾好行囊继续前进！最后真心祝所有看这篇博的人2018年不论是精神上还是物质上都有收获。我去尿尿了…</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;别了，2017&quot;&gt;&lt;a href=&quot;#别了，2017&quot; class=&quot;headerlink&quot; title=&quot;别了，2017&quot;&gt;&lt;/a&gt;别了，2017&lt;/h1&gt;&lt;p&gt;　今儿元旦。不管舍不舍得吧，2017年就这么过去了。本心是想写点什么不一样的，在这么盯着屏幕看估计再
      
    
    </summary>
    
    
      <category term="casual writing" scheme="http://yoursite.com/tags/casual-writing/"/>
    
  </entry>
  
  <entry>
    <title>二叉搜索树</title>
    <link href="http://yoursite.com/2017/12/29/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
    <id>http://yoursite.com/2017/12/29/二叉搜索树/</id>
    <published>2017-12-29T05:51:23.000Z</published>
    <updated>2018-01-12T07:09:14.400Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>对于大量输入的数据，链表的线性访问时间太慢了。树是一种简单的数据结构，其大部分操作运行时间平均为 O(log N)。(tree)树在计算机科学中是非常有用的抽象概念。博客要介绍的二叉查找树(brinary scarch tree)也是Java语言中两种类库集合类 TreeSet 和 TreeMap 的实现基础。Are you ready?</p><h2 id="开始之前"><a href="#开始之前" class="headerlink" title="开始之前"></a>开始之前</h2><p>在正式开始之前，我们应该做一些准备工作。比如树是什么？二叉树是什么？他们的特点又是啥？弄不清这些，那就会陷入一个”我是谁？我在那？我在干什么？”的尴尬境地。</p><h3 id="树"><a href="#树" class="headerlink" title="树"></a>树</h3><p>这里说的树当然不是大树的意思，树在计算机科学中就是一种数据结构，将它的抽象结构画出来很想一棵倒过来的树。树的应用也是很广泛，比如你电脑操作系统的文件系统等等balabala。</p><h4 id="树的概念"><a href="#树的概念" class="headerlink" title="树的概念"></a>树的概念</h4><p>引用书上的话</p><blockquote><p>一棵树是一些节点的集合。这个集合可以是空集；若不是空集，则树由称作根的节点root以及 0个或多个非空的子树 T1，T2,T3，…Tn组成，这些子树的每个根都被来自根 root 的一条有向边所连接。<br>每一棵子树的根叫做root的儿子(child),而 root 是每一棵子树的父亲(parent)。</p></blockquote><p>这段像绕口令的官方解释，翻译成普通话就是，树是由一个根节点和一堆子树组成的，注意这些子树也是树，也就是说<strong>树是可以通过递归来定义的</strong>。如下图就是利用递归定义的树</p><p><img src="http://p0bl99g4r.bkt.clouddn.com/ds_tree.PNG" alt="树的定义"></p><p>一棵树是 N 个节点和 N-1 条边的集合(要不信自己画一个)，其中的一个节点叫做根，除了根以外每个节点都会有一条边连接该节点的父亲，所以一棵树就有 N-1 条边！</p><h4 id="树的特点"><a href="#树的特点" class="headerlink" title="树的特点"></a>树的特点</h4><p>通过下面这张图告诉你树的特点</p><p><img src="http://p0bl99g4r.bkt.clouddn.com/ds_treenode.PNG" alt="树的节点"></p><p>1.每个节点可以有任意个儿子。<br>2.没有儿子的节点叫他叶子节点（或树叶或终端节点），如 B、F、H、J、K、L、M。<br>3.具有相同父亲的节点为兄弟(siblings)，B、C、D、E、F 就互为兄弟。<br>4.一棵树中从根到每个节点恰好存在一条路径。<br>5.对任意节点，该节点的深度(depth)等于从根开始的层次数，如 H 在树的第三层，深度为3，以此类推。<br>6.由 特点5 ，根的深度为1.<br>7.树中最大层次成为树的深度或高度。<br>8.节点有几个子节点，称之为该节点的度，树叶节点的度为 0。如 G 的度为 3。</p><h4 id="树的实现"><a href="#树的实现" class="headerlink" title="树的实现"></a>树的实现</h4><p>那么如何用 Java 语言来实现一棵树呢？根据概念，树是由节点和边的集合。很容易想到类似链表的写法，定义一个节点类，其中包含对其孩子节点的引用(指针)，可是问题来了：不同于链表知道每个节点后面只连接一个next节点,树的儿子结点是任意未知的，怎么破？ <strong>由于每个节点的儿子树可以变化很大并且实现不知道，因此在数据结构中建立到各个儿子结点的直接连接是不可行的，因为这样会长生太多浪费的空间</strong>。<br>实际上解决方法很简单：利用上面提到的兄弟节点概念，在每个节点中仅包含两个链接，其中一个链接该节点的第一个儿子，另一个链接当前节点的兄弟节点。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class TreeNode&#123;</span><br><span class="line">  //数据域</span><br><span class="line">  Object element;</span><br><span class="line">  //第一个儿子的引用</span><br><span class="line">  TreeNode firstChild;</span><br><span class="line">  //兄弟的引用</span><br><span class="line">  TreeNode nextSiblings</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><h4 id="二叉树的概念"><a href="#二叉树的概念" class="headerlink" title="二叉树的概念"></a>二叉树的概念</h4><p>首先二叉树(binary tree)是一棵树，特点是每个节点都不能有多于两个的儿子。下图是一颗由根和两个子树组成的二叉树，任意子树均可以为空</p><p><img src="http://p0bl99g4r.bkt.clouddn.com/ds_binarytree.PNG" alt="二叉树"></p><h4 id="二叉树的性质"><a href="#二叉树的性质" class="headerlink" title="二叉树的性质"></a>二叉树的性质</h4><p>以下图为例列举一些二叉树重要的性质</p><p><img src="http://p0bl99g4r.bkt.clouddn.com/ds_fullbinarytree.PNG" alt="满二叉树"></p><p>1.在二叉树的第 i (深度+1)层上至多有2<sup>i-1</sup>个节点 (i&gt;=1)。<br>2.深度为 k 的二叉树至多有 2<sup>k</sup>-1个节点(k&gt;=1)。<br>3.任意一棵二叉树 T，如果其终端节点数(叶子节点)为 n<sub>0</sub> ，度为 2 的节点数为 n<sub>2</sub> 则 n<sub>0</sub> = n<sub>2</sub> + 1。<br>4.一棵深度为 k 且有  2<sup>k</sup>-1 个节点的二叉树叫做满二叉树。<br>5.二叉树中的所有节点约定 从根节点起，自上而下，从左至右的排列叫做完全二叉树，如下图</p><p><img src="http://p0bl99g4r.bkt.clouddn.com/ds_completebinarytree.PNG" alt="完全二叉树"></p><p>下图则是非完全二叉树</p><p><img src="http://p0bl99g4r.bkt.clouddn.com/ds_uncompletebinarytree.PNG" alt="非完全二叉树"></p><p>6.满二叉树一定是完全二叉树，完全二叉树不一定是满二叉树。<br>7.具有n个节点的完全二叉树的深度为不大于 log<sub>2</sub>n+1 的整数。</p><h4 id="二叉树的实现"><a href="#二叉树的实现" class="headerlink" title="二叉树的实现"></a>二叉树的实现</h4><p>因为一个二叉树节点最多有两个子节点，所以可以直接在节点在类中保存直接连接到他们的链，有点类似于双端链表的声明,下面是二叉树节点代码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class BinaryNode&#123;</span><br><span class="line"></span><br><span class="line">  Object element;</span><br><span class="line">  //左孩子引用</span><br><span class="line">  BinaryTree leftChild;</span><br><span class="line">  //右孩子引用</span><br><span class="line">  BinaryTree rightChild;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里要注意的是，再画链表时习惯使用矩形表示数据域，并且用带有方向的直线连接，虽然二叉树的实现方式有双端链表类似但是习惯上用圆形便是数据，并且连接节点与孩子也不必表明方向，因为树和二叉树并不是线性结构。</p><h2 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h2><p>经过前面的长途跋涉，终于看到了今天的主角，二叉搜索树。经过上面的二叉树小节，已经对二叉树有了一个简要的了解。二叉搜索树从名字的定义显然是一种二叉树！</p><h3 id="二叉搜索树概念"><a href="#二叉搜索树概念" class="headerlink" title="二叉搜索树概念"></a>二叉搜索树概念</h3><p>按照国际惯例看一下二叉搜索树概念，<strong>二叉搜索树的一个重要应用是它们在查找中的使用</strong>。使二叉树成为二叉搜索树的性质是，对于二叉树中每个节点X，它的左子树中所有项的值都小于X中的项，而它的右子树中所有项的值都大于X中的项，如下图是以项的类型为整型为例。</p><p><img src="http://p0bl99g4r.bkt.clouddn.com/ds_binarysearchtree.PNG" alt="二叉搜索树"></p><p>根据二叉搜索树的概念，在二叉搜索树中每个节点的左子树中所有节点均比该节点项的值小。</p><h3 id="二叉搜索树实现"><a href="#二叉搜索树实现" class="headerlink" title="二叉搜索树实现"></a>二叉搜索树实现</h3><h4 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h4><p>由于二叉搜索树要求每个项(节点)都可以进行排序(就是项与项之间可以进行比较)，这是他在实现上区别于一般二叉树的地方。如何达到这个效果？你可能才想到了，利用 Comparable 这个接口。我的原则是利用 泛型+Comparable接口：<strong>泛型 AnyType 作为 每个节点数据项的类型，同时也需要是 Comparable 的子类型(即Comparable的实现)，这样项与项之间就可以通过 compareTo 进行比较</strong>。所以代码的大体框架是下面这个样子滴</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public class BinarySearchTree&lt;AnyType extends Comparable&lt;? super AnyType&gt;&gt;&#123;</span><br><span class="line"></span><br><span class="line">  //嵌套的节点类</span><br><span class="line">  private static class BinaryNode&lt;AnyType&gt;&#123;</span><br><span class="line">        //见嵌套节点类小节</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  //根节点引用</span><br><span class="line">  private BinaryNode&lt;AnyType&gt; root;</span><br><span class="line">  //令二叉搜索树为空</span><br><span class="line">  public void makeEmpty()&#123;//见二叉搜索树的初始化与置空小节&#125;;</span><br><span class="line">  //判断二叉树是否为空</span><br><span class="line">  public boolean isEmpty()&#123;//见二叉搜索树的初始化与置空小节&#125;;</span><br><span class="line">  //寻找二叉树中最小值</span><br><span class="line">  public AnyType findMin()&#123;//见最大值与最小值小节&#125;;</span><br><span class="line">  //寻找二叉树中最大值</span><br><span class="line">  public AnyType findMax()&#123;//见最大值与最小值小节&#125;;</span><br><span class="line">  //插入节点</span><br><span class="line">  public void insert(AnyType x)&#123;//见插入新数据小节&#125;</span><br><span class="line">  //删除节点</span><br><span class="line">  public void remove(AnyType x)&#123;//见删除操作小节&#125;</span><br><span class="line">  //判断树中是否包含某项</span><br><span class="line">  public boolean contains(AnyType x)&#123;//见查找是否包含某项小节&#125;</span><br><span class="line">  //打印树</span><br><span class="line">  public void printTree()&#123;//见树的遍历小节&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="嵌套节点类"><a href="#嵌套节点类" class="headerlink" title="嵌套节点类"></a>嵌套节点类</h4><p>由于二叉搜索树同样是二叉树，每个节点拥有数据项和左右两个儿子，所以节点类的代码是很简单的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">private static class BinaryNode&lt;AnyType&gt;&#123;</span><br><span class="line"></span><br><span class="line">    //数据项</span><br><span class="line">    AnyType elements;</span><br><span class="line">    //左孩子节点</span><br><span class="line">    BinaryNode&lt;AnyType&gt; left;</span><br><span class="line">    //右孩子节点</span><br><span class="line">    BinaryNode&lt;AnyType&gt; right;</span><br><span class="line"></span><br><span class="line">    BinaryNode(AnyType theElement, BinaryNode&lt;AnyType&gt; lt, BinaryNode&lt;AnyType&gt; rt)&#123;</span><br><span class="line">       elements = theElement;</span><br><span class="line">       left = lt;</span><br><span class="line">       right = rt;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    BinaryNode(AnyType theElement)&#123;</span><br><span class="line">       this(theElement,null,null);</span><br><span class="line">     &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="二叉搜索树的初始化与置空"><a href="#二叉搜索树的初始化与置空" class="headerlink" title="二叉搜索树的初始化与置空"></a>二叉搜索树的初始化与置空</h4><p>树结构是从根节点开始向下插入节点，一棵树只有一个根，所以任何一棵树的初始化与置空操作都是判断根节点是否为空。这就好像如果一个家族，根本没有祖先(生育他们的人)，那下面这些孩子是不可能存在的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//利用构造方法初始化</span><br><span class="line"> public BinarySearchTree()&#123;</span><br><span class="line">     root = null;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> //令二叉搜索树为空</span><br><span class="line"> public void makeEmpty()&#123;</span><br><span class="line">     root = null;</span><br><span class="line"> &#125;</span><br><span class="line"> //判断二叉树是否为空</span><br><span class="line"> public boolean isEmpty()&#123;</span><br><span class="line">     return root == null;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h4 id="最大值与最小值"><a href="#最大值与最小值" class="headerlink" title="最大值与最小值"></a>最大值与最小值</h4><p>如果不是二叉搜索树，这个功能实现起来会异常麻烦并且毫无意义，而二叉搜索树作为存在大小规律的二叉树，最小值节点一定在根节点左子树中最左面的节点，最大值一定在根节点右子树中最右边的节点，掌握这个那就很好办了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">//寻找最大最小一定是从根节点开始寻找</span><br><span class="line"></span><br><span class="line">public AnyType findMin()&#123;</span><br><span class="line">       if (isEmpty())</span><br><span class="line">           throw new BufferUnderflowException();</span><br><span class="line">       return findMin(root).elements;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">public AnyType findMax()&#123;</span><br><span class="line">       if (isEmpty())</span><br><span class="line">           throw new BufferUnderflowException();</span><br><span class="line">       return findMax(root).elements;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">private BinaryNode&lt;AnyType&gt; findMin(BinaryNode&lt;AnyType&gt; t)&#123;</span><br><span class="line">         if (t != null)&#123;</span><br><span class="line">            //当左子树中的左节点的左节点为空那一定是最小的</span><br><span class="line">             while (t.left != null)&#123;</span><br><span class="line">                 t = t.left;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         return t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private BinaryNode&lt;AnyType&gt; findMax(BinaryNode&lt;AnyType&gt; t)&#123;</span><br><span class="line">        if (t != null)&#123;</span><br><span class="line">           //当右树中的左节点的右节点为空那一定是最大的</span><br><span class="line">            while (t.right != null)&#123;</span><br><span class="line">                t = t.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return t;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="查找是否包含某项"><a href="#查找是否包含某项" class="headerlink" title="查找是否包含某项"></a>查找是否包含某项</h4><p>由于二叉树并不是线性的表结构，所以这里所说的查找并不会把位置说出来，当输入一个数据项时会判断树中是否含有该数据。实现起来也很简单，从根节点比较传入的数据项，如果相等则找到该节点，如果传入数据较小则根节点一定在根节点的左子树中，以此类推，聪明的你一定会想到使用递归了吧~~</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//从根节点判断该二叉搜索树是否有节点的数据项与传入节点相同</span><br><span class="line">public boolean contains(AnyType x)&#123;</span><br><span class="line">       return contains(x,root);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">private boolean contains(AnyType x, BinaryNode&lt;AnyType&gt; t)&#123;</span><br><span class="line">       if (t == null)</span><br><span class="line">            return false;</span><br><span class="line">       int compareResult = x.compareTo(t.elements);</span><br><span class="line">       //如果传入数据比当前节点的数据小，则去当前节点的左孩子查找</span><br><span class="line">       if (compareResult &lt; 0)&#123;</span><br><span class="line">            return contains(x,t.left);</span><br><span class="line">        //如果传入数据比当前节点的数据大，则去当前节点的右孩子查找</span><br><span class="line">         &#125;else if (compareResult &gt; 0)&#123;</span><br><span class="line">             return contains(x,t.right);</span><br><span class="line">         &#125;else</span><br><span class="line">             return true;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><h4 id="插入新数据"><a href="#插入新数据" class="headerlink" title="插入新数据"></a>插入新数据</h4><p>二叉搜索树的插入实际上是最重要的了，原因就是我们上面所说的查找最小最大、查看是否包含、以及下面要提到的删除操作，都是基于插入操作正确插入的条件下，原因很简单上述操作我们会比较树中节点的大小，而这些节点一定要按照规则插入才行！而这个规则实际上就是二叉搜索树的定义呀，即每个节点的做儿子中的值比该节点值小，右儿子中的值比该节点值大！这里咱们约定一下，当插入树有已有数据时，不做插入即树中的个个节点的数据域是不同的。依然使用递归去实现。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">//从根节点开始插入</span><br><span class="line">public void insert(AnyType x)&#123;</span><br><span class="line">       root = insert(x,root);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">private BinaryNode&lt;AnyType&gt; insert(AnyType x,BinaryNode&lt;AnyType&gt; t)&#123;</span><br><span class="line"></span><br><span class="line">    if (t == null)&#123;</span><br><span class="line">        return new BinaryNode&lt;&gt;(x,null,null);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int compareResult = x.compareTo(t.elements);</span><br><span class="line">    //如果插入项比当前节点的数据域小，则递归调用插入该节点的左儿子节点</span><br><span class="line">    if (compareResult &lt; 0)&#123;</span><br><span class="line">        t.left = insert(x,t.left);</span><br><span class="line">    //如果插入项比当前节点的数据域大，则递归调用插入该节点的右儿子节点    </span><br><span class="line">    &#125;else if (compareResult &gt; 0 )</span><br><span class="line">        t.right = insert(x,t.right);</span><br><span class="line">    else</span><br><span class="line">        ;</span><br><span class="line">    return t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h4><p>删除操作可以说是整个二叉搜索树最复杂的地方了。原因是在我们删除一个节点后，我们还要保持删除后的二叉搜索树依然是一个二叉搜索树，有点像绕口令哈~~为了在删除后保持原状分为以下三种情况：<br>1.被删除的节点没有儿子节点，直接删除(变为null)</p><p><img src="http://p0bl99g4r.bkt.clouddn.com/ds_binarysearchdele1.PNG" alt=""></p><p>2.被删除的节点有一个儿子节点，用该儿子节点替代该节点位置</p><p><img src="http://p0bl99g4r.bkt.clouddn.com/ds_binarysearchdele2.PNG" alt=""></p><p>3.被删除节点有两个儿子节点，这是最麻烦的情况，咋办？别急有一个技巧，这种情况下我们只<strong>需要找到被删除节点右子树中最小节点，并将其数据项的值赋给要删除节点，再删除该最小节点即可</strong>。为什么？想一下被删除节点的右子树中所有节点一定都比被删除节点左子树的大，而右子树中最小数据项我们可以轻易的获取(通过 上面的findMin方法)！</p><p><img src="http://p0bl99g4r.bkt.clouddn.com/ds_binarysearchdele3.PNG" alt=""></p><p>下面是代码，依然使用递归实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public void remove(AnyType x)&#123;</span><br><span class="line">         remove(x,root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">//删除节点</span><br><span class="line">private BinaryNode&lt;AnyType&gt; remove(AnyType x,BinaryNode&lt;AnyType&gt; t)&#123;</span><br><span class="line"></span><br><span class="line">       if (t == null)&#123;</span><br><span class="line">           return t;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       int compareResult = x.compareTo(t.elements);</span><br><span class="line"></span><br><span class="line">       if ( compareResult &lt; 0)&#123;</span><br><span class="line">           remove(x,t.left);</span><br><span class="line">       &#125;else if( compareResult &gt; 0)&#123;</span><br><span class="line">           t.right = remove(x,t.right);</span><br><span class="line">       //要删除的节点有两个孩子</span><br><span class="line">       &#125;else if ( t.left != null &amp;&amp; t.right != null)&#123;</span><br><span class="line">           //使其右子树中最小的节点替代</span><br><span class="line">           t.elements = findMin(t.right).elements;</span><br><span class="line">           //删除该最小节点</span><br><span class="line">           t.right = remove(t.elements,t.right);</span><br><span class="line">       //要删除的节点只有一个孩子,则由该孩子替代</span><br><span class="line">       &#125;else &#123;</span><br><span class="line">           t = (t.left != null) ? t.left : t.right;</span><br><span class="line">       &#125;</span><br><span class="line">       return t;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="树的遍历"><a href="#树的遍历" class="headerlink" title="树的遍历"></a>树的遍历</h4><p>树的遍历有三种方法：<br>1.中序遍历，顺序为 左 -&gt; 根 -&gt; 右，以本节开头二叉搜索树图片为例，该树中序遍历顺序为 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 6 -&gt; 8<br>2.前序遍历，顺序为 根 -&gt; 左 -&gt; 右，以本节开头二叉搜索树图片为例，该树中序遍历顺序为 6 -&gt; 2 -&gt; 1 -&gt; 4 -&gt; 3 -&gt; 8<br>3.后序遍历，顺序为 左 -&gt; 右 -&gt; 根，以本节开头二叉搜索树图片为例，该树后序遍历顺序为 1 -&gt; 3 -&gt; 4 -&gt; 2 -&gt; 8 -&gt; 6</p><p>我使用的是中序遍历方法，依然使用递归的方式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">//打印树</span><br><span class="line">public void printTree()&#123;</span><br><span class="line">   printTree(root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//中序遍历</span><br><span class="line">private void printTree(BinaryNode&lt;AnyType&gt; t)&#123;</span><br><span class="line">      if (t != null &amp;&amp; t.elements != null)&#123;</span><br><span class="line">          printTree(t.left);</span><br><span class="line">          System.out.println(t.elements);</span><br><span class="line">          printTree(t.right );</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>你可能会发现，在二叉树的实现中用到了好多好多递归呀，插入、查找、删除、甚至遍历，没有错这就是二叉搜索树、树的特点，原因很简单我们将每个节点个和该节点的子树拿出来又是一颗树！这给了我们使用递归去定义二叉搜索树的机会，帮助我们更好的去理解树这种数据结构！完整代码见 <a href="https://github.com/DomBro96/datastructures/blob/master/src/main/java/cn/dombro/datastructures/tree/BinarySearchTree.java" target="_blank" rel="noopener">github</a>。</p><h3 id="二叉搜索树的效率"><a href="#二叉搜索树的效率" class="headerlink" title="二叉搜索树的效率"></a>二叉搜索树的效率</h3><p>上一节提到的二叉搜索树的增(insert)、查(contains)、删除(remove)操作的平均时间复杂度均为 O(log N)。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;对于大量输入的数据，链表的线性访问时间太慢了。树是一种简单的数据结构，其大部分操作运行时间平均为 O(log N)。(tree)树在计算机科
      
    
    </summary>
    
    
      <category term="数据结构 Data Structures" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-Data-Structures/"/>
    
  </entry>
  
  <entry>
    <title>栈及栈的应用</title>
    <link href="http://yoursite.com/2017/12/21/%E6%A0%88%E5%8F%8A%E6%A0%88%E7%9A%84%E5%BA%94%E7%94%A8/"/>
    <id>http://yoursite.com/2017/12/21/栈及栈的应用/</id>
    <published>2017-12-21T05:31:38.000Z</published>
    <updated>2017-12-23T03:24:54.143Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>数据结构是一个程序员的内功，只有内功基础打牢了，才可以决定你是否可以练就上乘的武功。今天来说一说栈结构。</p><h2 id="What"><a href="#What" class="headerlink" title="What"></a>What</h2><p>啥是栈(stack)结构？关于栈结构听过最多的就是后入先出的结构(LIFO,last in first out)。别说你不知道啊！</p><ul><li>栈的特点</li></ul><p>1.首先栈你要知道栈是一个表(线性结构)，因此任何实现表的方法都能实现栈。<br>2.栈是限制插入和删除只能在一个位置进行的表，该位置是表的末端，叫做栈顶(top)。<br>3.对栈的基本操作有push（进栈）和 pop（出栈），前者相当于插入，后者则是删除最后插入的元素。<br>4.由于第二点和第三点中说的，栈只在栈顶进行操作，所以出栈和入栈都是常数时间的操作。</p><h2 id="How"><a href="#How" class="headerlink" title="How"></a>How</h2><p>根据栈的特点中的第一条，栈是一个表，任何实现表的方法都能实现栈。那就分别用数组和链表的方式实现一下栈。</p><h3 id="栈的数组实现"><a href="#栈的数组实现" class="headerlink" title="栈的数组实现"></a>栈的数组实现</h3><p>由于栈<strong>只操作栈顶元素</strong>，如果用顺序存储的数组实现,又考虑后入先出的原则，很自然就会想到利用数组中最后一个元素的索引（这里叫他topOfStack） ！比如push操作，我们可以先让topOfStack++，然后再把push的元素赋值给数组的topOfStack索引。</p><p><img src="http://p0bl99g4r.bkt.clouddn.com/ds_arrstack.PNG" alt=""> </p><p>很好理解吧？因为栈这个结构本身就是一个很基础的结构呀！下面是具体的代码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">public class ArrayStack&lt;AnyType&gt; &#123;</span><br><span class="line"></span><br><span class="line">    //默认规模</span><br><span class="line">    private static final int DEFAULT_CAPACITY = 10;</span><br><span class="line">    //用数组实现栈</span><br><span class="line">    private AnyType[] theArray;</span><br><span class="line">    //记录栈的规模</span><br><span class="line">    private int theSize;</span><br><span class="line">    //记录栈顶元素位置</span><br><span class="line">    private int top0fStack;</span><br><span class="line">    //通过构造方法完成初始化</span><br><span class="line">    public ArrayStack()&#123;</span><br><span class="line">        doClear();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 入栈操作</span><br><span class="line">     * 1.栈顶元素索引 ++，并指向插入元素</span><br><span class="line">     * 2.栈规模 ++</span><br><span class="line">     */</span><br><span class="line">    public void push(AnyType item)&#123;</span><br><span class="line">        //判断栈是否已满</span><br><span class="line">        if(theSize == theArray.length)&#123;</span><br><span class="line">            ensureCapacity(theSize*2+1);</span><br><span class="line">        &#125;</span><br><span class="line">        top0fStack++;</span><br><span class="line">        theArray[top0fStack] = item;</span><br><span class="line">        theSize++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public AnyType peek()&#123;</span><br><span class="line">        if (size() == 0)&#123;</span><br><span class="line">            throw new EmptyStackException();</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            return theArray[theSize-1];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int size() &#123;</span><br><span class="line">        return theSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 出栈操作</span><br><span class="line">     * 1.栈规模 --</span><br><span class="line">     * 2.返回当前栈顶元素，栈顶元素索引--</span><br><span class="line">     */</span><br><span class="line">    public AnyType pop()&#123;</span><br><span class="line">        theSize--;</span><br><span class="line">        return theArray[top0fStack--];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    private void doClear()&#123;</span><br><span class="line">        theSize = 0;</span><br><span class="line">        top0fStack = -1;</span><br><span class="line">        ensureCapacity(DEFAULT_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //扩充栈规模</span><br><span class="line">    public void ensureCapacity(int newCapacity)&#123;</span><br><span class="line"></span><br><span class="line">        if (theSize &gt; newCapacity)</span><br><span class="line">            return;</span><br><span class="line">        //判断theArray有没有被初始化</span><br><span class="line">        if (theArray != null)&#123;</span><br><span class="line">            AnyType[] oldItems = theArray;</span><br><span class="line">            theArray = (AnyType[]) new Object[newCapacity];</span><br><span class="line">            for (int i = 0; i &lt; theSize; i++)&#123;</span><br><span class="line">                theArray[i] = oldItems[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            theArray = (AnyType[]) new Object[newCapacity];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean isEmpty()&#123;</span><br><span class="line">        return theSize == 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有意思的是，你会发现我在pop（出栈）操作时，并没有将栈顶元素删除掉而是利用了 topOfStack(栈顶元素在数组中的索引) 减一，让使用者无法访问刚刚出栈的元素，这是一种<strong>逻辑上的删除</strong>。</p><h3 id="栈的链表实现"><a href="#栈的链表实现" class="headerlink" title="栈的链表实现"></a>栈的链表实现</h3><p>用链表实现栈的好处是，我们不用担心数组越界，数组是否已满等等，要考虑后入先出，我们就要依赖于 topOfStack 节点的引用(注意，这里是节点！！)，首先topOfStack 节点的数据域被初始化为null,当进行push操作时 topOfStack 的后继为新插入的节点，而新插入节点的前驱则为当前 topOfStack ，最后将 topOfStack 引用指向刚刚插入的节点。什么？你蒙了？看图呀！</p><p><img src="http://p0bl99g4r.bkt.clouddn.com/ds_linstack.PNG" alt=""></p><p>也就是说topOfStack就是指向栈顶的引用！下面使代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 用链表实现的栈</span><br><span class="line"> */</span><br><span class="line">public class LinkedStack&lt;AnyType&gt; &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //栈规模</span><br><span class="line">    private int theSize;</span><br><span class="line"></span><br><span class="line">    //栈顶结点</span><br><span class="line">    private Node&lt;AnyType&gt; topOfStack;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     *入栈操作：</span><br><span class="line">     * 1.将栈顶结点作为插入节点的前驱</span><br><span class="line">     * 2.栈顶结点变为新插入节点</span><br><span class="line">     * 3.栈规模加一</span><br><span class="line">     */</span><br><span class="line">    public void push(AnyType item)&#123;</span><br><span class="line">        Node&lt;AnyType&gt; newNode = new Node&lt;AnyType&gt;(item,topOfStack);</span><br><span class="line">        topOfStack.next = newNode;</span><br><span class="line">        topOfStack = topOfStack.next;</span><br><span class="line">        theSize++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public AnyType peek()&#123;</span><br><span class="line">        return topOfStack.data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 出栈操作:</span><br><span class="line">     * 1.返回当前栈顶结点的数据域</span><br><span class="line">     * 2.栈顶结点的前驱作为栈顶结点</span><br><span class="line">     * 3.栈规模减一</span><br><span class="line">     *</span><br><span class="line">     */</span><br><span class="line">    public AnyType pop()&#123;</span><br><span class="line"></span><br><span class="line">        Node&lt;AnyType&gt; oldTop;</span><br><span class="line">        if (theSize &lt;= 0)&#123;</span><br><span class="line">            throw new IllegalStateException();</span><br><span class="line">        &#125;</span><br><span class="line">        oldTop = topOfStack;</span><br><span class="line">        topOfStack = topOfStack.prev;</span><br><span class="line">        theSize--;</span><br><span class="line">        return oldTop.data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public LinkedStack()&#123;</span><br><span class="line">        doClear();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 对栈进行初始化</span><br><span class="line">     */</span><br><span class="line">    private void doClear()&#123;</span><br><span class="line">        topOfStack = new Node&lt;AnyType&gt;(null,null);</span><br><span class="line">        theSize = 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    private static class Node&lt;AntType&gt;&#123;</span><br><span class="line"></span><br><span class="line">        public AntType data ;</span><br><span class="line">        public Node&lt;AntType&gt; next;</span><br><span class="line">        public Node&lt;AntType&gt; prev;</span><br><span class="line"></span><br><span class="line">        public Node(AntType data,Node&lt;AntType&gt; prev)&#123;</span><br><span class="line">            this.data = data;</span><br><span class="line">            this.prev = prev;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean isEmpty()&#123;</span><br><span class="line">        return theSize &lt;= 0;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总的来说无论用数组实现还使用链表实现都是各有优缺点的，比如用数组实现你就要考虑数组长度问题，而用链表如果你指针(引用)知识学的很屎，则容易出现大的bug ！但是一般来说使用数组方式实现是更流行的。</p><h2 id="When"><a href="#When" class="headerlink" title="When"></a>When</h2><p>是英雄总要有用武之地，栈是一个在计算机科学中很常用也很实用的数据结构。下面来介绍几个简单的应用。</p><h3 id="符号平衡"><a href="#符号平衡" class="headerlink" title="符号平衡"></a>符号平衡</h3><p>如果你是一个 Java 或 C++ 等程序员(不包括Python)，如果不用 IDEA 或 Eclipse　等IDE 让你在记事本上(或者是 vim 等编辑器，无所谓啦)写程序，你可能很不习惯，因为这些家伙都不能自动为你补齐 { &lt; ( [ 括号的 右半部分，而且也不会提示你没有输入右半部分的括号。那你有没有好奇那些编辑器是咋做到的，其实很简单！就是利用咱们的栈结构！因为在编程语言中右括号一定会匹配离该右括号最近的左括号，而最近的左括号一定是最后输入的。<br>遵循以下几点：<br>1.给定一段字符串，当遇到 左括号 { &lt; ( [ 时入栈。<br>2.当遇到右括号 ] ) &gt; } 时出栈，判断出栈符号与右括号是否匹配。<br>3.当字符串读取完毕，但是栈中还有左括号时，说明存在未输入的右括号。</p><p>下面是代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">  * 栈的平衡符号应用</span><br><span class="line">  * 1.若遇到 [,&#123;,(,&lt; 入栈</span><br><span class="line">  * 2.若遇到 ].&#125;,),&gt; 出栈</span><br><span class="line">  */</span><br><span class="line">public static void bracketCheck(String input)&#123;</span><br><span class="line">   ArrayStack&lt;Character&gt; stack = new ArrayStack();</span><br><span class="line"></span><br><span class="line">   for (int i = 0;i &lt; input.length();i++)&#123;</span><br><span class="line">      char inChar =  input.charAt(i);</span><br><span class="line">      switch (inChar)&#123;</span><br><span class="line">         case &apos;[&apos;:</span><br><span class="line">         case &apos;&#123;&apos;:</span><br><span class="line">         case &apos;(&apos;:</span><br><span class="line">         case &apos;&lt;&apos;:</span><br><span class="line">           stack.push(inChar);</span><br><span class="line">           break;</span><br><span class="line"></span><br><span class="line">         case &apos;]&apos;:</span><br><span class="line">         case &apos;&#125;&apos;:</span><br><span class="line">         case &apos;)&apos;:</span><br><span class="line">         case &apos;&gt;&apos;:</span><br><span class="line">           if (! stack.isEmpty())&#123;</span><br><span class="line">           char popChar = stack.pop();</span><br><span class="line">           if ((popChar == &apos;[&apos; &amp;&amp; inChar != &apos;]&apos;) || (popChar == &apos;&#123;&apos; &amp;&amp; inChar != &apos;&#125;&apos;) || (popChar == &apos;(&apos; &amp;&amp; inChar != &apos;)&apos;)|| (popChar == &apos;&lt;&apos; &amp;&amp; inChar != &apos;&gt;&apos;))&#123;</span><br><span class="line">             throw new RuntimeException(&quot;请确保有与&quot;+inChar+&quot;对应字符&quot;);</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;else &#123;</span><br><span class="line">               throw new RuntimeException(&quot;你并没输入左侧符号&quot;);</span><br><span class="line">             &#125;</span><br><span class="line">              break;</span><br><span class="line"></span><br><span class="line">            default:</span><br><span class="line">              break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (!stack.isEmpty())&#123;</span><br><span class="line">          throw new RuntimeException(&quot;你并没输入右侧符号&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="后缀表达式求值"><a href="#后缀表达式求值" class="headerlink" title="后缀表达式求值"></a>后缀表达式求值</h3><p>我们的计算机是很笨的，他只会从左往右去读，比如让他计算 1*3+4+2 它会算出结果是 9 但是 1+3+4*2 他一定给你算一个 16 。怎么办呢？聪明的计算机设计人员设计了一种后缀表达式 1+3+4*2  就变成 13+42*+ 。啥？你看不懂？后缀表达式就是把原本在两个数字中间的运算符号放置在<strong>要计算的两个数字后面</strong>。<strong>计算后缀表达式最简单的做法就是使用栈，并且不需要知道任何优先规则</strong>！</p><p>遵循以下几点：<br>1.当遇到一个数字进栈；<br>2.遇到第一个操作符时，该运算符就作用于栈中弹出的两个数上，再将所得结果压入栈中。</p><p>下面是代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * 后缀表达式求值</span><br><span class="line">     * 1.将数字依次压入栈中</span><br><span class="line">     * 2.当遇到操作符时将栈中两个数字出栈，将两数字与操作符的结果再次压入栈中</span><br><span class="line">     * 3.后缀表达式的好处是不用知道任何优先规则</span><br><span class="line">     * 4.按照规定位与位之间用 &quot; &quot; 相隔</span><br><span class="line">     */</span><br><span class="line">    public static int postFix(String input)&#123;</span><br><span class="line">        ArrayStack&lt;Integer&gt; stack = new ArrayStack();</span><br><span class="line">        String[] postFix =  input.split(&quot; &quot;);</span><br><span class="line">        for (int i = 0;i &lt; postFix.length; i++)&#123;</span><br><span class="line">            String card = postFix[i];</span><br><span class="line">            int topOfStack ;</span><br><span class="line">            int nextOfStack;</span><br><span class="line">            int result;</span><br><span class="line">            if (card.matches(&quot;[0-9]+&quot;))&#123;</span><br><span class="line">                 int number = Integer.parseInt(card);</span><br><span class="line">                 stack.push(number);</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                switch (card)&#123;</span><br><span class="line">                    case &quot;+&quot;:</span><br><span class="line">                        topOfStack = stack.pop();</span><br><span class="line">                        nextOfStack = stack.pop();</span><br><span class="line">                        result = topOfStack + nextOfStack;</span><br><span class="line">                        stack.push(result);</span><br><span class="line">                        break;</span><br><span class="line">                    case &quot;-&quot;:</span><br><span class="line">                        topOfStack = stack.pop();</span><br><span class="line">                        nextOfStack = stack.pop();</span><br><span class="line">                        result = nextOfStack - topOfStack  ;</span><br><span class="line">                        stack.push(result);</span><br><span class="line">                        break;</span><br><span class="line">                    case &quot;*&quot;:</span><br><span class="line">                        topOfStack = stack.pop();</span><br><span class="line">                        nextOfStack = stack.pop();</span><br><span class="line">                        result = nextOfStack * topOfStack  ;</span><br><span class="line">                        stack.push(result);</span><br><span class="line">                        break;</span><br><span class="line">                    case &quot;/&quot;:</span><br><span class="line">                        topOfStack = stack.pop();</span><br><span class="line">                        nextOfStack = stack.pop();</span><br><span class="line">                        result = nextOfStack / topOfStack  ;</span><br><span class="line">                        stack.push(result);</span><br><span class="line">                        break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return stack.pop();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="中缀表达式转后缀表达式"><a href="#中缀表达式转后缀表达式" class="headerlink" title="中缀表达式转后缀表达式"></a>中缀表达式转后缀表达式</h3><p>上面介绍了后缀表达式求值，可是要怎样将正常的中缀表达式转为后缀表达式呢？仅考虑中缀表达式中的符号有 + - * / () 。还要考虑这几个符号的运算优先级，咋办？用栈！<br>遵循以下几点：<br>1.当遇到数字直接输出。<br>2.遇到 ( 入栈。<br>3.遇到 +或- ：判断栈顶是否为*或/ ，若是则将 * 或 /出栈并输出，并将 +或 -入栈<br>4.遇到*或/ ：直接入栈。<br>5.遇到 ) : 将栈中一直到 ( 的字符出栈并输出，( 出栈并不输出。<br>6.读取字符串之后，将栈中字符出栈并输出。</p><p>下面是代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">    * 通过中缀表达式得到后缀表达式</span><br><span class="line">    * 1.使用栈放入操作符</span><br><span class="line">    * 2.操作符仅允许使用 + - * / ()</span><br><span class="line">    * 3.优先级  () 大于 * / 大于 + -</span><br><span class="line">    * 4.当 遇到优先级 更高的操作符时，当遇到数字便全部出栈</span><br><span class="line">    * 5.当 栈中有 ( 时，除非遇到 ) 否则 ( 不出栈</span><br><span class="line">    * 6.按照规定位与位之间用 &quot; &quot; 相隔</span><br><span class="line">    */</span><br><span class="line">   public static String getPostFix(String input)&#123;</span><br><span class="line">       ArrayStack&lt;String&gt; opStack = new ArrayStack&lt;&gt;();</span><br><span class="line"></span><br><span class="line">       String[] preFixArray = input.split(&quot; &quot;);</span><br><span class="line">       String suffix = &quot;&quot;;</span><br><span class="line">       for (int i = 0; i &lt; preFixArray.length; i++)&#123;</span><br><span class="line">           String current = preFixArray[i];</span><br><span class="line">           String temp ;</span><br><span class="line">           switch (current)&#123;</span><br><span class="line">               //遇到 ( 则入栈</span><br><span class="line">               case &quot;(&quot;:</span><br><span class="line">                   opStack.push(current);</span><br><span class="line">                   break;</span><br><span class="line">               case &quot;+&quot;:</span><br><span class="line">               case &quot;-&quot;:</span><br><span class="line">                   while (!opStack.isEmpty())&#123;</span><br><span class="line">                       temp = opStack.pop();</span><br><span class="line">                       //如果是栈顶是 ( 则直接将当前字符串入栈,不进行操作</span><br><span class="line">                       if (temp.equals(&quot;(&quot;))&#123;</span><br><span class="line">                           opStack.push(&quot;(&quot;);</span><br><span class="line">                           break;</span><br><span class="line">                       &#125;else &#123;</span><br><span class="line">                           suffix += &quot; &quot;+temp;</span><br><span class="line">                       &#125;</span><br><span class="line"></span><br><span class="line">                   &#125;</span><br><span class="line">                   opStack.push(current);</span><br><span class="line">                   suffix += &quot; &quot;;</span><br><span class="line">                   break;</span><br><span class="line">               case &quot;*&quot;:</span><br><span class="line">               case &quot;/&quot;:</span><br><span class="line">                   while (!opStack.isEmpty())&#123;</span><br><span class="line">                       temp = opStack.pop();</span><br><span class="line">                       if (temp.equals(&quot;(&quot;) || temp.equals(&quot;+&quot;) || temp.equals(&quot;-&quot;))&#123;</span><br><span class="line">                           opStack.push(temp);</span><br><span class="line">                           break;</span><br><span class="line">                       &#125;else &#123;</span><br><span class="line">                            suffix += &quot; &quot; + temp;</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">                   opStack.push(current);</span><br><span class="line">                   suffix += &quot; &quot;;</span><br><span class="line">                   break;</span><br><span class="line">               case &quot;)&quot;:</span><br><span class="line">                   while (!opStack.isEmpty())&#123;</span><br><span class="line">                       temp = opStack.pop();</span><br><span class="line">                       if (temp.equals(&quot;(&quot;))&#123;</span><br><span class="line">                           break;</span><br><span class="line">                       &#125;else &#123;</span><br><span class="line">                           suffix += &quot; &quot;+temp ;</span><br><span class="line"></span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">                   break;</span><br><span class="line">               default :</span><br><span class="line">                       suffix += current;</span><br><span class="line">                       break;</span><br><span class="line">            &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       while (!opStack.isEmpty())&#123;</span><br><span class="line">           suffix += &quot; &quot;+ opStack.pop();</span><br><span class="line">       &#125;</span><br><span class="line">       System.out.println();</span><br><span class="line"></span><br><span class="line">       return suffix;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><p>这就是栈的几个应用，你说他简单但是他却很重要。你会发现栈的应用一般都是用在要保存某种状态时的场景，比如网页浏览记录、回退等等。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;数据结构是一个程序员的内功，只有内功基础打牢了，才可以决定你是否可以练就上乘的武功。今天来说一说栈结构。&lt;/p&gt;
&lt;h2 id=&quot;What&quot;
      
    
    </summary>
    
    
      <category term="数据结构 Data Structures" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-Data-Structures/"/>
    
  </entry>
  
  <entry>
    <title>高级bash</title>
    <link href="http://yoursite.com/2017/12/12/%E9%AB%98%E7%BA%A7bash/"/>
    <id>http://yoursite.com/2017/12/12/高级bash/</id>
    <published>2017-12-12T01:12:24.000Z</published>
    <updated>2017-12-13T10:28:30.225Z</updated>
    
    <content type="html"><![CDATA[<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li><a href="#1">1. 数据流重定向</a><ul><li><a href="#1.1">1.1 what</a><ul><li><a href="#1.1.1">1.1.1 标准输出与错误输出</a></li><li><a href="#1.1.2">1.1.2 数据流重定向功能</a></li><li><a href="#1.1.3">1.1.3 标准输入</a></li></ul></li><li><a href="#1.2">1.2 why</a> </li></ul></li><li><a href="#2">2. 命令执行的判断依据 ;、&amp;&amp;、||</a><ul><li><a href="#2.1">2.1 ;</a></li><li><a href="#2.2">2.2 &amp;&amp;、||</a></li></ul></li><li><a href="#3">3. 管道命令</a><ul><li><a href="#3.1">3.1 what</a></li><li><a href="#3.2">3.2 一些管道命令</a><ul><li><a href="#3.2.1">3.2.1 选取命令：cut、grep</a></li><li><a href="#3.2.2">3.2.2 排序命令: sort、wc、uniq</a></li><li><a href="#3.2.3">3.2.3 双向重定向：tee</a></li><li><a href="#3.2.5">3.2.4 字符转换命令: tr、col、join、paste、expand</a></li></ul></li></ul></li></ul><h2 id="1">1. 数据流重定向</h2><p>重定向，英文 redirct。这个词程序员经常能遇到，大概意思就是给一个东西重新定位。而数据流重定向，大概就是将数据传导到其他地方去。</p><h3 id="1.1">1.1 what</h3><p>想知道啥叫数据流重定向，就要先了解一下命令执行结果。默认情况下，我们执行一个命令无论正确与否，命令执行结果(如果有的话)信息都会被打印到屏幕上。</p><h4>1.1.1 标准输出 &amp; 标准错误输出</h4><p>上面说到，默认情况下一个命令的执行结果都会被输出到屏幕上。<strong>输出的结果无非就是两种情况：命令回传的正确信息和命令回传的错误信息。这两种情况就分别对应 标准输出(standard output,简称stdout) 和 标准错误输出(standard error output,简称stderr)</strong>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dombro@ubuntu:~$ cat catfile &lt;== 使用 cat 将文件内容显示</span><br><span class="line">hello                        &lt;== 文件内容被打印出来，stdout</span><br><span class="line">just test for stin</span><br><span class="line">dombro@ubuntu:~$ cat cat11</span><br><span class="line">cat: cat11: No such file or directory  &lt;== 没有这个文件 stderr</span><br></pre></td></tr></table></figure><p>也就是说当你命令执行成功时输出的信息就是 stdout ，反之命令执行失败输出的信息就是 stderr 。<strong>不管正确与错误的数据都输出到屏幕上时很混乱的，如何将这两者分开就是数据流重定向的功能</strong>。</p><h4 id="1.1.2">1.1.2 数据流重定向功能</h4><p>数据流重定向可以将 stdout 和 stderr 分别传送到其他文件和设备中而不只是将其输出到屏幕上。而传送所需要的特殊字符如下</p><blockquote><p>1.标准输入(stdin) : 代码为 0，使用 &lt; 或 &lt;&lt; <br><br>2.标准输出(stdout) : 代码为 1，使用 &gt; 或 &gt;&gt; <br><br>3.标准错误输出(stderr) : 代码为 2，使用 2&gt; 或 2&gt;&gt;</p></blockquote><p>光说不练假把式，通过几个范例练习一下</p><ul><li>范例一：将系统根目录下(/) 各个文件信息记录到 ~/rootfile 中</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">dombro@ubuntu:~$ ll / &gt; ./rootfile &lt;== 神奇的是这是屏幕什么都不会输出</span><br><span class="line">dombro@ubuntu:~$ cat ./rootfile   &lt;== 使用 cat 查看一下，果然信息都写入了rootfile 中</span><br><span class="line">total 112</span><br><span class="line">drwxr-xr-x  25 root root  4096 Nov  5 09:47 ./</span><br><span class="line">drwxr-xr-x  25 root root  4096 Nov  5 09:47 ../</span><br><span class="line">...下面省略</span><br></pre></td></tr></table></figure><p>范例一中 ~/rootfile 的创建方式是：</p><blockquote><p>1.该文件若不存在系统自动将它创建<br><br>2.若文件已经存在，系统会先将这个文件清空，在将数据写入<br><br>3.综合上两点，若以 &gt; 输出到一个已存在的文件中，那这个文件就会被覆盖掉</p></blockquote><p><strong>如果想以累加的方式重定向，不删除旧数据，咋办？将 &gt; 改成 &gt;&gt; 就好了</strong>。上面说的标准输出代码为1,所以在 &gt; 和 &gt;&gt; 前面加上 数字1 ，1&gt;&gt;、1&gt;起到的效果是一样的。</p><p><strong>标准错误输出(stderr)的重定向和 stdout 使用方法是一样的，只不过标准错误输出的重定向字符为 2&gt; 和 2&gt;&gt;</strong>。</p><ul><li>范例二：利用一般用户账号使用 find 命令查找/home 下面是否有 .bashrc的文件存在</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">dombro@ubuntu:~$ find /home -name .bashrc</span><br><span class="line">/home/dongbo/.bashrc &lt;== stdout </span><br><span class="line">find: ‘/home/dongbo/.cache’: Permission denied &lt;== stderr 这里是错误输出，很明显 dombro 这个用户没有 /home/dongbo 这个目录的读取权限</span><br><span class="line">/home/user2/.bashrc  &lt;== stdout </span><br><span class="line">/home/user1/.bashrc  &lt;== stdout </span><br><span class="line">/home/dombro/.bashrc &lt;== stdout</span><br></pre></td></tr></table></figure><p>这个时候你可以使用 stdout 重定向 <code>find /home -name .bashrc &gt; list</code> 正确的输出数据会被写入到 list 这个文件里，但错误的提示还是会在屏幕上。</p><ul><li>范例三：承接范例二，将 stdout 和 stderr 分别存到不同的文件中</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dombro@ubuntu:~$ find /home -name .bashrc &gt; list_right 2&gt; list_error &lt;== 屏幕不会显示任何信息， </span><br><span class="line">dombro@ubuntu:~$ ls -al list_right list_error </span><br><span class="line">-rw-rw-r-- 1 dombro dombro 51 Dec 12 10:42 list_error &lt;== stderr 的错误信息写入该文件</span><br><span class="line">-rw-rw-r-- 1 dombro dombro 82 Dec 12 10:42 list_right &lt;== stdout 的正确信息写入该文件</span><br></pre></td></tr></table></figure><ul><li>范例四：承接范例三，将错误数据丢弃，屏幕显示正确数据</li></ul><p>如果我不想使用文件保存 stderr 返回的错误信息，也不想让其在屏幕上显示 我们可以<strong>借助 /dev/null 这个设备 ，你可以把它想象成一个垃圾桶或者黑洞，他可以吃掉任何导向这个设备的信息</strong>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dombro@ubuntu:~$ find /home -name .bashrc 2&gt; /dev/null </span><br><span class="line">/home/dongbo/.bashrc &lt;== 仅会显示 stdout </span><br><span class="line">/home/user2/.bashrc</span><br><span class="line">/home/user1/.bashrc</span><br><span class="line">/home/dombro/.bashrc</span><br></pre></td></tr></table></figure><p>使用这种写法是因为你提前知道会出现哪些 stderr 的错误输出。</p><ul><li>范例五：将命令的返回数据全部写入名为list_show的文件中</li></ul><p>我猜你肯定会这么写</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">dombro@ubuntu:~$ find /home -name .bashrc &gt; list_show 2&gt; list_show</span><br><span class="line">dombro@ubuntu:~$ cat list_show </span><br><span class="line">find: ‘/home/dongbo/home/user2/.bashrc</span><br><span class="line">/home/user1/.bashrc   &lt;== 有没有注意到正确和错误的顺序怪怪的</span><br><span class="line">/home/dombro/.bashrc</span><br><span class="line">...已经显示全部了...</span><br></pre></td></tr></table></figure><p><strong>这是一种错误的写法!</strong>虽然 list_show 这个文件会创建以及被写入，但是 stdout 和 stderr 可能会交替写入，数据可能会丢失。</p><p>正确的两种写法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dombro@ubuntu:~$ find /home -name .bashrc &gt; list_show 2&gt;&amp;1 &lt;== 推荐写法，因为予以更加清晰</span><br><span class="line">dombro@ubuntu:~$ find /home -name .bashrc  &amp;&gt; list_show</span><br></pre></td></tr></table></figure><h4 id="1.1.3">1.1.3 标准输入</h4><p>说了标准输出与标准错误输出应该看一下 标准输入stdin 了。stdin 重定向字符为 &lt; 或 &lt;&lt; ，这两个字符可以将原本需要由键盘输入的数据改由文件内容来代替。</p><ul><li>范例六：利用 cat　命令创建一个文件的简单流程</li></ul><p>what ? cat 创建文件？当然可以</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">dombro@ubuntu:~$ cat &gt; catfile</span><br><span class="line">testing </span><br><span class="line">cat file test</span><br><span class="line">&lt;== 这里按下 [ctrl] + d离开</span><br><span class="line"></span><br><span class="line">dombro@ubuntu:~$ cat catfile</span><br><span class="line">testing </span><br><span class="line">cat file test</span><br></pre></td></tr></table></figure><p>加入 &gt; 在 cat后，所以那个catfile会被主动创建，内容就是键盘上的输入。</p><ul><li>范例七：承接范例六，用 stdin 替代键盘输入已创建新文件简单流程</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dombro@ubuntu:~$ cat &gt; catfile2 &lt; catfile</span><br><span class="line">dombro@ubuntu:~$ ls -al catfile catfile2</span><br><span class="line">-rw-rw-r-- 1 dombro dombro 23 Dec 12 11:13 catfile</span><br><span class="line">-rw-rw-r-- 1 dombro dombro 23 Dec 12 11:20 catfile2</span><br></pre></td></tr></table></figure><p>这两个文件大小一模一样，就像是使用 cp 复制一样。</p><ul><li>范例八: stdin 的 &lt;&lt; </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">dombro@ubuntu:~$ cat &gt; catfile &lt;&lt; &quot;end&quot;</span><br><span class="line">&gt; This is a test</span><br><span class="line">&gt; now stop</span><br><span class="line">&gt; end &lt;== 输入这个关键字，立刻结束不需要输入 [ctrl]+d</span><br><span class="line">dombro@ubuntu:~$ cat catfile</span><br><span class="line">This is a test</span><br><span class="line">now stop</span><br></pre></td></tr></table></figure><p>可以看到 &lt;&lt; 表示结束输入的意思，利用 &lt;&lt; 右侧的控制字符，我们可以终止一次输入，而不必使用 [ctrl]+d 来结束。</p><h3>1.2 why</h3><p>为什么要使用命令重定向呢？来说一说重定向的使用场景</p><blockquote><p>1.屏幕输出的信息很重要，而且我们需要将它存下来<br><br>2.后台执行中的程序，不希望他干扰屏幕上的正常输出结果是<br><br>3.一些系统的执行命令的执行结果，希望它可以存下来<br><br>4.一些执行命令的可能已知错误信息时，可以用 “2&gt;/dev/null”将它丢掉<br><br>5.错误信息与正确信息需要分别输出时</p></blockquote><h2 id="2">2. 命令执行的判断依据 ;、&amp;&amp;、||</h2><p>科技生产力的进步离不开一个字——“懒”。如果我希望一次性执行输入的很多命令。咋办？一种是通过 shell　script 脚本，另一种就是题目中的三种符号 ; &amp;&amp; ||。</p><h3 id="2.1">2.1 ;</h3><p>有时候我们希望可以一次执行多个命令，可以写成这样</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmd;cmd</span><br></pre></td></tr></table></figure><p>上述方法在执行第一个命令后会立即执行第二个命令。常用的是关机操作，通过连续的sync将内存缓存写入磁盘后，在关机。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dombro@ubuntu:~$ sync;sync;shutdown -h now</span><br></pre></td></tr></table></figure><p>但是 ; 两端的命令并不能体现命令的相关性(联系)，即前一个命令的执行结果与后一个命令没啥关系，后一个命令都会执行。如果想达到通过前一个命令执行结果决定后一个命令是否执行，可以通过 &amp;&amp; 或 || 。</p><h3 id="2.2">2.2 &amp;&amp;、||</h3><p>看一下下面的表格</p><table><thead><tr><th>命令执行情况</th><th>说明      </th></tr></thead><tbody><tr><td> cmd1 &amp;&amp; cmd2</td><td>若 cmd1 执行完毕且正确执行($?=0),则开始执行cmd2;若 cmd1 执行完毕且错误执行($?!=0),则cmd2不执行</td></tr><tr><td> cmd1丨丨 cmd2</td><td>若 cmd1 执行完毕且正确执行($?=0)，则cmd2不执行; cmd1 执行完毕且错误执行($?!=0),则开始执行cmd2</td></tr></tbody></table><p>这两个字符挺考验逻辑的，但也挺好理解。</p><ul><li>范例九：用 ls 测试/tmp/testing 是否存在，若存在则显示 “exit”，若不存在则显示 “not exit”</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dombro@ubuntu:~$ ls -al /tmp/testingn 2&gt;/dev/null  &amp;&amp; echo &quot;exit&quot; || echo &quot;not exit&quot;</span><br><span class="line">not exit</span><br></pre></td></tr></table></figure><p>我们知道命令的执行顺序是从左到右，范例九当第一个命令执行执行失败，则导致第二个命令执行失败，第三个命令就会执行成功。这是一个很重要的点，例如下面给出错误示范</p><p>错误示范</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dombro@ubuntu:~$ ls -al /tmp/testingn 2&gt;/dev/null  || echo &quot;not exit&quot; &amp;&amp; echo &quot; exit&quot;  &lt;== 将两个信息都打印出来了</span><br><span class="line">not exit</span><br><span class="line">exit</span><br></pre></td></tr></table></figure><p>当文件不存在时，第二个命令会执行，而第三个命令则根据第二个命令执行成功也会执行。</p><h2 id="3">3. 管道命令</h2><p>你用过 <code>ps -aux|grep xxx</code> 这个命令去查找进程吗？用过的话，恭喜你你已经接触过管道命令了。 </p><h3 id="3.1">3.1 what</h3><p>那么啥是管道命令呢？<strong>简单来说就是前一个命令的输出(stdout)，作为后一个命令的输入(stdin)，命令之间用 | 隔开</strong>。</p><ul><li>举个例子</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dombro@ubuntu:~$ ls -al /etc | less</span><br></pre></td></tr></table></figure><p>如上，由于 /etc 路径下文件太多了，如果直接 ls 屏幕就会被塞满了不知道前面输出了什么，于是利用 less 命令来协助，这样 ls 命令输出的内容就能被less读取,并且利用less功能，可以前后翻动相关信息。很方便~</p><ul><li>了解一下 | </li></ul><p><strong>这个孤零零的命令 <code>|</code> 仅能处理经过前一个命令传来的正确信息,也就是 standard output 的信息，对于standard error并没有直接处理能力</strong></p><p><img src="http://p0bl99g4r.bkt.clouddn.com/Lin_pipe.jpg" alt=""></p><p><strong>在每个管道后接的第一个数据一定要是一个命令！而且这个命令一定要能够接受 standard input 数据才行，这样的命令才是管道命令</strong>。如 less、more、head、tail 等都是可以接受 stdin 的管道命令，而 ls、cp、mv等就不是管道命令了，因为他们并不会接收来自stdin的数据。</p><h3 id="3.2">3.2 一些管道命令</h3><h4 id="3.2.1">选取命令： cut,grep</h4> <p>选取命令就是将一段数据经过分析后，取出我们所需要的，或者经由分析关键字，取得我们所想要的那一行。不过，一般来说，选取的信息通常是针对 “行” 来分析，并不是整片信息分析。</p><ul><li>cut </li></ul><p>cut 切 的意思，没有错，这个命令可以将一段信息的某一段切出来，处理信息是以行为单位的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">语法：</span><br><span class="line">cut(选项)(参数)</span><br><span class="line"></span><br><span class="line">选项:</span><br><span class="line"></span><br><span class="line">-c：仅显示行中指定范围的字符 &lt;== 用于排列整齐的信息</span><br><span class="line">-d：指定字段的分隔符，与 -f 一起使用 &lt;== 用于分割字符</span><br><span class="line">-f：一句 -d 的分割字符将一段信息切割成位数段，用 -f 取出第几段的意思</span><br></pre></td></tr></table></figure><p>范例一：将 PATH 变量取出，找出第五个路径</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dombro@ubuntu:~$ echo $PATH</span><br><span class="line">/usr/java/jdk1.8.0_144/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin</span><br><span class="line"></span><br><span class="line">dombro@ubuntu:~$ echo $PATH |cut -d&apos;:&apos; -f 5</span><br><span class="line">/usr/bin</span><br></pre></td></tr></table></figure><p>如果想列出第3到第5段 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dombro@ubuntu:~$ echo $PATH |cut -d&apos;:&apos; -f 3,5</span><br><span class="line">/usr/local/bin:/usr/bin</span><br></pre></td></tr></table></figure><p>范例二：将 exoprt 输出的信息取得第12字符以后的所有字符串</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">dombro@ubuntu:~$ export</span><br><span class="line">declare -x CLASSPATH=&quot;.:/usr/java/jdk1.8.0_144/lib:/usr/java/jdk1.8.0_144/jre/lib&quot;</span><br><span class="line">declare -x CLUTTER_IM_MODULE=&quot;xim&quot;</span><br><span class="line">declare -x COMPIZ_CONFIG_PROFILE=&quot;ubuntu&quot;</span><br><span class="line">...省略...</span><br><span class="line"></span><br><span class="line">dombro@ubuntu:~$ export | cut -c 12-</span><br><span class="line">CLASSPATH=&quot;.:/usr/java/jdk1.8.0_144/lib:/usr/java/jdk1.8.0_144/jre/lib&quot;</span><br><span class="line">CLUTTER_IM_MODULE=&quot;xim&quot;</span><br><span class="line">COMPIZ_CONFIG_PROFILE=&quot;ubuntu&quot;</span><br></pre></td></tr></table></figure><p>如果想得到 第12-20 的字符，使用 cut -c 12-20 即可。</p><ul><li>grep </li></ul><p>这个命令其实很常见的，grep　实际上就是分析一行信息，若当中有我们需要的信息，就将该行拿出来。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">grep [-acinv] [--color=auto] &apos;搜尋字串&apos; filename</span><br><span class="line">選項與參數：</span><br><span class="line">-a ：將 binary 檔案以 text 檔案的方式搜尋資料</span><br><span class="line">-c ：計算找到 &apos;搜尋字串&apos; 的次數</span><br><span class="line">-i ：忽略大小寫的不同，所以大小寫視為相同</span><br><span class="line">-n ：順便輸出行號</span><br><span class="line">-v ：反向選擇，亦即顯示出沒有 &apos;搜尋字串&apos; 內容的那一行！</span><br><span class="line">--color=auto ：可以將找到的關鍵字部分加上顏色的顯示喔！</span><br></pre></td></tr></table></figure><p>范例三：将 last 中，有出现 root 的那一行取出来</p><p>last 命令可以显示系统用户登录的姓名信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">dombro@ubuntu:~$ last | grep &apos;root&apos;</span><br></pre></td></tr></table></figure><p>范例四：将 last 中，没有出现 root 的行取出来</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dombro@ubuntu:~$ last | grep -v &apos;root&apos;</span><br></pre></td></tr></table></figure><p>3.2.2 排序命令: sort、wc、uniq</p><ul><li>sort </li></ul><p>sort　是一个很有趣的命令，顾名思义，它可以帮助我们排序，还可以根据不同资料形态来排序！</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">sort [-fbMnrtuk] [file or stdin]</span><br><span class="line"></span><br><span class="line">选项：</span><br><span class="line">-f  ：忽略大小写的差异，例如 A 與 a 視为編碼相同；</span><br><span class="line">-b  ：忽略最前面的空白字元部分；</span><br><span class="line">-M  ：以月份的名字來排序，例如 JAN, DEC 等等的排序方法；</span><br><span class="line">-n  ：使用『純數字』進行排序(預設是以文字型態來排序的)；</span><br><span class="line">-r  ：反向排序；</span><br><span class="line">-u  ：就是 uniq ，相同的資料中，僅出現一行代表；</span><br><span class="line">-t  ：分隔符號，預設是用 [tab] 鍵來分隔；</span><br><span class="line">-k  ：以那個區間 (field) 來進行排序的意思</span><br></pre></td></tr></table></figure><p>范例一：对记录个人账号的 /etc/password 中的账号排序</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dombro@ubuntu:~$ cat /etc/passwd | sort </span><br><span class="line">_apt:x:105:65534::/nonexistent:/bin/false</span><br><span class="line">avahi-autoipd:x:110:119:Avahi autoip daemon,,,:/var/lib/avahi-autoipd:/bin/false</span><br><span class="line">backup:x:34:34:backup:/var/backups:/usr/sbin/nologin</span><br><span class="line">bin:x:2:2:bin:/bin:/usr/sbin/nologin</span><br></pre></td></tr></table></figure><p>可以看到，不加选项参数时，是以第一个字符来排序的</p><p>范例二：承接范例一，以第三个含后面字符来排序</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">dombro@ubuntu:~$ cat /etc/passwd | sort -t&apos;:&apos; -k 3</span><br><span class="line">root:x:0:0:root:/root:/bin/bash</span><br><span class="line">dombro:x:1000:1000:ubuntu,,,:/home/dombro:/bin/bash</span><br><span class="line">systemd-timesync:x:100:102:systemd Time Synchronization,,,:/run/systemd:/bin/false</span><br><span class="line">dongbo:x:1001:1002:,,,:/home/dongbo:/bin/bash</span><br><span class="line">user1:x:1002:1003::/home/user1:</span><br><span class="line">user2:x:1003:1004::/home/user2:</span><br></pre></td></tr></table></figure><p>注意第三个 <code>:</code> 后面是数字开始，所以当然会从 0 开始排序。如果单纯想要第三个栏位来处理则是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /etc/passwd | sort -t&apos;:&apos; -k 3,3</span><br></pre></td></tr></table></figure><p>如果想以数字顺序排序则是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /etc/passwd | sort -t&apos;:&apos; -k 3 -n &lt;== 加上 -n 选项即可</span><br></pre></td></tr></table></figure><ul><li>uniq </li></ul><p>如果使用 sort 排序完成，想要重复的资料仅列出一个就使用 uniq 这个命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">uniq [-ic]</span><br><span class="line">選項與參數：</span><br><span class="line">-i  ：忽略大小寫字元的不同；</span><br><span class="line">-c  ：進行計數</span><br></pre></td></tr></table></figure><p>范例一：使用 last　将账号列出，进去出账号栏，进行排序后仅取出一位</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">last | cut -d &apos; &apos; -f1 | sort | uniq</span><br></pre></td></tr></table></figure><p>范例二：承接范例一，列出每个用户登录的次数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">last | cut -d &apos; &apos; -f1 | sort | uniq -c &lt;== 使用 -c 选项列出行数即可</span><br></pre></td></tr></table></figure><ul><li>wc </li></ul><p>wc 命令可以帮助我们知道一个文件中有多少字，多少行，多少字符。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">wc [-lwm]</span><br><span class="line">選項與參數：</span><br><span class="line">-l  ：仅列出行；</span><br><span class="line">-w  ：仅列出多少字(英文單字)；</span><br><span class="line">-m  ：多少字符；</span><br></pre></td></tr></table></figure><p>范例一：列出 /etc/passwd 有多少字符</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dombro@ubuntu:~$ cat /etc/passwd | wc</span><br><span class="line">     43   &lt;== 行   72 &lt;== 字数   2353 &lt;== 字符数</span><br></pre></td></tr></table></figure><p>范例二：如何以一行命令串取得这个月份登录系统的总人次</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dombro@ubuntu:~$ last | grep [a-zA-Z] | grep -v &apos;wtmp&apos;|wc -l</span><br></pre></td></tr></table></figure><p>首先你要知道 last 会输出空白行与wtmp字样在最后两行，这些不包含用户登录信息。于是：grep [a-zA-Z] 取出非空行，grep -v ‘wtmp’ 去掉 wtmp 那两行，在 wc -l 计算行数。</p><h4 id="3.2.3">3.2.3 双向重定向：tee</h4><p>双向重定向？天哪这又是啥？上面<a href="#1.1.1">重定向的部分</a> 说到 &gt; 会将数据流整个传送给文件或设备，因此除非我们去读取这个文件或设备，否则就无法继续利用这个数据流。<strong>往往有时需要在屏幕显示输出的数据，但还要保存数据流处理的过程，那该怎么办？就可以用到我们的双重重定向命令 tee</strong>。</p><ul><li>tee</li></ul><p>tee 会同时将数据流传送给屏幕和文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tee [-a] file</span><br><span class="line"></span><br><span class="line">选项：-a</span><br><span class="line">已累加的方式将数据加入file中</span><br></pre></td></tr></table></figure><ul><li>范例一 : 使用双重重定向例子</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">dombro@ubuntu:~$ ls -al | tee ls_file|grep newfile </span><br><span class="line">-rwxr-xr-x  1 dombro dombro    27 Aug 29 20:49 newfile</span><br><span class="line">dombro@ubuntu:~$ cat ls_file  &lt;== 查看一下</span><br><span class="line">total 184</span><br><span class="line">drwxr-xr-x 19 dombro dombro  4096 Dec 12 11:13 .</span><br><span class="line">drwxr-xr-x  6 root   root    4096 Nov 13 14:04 ..</span><br><span class="line">-rw-rwxr--  1 dombro dombro     0 Aug 27 10:38 at_example.txt</span><br><span class="line">-rw-------  1 dombro dombro 10455 Dec 12 14:03 .bash_history</span><br><span class="line">-rw-r--r--  1 dombro dombro   220 Aug 13 17:08 .bash_logout</span><br><span class="line">-rw-r--r--  1 dombro dombro  3771 Aug 13 17:08 .bashrc</span><br></pre></td></tr></table></figure><p>如果想已累加的方式将数据流存入文件 <code>tee -a file</code> 即可。<br><strong>tee 可以让 stdout 转存一份到文件内并将同样的数据继续送到屏幕去处理</strong>。这样除了可以让我们同时分析一份数据并记录下来之外，还可以作为处理一份数据的中间暂存盘记录。</p><h4 id="3.2.4">3.2.4 字符转换命令: tr、col、join、paste、expand</h4><p>下面介绍几个与字符转换相关的管道命令。</p><ul><li>tr </li></ul><p>tr 用来删除一段信息当中的文字，或者是进行文字信息的转换。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">tr [-ds] SET1</span><br><span class="line"></span><br><span class="line">选项：</span><br><span class="line"></span><br><span class="line">-d : 删除信息中 SET1 这个字符串</span><br><span class="line">-s : 替换重复的字符</span><br></pre></td></tr></table></figure><p>范例一：将 ls 出的文件信息，全部变成大写</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">dombro@ubuntu:~$ ls -al | tr [a-z] [A-Z]</span><br><span class="line">TOTAL 188</span><br><span class="line">DRWXR-XR-X 19 DOMBRO DOMBRO  4096 DEC 13 13:40 .</span><br><span class="line">DRWXR-XR-X  6 ROOT   ROOT    4096 NOV 13 14:04 ..</span><br><span class="line">-RW-RWXR--  1 DOMBRO DOMBRO     0 AUG 27 10:38 AT_EXAMPLE.TXT</span><br><span class="line">-RW-------  1 DOMBRO DOMBRO 10455 DEC 12 14:03 .BASH_HISTORY</span><br><span class="line">...下面省略...</span><br></pre></td></tr></table></figure><p>范例二：将 ls 出的文件信息中的空格去掉</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">dombro@ubuntu:~$ ls -al | tr -d &apos; &apos;</span><br><span class="line">total188</span><br><span class="line">drwxr-xr-x19dombrodombro4096Dec1313:40.</span><br><span class="line">drwxr-xr-x6rootroot4096Nov1314:04..</span><br><span class="line">-rw-rwxr--1dombrodombro0Aug2710:38at_example.txt</span><br><span class="line">-rw-------1dombrodombro10455Dec1214:03.bash_history</span><br><span class="line">...下面省略...</span><br></pre></td></tr></table></figure><p>范例三：将 /etc/passwd 转存成 dos 断行到 /root/passwd 中，再将 ^M 符号删除<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@www ～]# cp /etc/passwd /root/passwd &amp;&amp; UNIX2dos /root/passwd</span><br><span class="line">[root@www ～]# file /etc/passwd /root/passwd</span><br><span class="line">/etc/passwd: ASCII text</span><br><span class="line">/root/passwd: ASCII text, with CRLF line terminators &lt;==就是 DOS 断行</span><br><span class="line">[root@www ～]# cat /root/passwd | tr -d &apos;\r&apos; &gt; /root/passwd.linux</span><br><span class="line"># 那个 \r 指的是 DOS 的断行字符，关于更多的字符，请参考 man tr</span><br><span class="line">[root@www ～]# ll /etc/passwd /root/passwd*</span><br><span class="line">-rw-r--r-- 1 root root 1986 Feb 6 17:55 /etc/passwd</span><br><span class="line">-rw-r--r-- 1 root root 2030 Feb 7 15:55 /root/passwd</span><br><span class="line">-rw-r--r-- 1 root root 1986 Feb 7 15:57 /root/passwd.linux</span><br><span class="line"># 处理过后，发现文件大小与原本的 /etc/passwd 就一致了</span><br></pre></td></tr></table></figure></p><ul><li>col </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">col [-xb]</span><br><span class="line"></span><br><span class="line">参数：</span><br><span class="line">-x : 将 tab 键转换成对等的空格键</span><br><span class="line">-b : 在文字内有反斜杠(/) ，仅保留反斜杠最后接的那个字符</span><br></pre></td></tr></table></figure><p>范例一：利用 cat -A 显示出所有特殊按键，最后以 col 将 [tab] 转成空白</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@www ～]# cat -A /etc/man.config &lt;==此时会看到很多 ^I 的符号，那就是 tab</span><br><span class="line">[root@www ～]# cat /etc/man.config | col -x | cat -A | more</span><br><span class="line">#如此一来，[tab] 按键会被替换成为空格键，输出就美观多了。</span><br></pre></td></tr></table></figure><p>范例二：将 col 的 man page 转存成为 /root/col.man 的纯文本文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@www ～]# man col &gt; /root/col.man</span><br><span class="line">[root@www ～]# vi /root/col.man</span><br><span class="line">COL（1） BSD General Commands Manual COL（1）</span><br><span class="line">N^HNA^HAM^HME^HE</span><br><span class="line">c^Hco^Hol^Hl - filter reverse line feeds from input</span><br><span class="line">S^HSY^HYN^HNO^HOP^HPS^HSI^HIS^HS</span><br><span class="line">c^Hco^Hol^Hl [-^H-b^Hbf^Hfp^Hpx^Hx] [-^H-l^Hl _^Hn_^Hu_^Hm]</span><br><span class="line"># 你没看错。由于 man page 内有些特殊按钮会用来作为类似特殊按键与颜色显示，</span><br><span class="line"># 所以这个文件内就会出现如上所示的一堆怪异字符（有 ^ 的）</span><br><span class="line">[root@www ～]# man col | col -b &gt; /root/col.man</span><br></pre></td></tr></table></figure><ul><li>join </li></ul><p>join 看字面上的意义（加入/参加）就可以知道，它是在处理两个文件之间的数据，而且，主要是将两个文件当中有相同数据的那一行加在一起。我们利用下面的简单例子来说明：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@www ～]# join [-ti12] file1 file2</span><br><span class="line">参数：</span><br><span class="line">-t ：join 默认以空格符分隔数据，并且对比“第一个字段”的数据，</span><br><span class="line">如果两个文件相同，则将两条数据连成一行，且第一个字段放在第一个；</span><br><span class="line">-i ：忽略大小写的差异；</span><br><span class="line">-1 ：这个是数字的 1 ，代表第一个文件要用哪个字段来分析的意思；</span><br><span class="line">-2 ：代表第二个文件要用哪个字段来分析的意思。</span><br></pre></td></tr></table></figure><ul><li>paste </li></ul><p>这个paste就要比join简单多了。相对于join必须要对比两个文件的数据相关性，paste就直接将两行贴在一起，且中间以[tab]键隔开而已。简单的使用方法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@www ～]# paste [-d] file1 file2</span><br><span class="line">参数：</span><br><span class="line">-d ：后面可以接分隔字符，默认是以 [tab] 来分隔的。</span><br><span class="line">- ：如果 file 部分写成 - ，表示来自 standard input 的数据的意思。</span><br></pre></td></tr></table></figure><ul><li>expand</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">就是将[tab]按键转成空格键，可以这样做：</span><br><span class="line">[root@www ～]# expand [-t] file</span><br><span class="line">参数：</span><br><span class="line">-t ：后面可以接数字。一般来说，一个[tab]按键可以用 8 个空格键替换。</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; class=&quot;headerlink&quot; title=&quot;目录&quot;&gt;&lt;/a&gt;目录&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#1&quot;&gt;1. 数据流重定向&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#1.1&quot;&gt;1.1 what&lt;/a&gt;&lt;u
      
    
    </summary>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>浅谈token</title>
    <link href="http://yoursite.com/2017/12/11/%E6%B5%85%E8%B0%88token/"/>
    <id>http://yoursite.com/2017/12/11/浅谈token/</id>
    <published>2017-12-11T11:35:21.000Z</published>
    <updated>2017-12-11T11:35:51.444Z</updated>
    
    <content type="html"><![CDATA[<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li><a href="#1">1.不保存状态的 HTTP 协议</a><ul><li><a href="#1.1">1.1 cookie &amp; session</a></li></ul></li><li><a href="#2">2.Token</a><ul><li><a href="#2.1">2.1 Token哪里好</a></li><li><a href="#2.2">2.2 Token是个啥</a></li><li><a href="#2.3">2.3 JWT的Java实现</a></li></ul></li></ul><h2 id="1">1. 不保存状态的 HTTP 协议</h2><p>目前我们接触到的所有 Web 项目，基本上都是基于 HTTP 协议的，至于啥叫 HTTP协议？简单来说就是从客户端请求访问文本或图像这一类资源(<strong>使用 URI定位</strong>)，服务器端可以提供该资源的响应(<strong>不主动提供响应</strong>)。</p><ul><li>不保存状态的 HTTP 协议</li></ul><p><img src="https://i.imgur.com/iWmfdEO.jpg" alt=""></p><h3 id="1.1">1.1cookie &amp; session</h3> <p>使用 HTTP 协议，每当有新的请求发送时，就会有对应的新响应产生。  无状态导致的业务处理变得棘手情况增多。比如登录购物网站，即使他跳转到该站的其他页面后，也需要能继续保持登陆状态。 因此网站需要保存用户状态，为了实现期望保持状态功能，引入了 Cookie 技术。</p><ul><li>cookie 流程</li></ul><p>cookie 就是在客户端保持状态信息的方案。Cookie 是浏览器访问Web服务器的某个资源时，由Web服务器在Http响应头中附带传给浏览器的小文本文件。这些文本文件，可以保存在浏览器缓存或硬盘中。</p><p>1.浏览器向某个URL发起HTTP请求（可以是任何请求，比如GET一个页面、POST一个登录表单等）</p><p>2.对应的服务器收到该HTTP请求，并计算应当返回给浏览器的HTTP响应。（HTTP响应包括请求头和请求体两部分）</p><p>3.在响应头加入Set-Cookie字段，它的值是要设置的Cookie。</p><p>4.浏览器收到来自服务器的HTTP响应。</p><p>5.浏览器在响应头中发现Set-Cookie字段，就会将该字段的值保存在内存或者硬盘中。（Set-Cookie字段的值可以是很多项Cookie，每一项都可以指定过期时间Expires。 默认的过期时间是用户关闭浏览器时。）</p><p>6.浏览器下次给该服务器发送HTTP请求时， 会将服务器设置的Cookie附加在HTTP请求的头字段Cookie中。（浏览器可以存储多个域名下的Cookie，但只发送当前请求的域名曾经指定的Cookie， 这个域名也可以在Set-Cookie字段中指定）。）</p><p>7.服务器收到这个HTTP请求，发现请求头中有Cookie字段， 便知道之前就和这个用户打过交道了.</p><p>8.过期的Cookie会被浏览器删除。</p><p>（此处举个例子）</p><p><strong>思考题：在后端执行以下代码时，HTTP协议到底做了什么？</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Cookie cookie = new Cookie(&quot;username&quot;,&quot;王大锤&quot;);</span><br><span class="line">response.addCookie(cookie);</span><br></pre></td></tr></table></figure></p><ul><li>cookie 的安全隐患</li></ul><p>Cookie提供了一种手段使得HTTP请求可以附加当前状态， 现今的网站也是靠Cookie来标识用户的登录状态的：</p><p>1.用户提交用户名和密码的表单，这通常是一个POST HTTP请求。</p><p>2.服务器验证用户名与密码，如果合法则返回200（OK）并设置Set-Cookie为authed=true。</p><p>3.浏览器存储该Cookie。</p><p>4.浏览器发送请求时，设置Cookie字段为authed=true。</p><p>5.服务器收到第二次请求，从Cookie字段得知该用户已经登录。 按照已登录用户的权限来处理此次请求。</p><p>问题是什么？？风险是什么？？</p><p>我们知道可以发送HTTP请求的不只是浏览器，很多HTTP客户端软件（包括curl、Node.js）都可以发送任意的HTTP请求，可以设置任何头字段。 <strong>假如我们直接设置Cookie字段为authed=true并发送该HTTP请求， 服务器岂不是被欺骗了？这种攻击非常容易，Cookie是可以被篡改的</strong>！</p><p><em>当然，cookie 是有防篡改机制的，不过我不太了解，但还是有风险！！因为 cookie 是明文传输的，因此 cookie 中最好不要放敏感数据</em></p><ul><li>session 的原理</li><li></li></ul><p><strong>第一次听到 session 就是 cookie 的时候我真的一脸懵逼。WTF 说话一点都不严谨。我们可以说 session 机制是通过 cookie 机制在 HTTP服务器实现保持状态的机制！Session 是存储在服务器端的，避免了在客户端Cookie中存储敏感数据。 Session 可以存储在HTTP服务器的内存中</strong>，也可以存在内存数据库（如redis）中， 对于重量级的应用甚至可以存储在数据库中。<br>session 大家就很熟了可以将用户信息，或其他敏感信息放到 session 对象里面，并且 sesson 可以跨页面（跨页面获取 ？此处有问题？）<br>为什么可以跨页面获取，当然是通过 cookie 啦！ HTTP 每生成（新建）一个session ，都会对应生成一个 sessionId ，这个 sessionId 是该session对象的唯一对应，sessionId 实际上就是一个 cookie ，  将该Cookie传给客户端，在下次请求时就会自动带上sessionId(Cookie)。为了防止混淆，在浏览器中此Cookie默认为JSESSIONID。</p><p>思考题：后端执行这段代码 HTTP 协议到底做了什么？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">User user = new User(1，&quot;王大锤&quot;,&quot;男&quot;);</span><br><span class="line">HttpSession session = request.getSession();</span><br><span class="line">session.setAttribute(&quot;user&quot;,user);</span><br><span class="line">session.getAttribute(&quot;user&quot;);</span><br></pre></td></tr></table></figure><ul><li>session 的实现机制</li></ul><p>1.用户提交包含用户名和密码的表单，发送HTTP请求。</p><p>2.服务器验证用户发来的用户名密码。</p><p>3.如果正确则把当前用户名（通常是用户对象）存储到redis中，并生成它在redis中的ID。</p><p>这个ID称为Session ID，通过Session ID可以从Redis中取出对应的用户对象， 敏感数据（比如authed=true）都存储在这个用户对象中。</p><p>4.设置Cookie为sessionId=xxxxxx|checksum并发送HTTP响应， 仍然为每一项Cookie都设置签名。</p><p>5.用户收到HTTP响应后，便看不到任何敏感数据了。在此后的请求中发送该Cookie给服务器。</p><p>6.服务器收到此后的HTTP请求后，发现Cookie中有SessionID，进行放篡改验证。</p><p>7.如果通过了验证，根据该ID从Redis中取出对应的用户对象， 查看该对象的状态并继续执行业务逻辑。</p><p>实现上述过程，在Web应用中可以直接获得当前用户。 相当于在HTTP协议之上，通过Cookie实现了持久的会话。这个会话便称为Session。</p><h2 id="2">2. Token</h2><p>很好，开胃菜结束了，<strong>迎来了今天的主菜 Token 。</strong> 大家掌声欢迎一下 ！</p><h3 id="2.1">2.1 Token 哪里好</h3><p>1.支持跨域访问: Cookie是不允许垮域访问的，这一点对Token机制是不存在的，前提是传输的用户认证信息通过HTTP头传输。（垮域访问：两个域名之间不能跨过域名来发送请求或者请求数据）</p><p>2.<strong>无状态(也称：服务端可扩展行):Token机制在服务端不需要存储session信息，因为Token 自身包含了所有登录用户的信息，只需要在客户端的cookie或本地介质存储状态信息</strong>.</p><p>3.<strong>更适用CDN: 可以通过内容分发网络请求你服务端的所有资料（如：javascript，HTML,图片等），而你的服务端只要提供API即可</strong>.</p><p>4.<strong>去耦: 不需要绑定到一个特定的身份验证方案。Token可以在任何地方生成，只要在你的API被调用的时候，你可以进行Token生成调用即可</strong>.</p><p>5.<strong>更适用于移动应用: 当你的客户端是一个原生平台（iOS, Android，Windows 8等）时，Cookie是不被支持的（你需要通过Cookie容器进行处理），这时采用Token认证机制就会简单得多</strong>。</p><p>6.<strong>CSRF:因为不再依赖于Cookie，所以你就不需要考虑对CSRF（跨站请求伪造）的防范</strong>。</p><p>7.<strong>性能: 一次网络往返时间（通过数据库查询session信息）总比做一次HMACSHA256计算 的Token验证和解析要费时得多</strong>.</p><p>8.<strong>不需要为登录页面做特殊处理: 如果你使用Protractor 做功能测试的时候，不再需要为登录页面做特殊处理</strong>.</p><p>9.基于标准化:你的API可以采用标准化的 JSON Web Token (JWT). 这个标准已经存在多个后端库（.NET, Ruby, Java,Python, PHP）和多家公司的支持（如：Firebase,Google, Microsoft）.</p><h3 id="2.2">2.2 Token 是个啥</h3><p>Token 是 一种保持状态的的机制。不过并不像我们在 web 中学过的 Cookie 和 Session 那样是已经写好的类或对应的对象。Token 是一种用指定算法生成的 “ 串 ”。</p><ul><li>Token 原理</li></ul><p>1.将荷载payload，以及Header信息进行Base64加密，形成密文payload密文，header密文。<br>2.将形成的密文用句号链接起来，用服务端秘钥进行HS256加密，生成签名.<br>3.将前面的两个密文后面用句号链接签名形成最终的token返回到服务端<br>无图言屌</p><p><img src="https://i.imgur.com/O12gxcB.jpg" alt=""></p><p>因此 <strong>Token 可以简化为 base64url_encode(Header) + ‘.’ + base64url_encode(Claims) + ‘.’ + base64url_encode(Signature)</strong><br><strong>实际上生成这个 Token 生成一个 加密字符串(包含用户信息的加密字符串)的过程</strong></p><ul><li>Token 用法</li></ul><p>1.用户请求时携带此token（分为三部分，header密文，payload密文，签名）到服务端，服务端解析第一部分（header密文），用Base64解密，可以知道用了什么算法进行签名，此处解析发现是HS256。<br>2.服务端使用原来的秘钥与密文(header密文+”.”+payload密文)同样进行HS256运算，然后用生成的签名与token携带的签名进行对比，若一致说明token合法，不一致说明原文被修改。<br>3.判断是否过期，客户端通过用Base64解密第二部分（payload密文），可以知道荷载中授权时间，以及有效期。通过这个与当前时间对比发现token是否过期。</p><p><img src="https://i.imgur.com/0SklpWT.png" alt=""></p><h3 id="2.3">2.3 JWT 的 Java实现</h3><p>JWT 是一种基于 Token 的认证方案，生成 Token 的方式有很多种（反正给前台） 。JWT 算法可以理解为是专门为生成 Token 而存在的，它可以通过方法设置 Header , 载荷信息，设置Token过期时间等等功能。</p><ul><li>依赖</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">       &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt;</span><br><span class="line">       &lt;artifactId&gt;jjwt&lt;/artifactId&gt;</span><br><span class="line">       &lt;version&gt;0.7.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>当然，Token 并不代表着万事大吉，大吉大利，只是相对于 cookie 来说是一种更好的选择，毕竟没有完美的 web 策略嘛</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; class=&quot;headerlink&quot; title=&quot;目录&quot;&gt;&lt;/a&gt;目录&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#1&quot;&gt;1.不保存状态的 HTTP 协议&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#1.1&quot;&gt;1.1 coo
      
    
    </summary>
    
    
      <category term="JavaWeb" scheme="http://yoursite.com/tags/JavaWeb/"/>
    
  </entry>
  
  <entry>
    <title>Java工厂设计模式</title>
    <link href="http://yoursite.com/2017/12/11/Java%E5%B7%A5%E5%8E%82%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2017/12/11/Java工厂设计模式/</id>
    <published>2017-12-11T11:26:41.000Z</published>
    <updated>2017-12-11T11:32:56.978Z</updated>
    
    <content type="html"><![CDATA[<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li><a href="#0">0.阅读指南</a></li><li><a href="#1">1. 前言</a></li><li><a href="#2">2. What</a><ul><li><a href="#2.1">2.1 简单工厂模式</a></li><li><a href="#2.2">2.2 工厂方法模式</a></li><li><a href="#2.3">2.3 抽象工厂模式</a></li></ul></li><li><a href="#3">3. How</a><ul><li><a href="#3.1">3.1 引子</a></li><li><a href="#3.2">3.2 Why</a></li></ul></li><li><a href="#4">4. When</a></li><li><a href="#5">5.总结</a></li><li><a href="#6">6.参考</a></li></ul><h2 id="0">0.阅读指南</h2><p>初次接触工厂模式的同学，如果不想看枯燥的概念，可以先从<a href="#3.1">3.1引子</a>看起，回过头来在看一下概念性较多的<a href="#2">What</a>部分。</p><h2 id="1">1.前言</h2><p>当老师讲设计模式这门课整天嘴上挂着面向对象、OOP等专业术语，觉得离自己太遥远。总以为技术上的low逼怎么可能理解或者用到 GoF 的《设计模式》这本书…然鹅事实并非如此。上课迷迷糊糊听到老师讲到工厂模式，听到了Factory 这个单词，我马上被吸引了，Spring、MyBatis里面都有Factory…莫非有啥关系吗?好好看过书与上网查阅资料后，才发现设计模式离我如此之近！！！</p><h2 id="2">2.What</h2><p>在 GoF 四位大佬写的《设计模式》（被面向对象编程人员当做圣经的一本书）<strong>创建型模式</strong>这一章中，提到了五种创建型模式，这其中包括<strong>抽象工厂模式(ABSTRACT FACTORY)</strong>、<strong>工厂方法模式(FACTORY METHOD)</strong>。<br>创建型模式，顾名思义创造对象实例化过程的模式，也就是帮你造对象的模式，主要的<strong>功能就是帮助我们把对象的实例化部分抽取了出来，优化了系统的架构，并且增强了系统的扩展性</strong>。虽然四大佬在书里只提到两种创建型工厂模式，其实还有一种Java语言常用的<strong>简单工厂模式</strong>。今天就来撸一撸这三种工厂模式！</p><h3 id="2.1">2.1 简单工厂模式</h3><p>简单工厂模式的工厂类一般是使用静态方法，通过接收的参数的不同来返回不同的对象实例。不修改代码的话，是无法扩展的</p><p><img src="http://p0bl99g4r.bkt.clouddn.com/SimpleFactory.PNG" alt=""></p><h3 id="2.2">2.2 工厂方法模式</h3><p>工厂方法是针对每一种产品提供一个工厂类。通过不同的工厂实例来创建不同的产品实例。在同一等级结构中，支持增加任意产品。</p><p><img src="http://p0bl99g4r.bkt.clouddn.com/FactoryMethod.PNG" alt=""></p><h3 id="2.3">2.3 抽象工厂模式</h3><p>抽象工厂是应对产品族概念的。应对产品族概念而生，增加新的产品线很容易，但是无法增加新的产品。</p><p><img src="http://p0bl99g4r.bkt.clouddn.com/AbstractFactory.PNG" alt=""></p><h2 id="3">3. How</h2><p>事实上这三种工厂模式并没有严格的好坏之分，会因为使用场景的不同而有最适合的模式。</p><h3 id="3.1">3.1 引子</h3><p>在面向对象的世界中，最高阶的功法与核心就是模拟真实世界，把真实世界中的事物抽象成类，整个程序靠各个类的实例互相通信、互相协作完成系统功能，这非常符合真实世界的运行状况，也是面向对象思想的精髓。<br>本着这种精髓来举个例子，有这样一个人，就叫他大黄吧，他想要<strong>驾驶一辆汽车兜兜风</strong>，他可能会这样：</p><ul><li>剧本一 大黄自己造汽车</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">产品</span><br><span class="line">//汽车类</span><br><span class="line">class Car&#123;</span><br><span class="line"></span><br><span class="line">  public void move()&#123;</span><br><span class="line">     System.out.println(&quot;我只是一辆普通的小汽车，我开动了&quot;)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">使用者：</span><br><span class="line"></span><br><span class="line">//大黄先生类（调用类）</span><br><span class="line">public class DaHuang&#123;</span><br><span class="line"></span><br><span class="line">   public void drive()&#123;</span><br><span class="line">   //自己造汽车，累的一批</span><br><span class="line">   Car car = new Car();</span><br><span class="line">   //启动车</span><br><span class="line">   car.move();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有没有很累呀，大黄先生只想安静的开车兜风，但却要自己亲自造一个车(new Car) 。太不suang了，后来大黄先生发现家附近有一个汽车工厂，不仅可以造汽车，还可以选择宝马和奔驰这两种品牌，这可乐坏了大黄先生，于是：</p><ul><li>剧本二 工厂为大黄造汽车（<a href="#2.1">简单工厂模式，戳我看概念</a>）</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">                           产品</span><br><span class="line">//汽车接口</span><br><span class="line">interface Car&#123;</span><br><span class="line"></span><br><span class="line">  public void move();</span><br><span class="line">   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//宝马汽车类</span><br><span class="line">class Bwm implements Car&#123;</span><br><span class="line"></span><br><span class="line"> public void move()&#123;</span><br><span class="line">     System.out.println(&quot;我可是宝马老铁，我开动了，速度可快了呢！&quot;)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//奔驰汽车类</span><br><span class="line">class Benz implements Car&#123;</span><br><span class="line"></span><br><span class="line"> public void move()&#123;</span><br><span class="line">     System.out.println(&quot;我是奔驰呀，我开动了，我的稳定性很好&quot;)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">工厂：</span><br><span class="line"></span><br><span class="line">class CarFactory&#123;</span><br><span class="line"></span><br><span class="line">  public static Car createCar(String carBrand)&#123;</span><br><span class="line">    switch(carBrand)&#123;</span><br><span class="line">      case &quot;Bwm&quot;:</span><br><span class="line">       return new Bwm();</span><br><span class="line">   break;</span><br><span class="line">      case &quot;Benz&quot;:</span><br><span class="line">       return new Benz();</span><br><span class="line">   break;         </span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">使用者：</span><br><span class="line"></span><br><span class="line">//大黄先生类（调用类）</span><br><span class="line">public class DaHuang()&#123;</span><br><span class="line">   //依赖汽车接口</span><br><span class="line">   private Car car;</span><br><span class="line"></span><br><span class="line">   public void drive()&#123;</span><br><span class="line">   //找工厂要指定型号的汽车 </span><br><span class="line">   car = CarFactory.createCar(&quot;Bwm&quot;);</span><br><span class="line">   //启动车</span><br><span class="line">   car.move();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大黄先生开着从工厂造出来的宝马，心里想那以后开奔驰的时候还要特意跑来工厂跟厂长说我只想要奔驰，靠，我只想开车呀！可不可以在省力一点！就在这个时候厂长打来电话，告诉大黄先生，我们厂改革啦，造奔驰和造宝马的分成两个不同的厂子啦，以后给指定的厂子打电话就可以<strong>送货上门</strong>！真的吗？大黄先生高兴坏了：</p><ul><li>剧本三 大黄给奔驰汽车厂打电话，送货上门(<a href="#2.2">工厂方法模式，戳我看概念</a>)</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line">产品</span><br><span class="line">//汽车接口</span><br><span class="line">interface Car&#123;</span><br><span class="line"></span><br><span class="line">  public void move();</span><br><span class="line">   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//宝马汽车类</span><br><span class="line">class Bwm implements Car&#123;</span><br><span class="line"></span><br><span class="line"> public void move()&#123;</span><br><span class="line">     System.out.println(&quot;我可是宝马老铁，我开动了，速度可快了呢！&quot;)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//奔驰汽车类</span><br><span class="line">class Benz implements Car&#123;</span><br><span class="line"></span><br><span class="line"> public void move()&#123;</span><br><span class="line">     System.out.println(&quot;我是奔驰呀，我开动了，我的稳定性很好&quot;)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">工厂：</span><br><span class="line"></span><br><span class="line">//工厂改革了，不在这个厂区生产了，只进行图纸研发，即变成接口，只规定一些规范，</span><br><span class="line">interface CarFactory&#123;</span><br><span class="line">   </span><br><span class="line">  public Car createCar();</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//宝马汽车厂</span><br><span class="line">class BwmFactory implements CarFactory&#123;</span><br><span class="line">    </span><br><span class="line">private BwmFactory()&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //单例模式,即只提供送货上门</span><br><span class="line">    public static BwmFactory getInstance()&#123;</span><br><span class="line">        return BwmFactory();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //只生产宝马</span><br><span class="line">public Car createCar()&#123;</span><br><span class="line">    return new Bwm();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//奔驰汽车厂</span><br><span class="line">class BenzFactory implements CarFactory&#123;</span><br><span class="line">    </span><br><span class="line">    private BenzFactory()&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    //单例模式,即只提供送货上门</span><br><span class="line">    public static BenzFactory getInstence()&#123;</span><br><span class="line"></span><br><span class="line">       return new BenzFactory();</span><br><span class="line">&#125;</span><br><span class="line">     </span><br><span class="line">    //只生产宝马</span><br><span class="line">public Car createCar()&#123;</span><br><span class="line">    return new Benz();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">使用者:</span><br><span class="line"></span><br><span class="line">//大黄先生类（调用类）</span><br><span class="line">public class DaHuang()&#123;</span><br><span class="line">   //依赖汽车接口</span><br><span class="line">   private Car car;</span><br><span class="line">   public void drive()&#123;</span><br><span class="line">   //直接给生产奔驰的厂区打电话，叫他们把奔驰送过来</span><br><span class="line">   car = BenzFactory.getInstence().createCar();</span><br><span class="line">   //启动车</span><br><span class="line">   car.move();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这下大黄舒服满意了吧？他开着厂家送过来的奔驰，突然发现自己的车没有安装行车记录仪，大黄当然自己可以造一款行车记录仪（new Tachograph），但是大黄只想开车，于是大黄开车找到了行车记录仪厂家，当然可以帮大黄安装，但大黄只想开车呀，各位乡亲父老，他只想开车有错吗？这时候，汽车厂厂长又打来了电话，告诉大黄先生说，我们厂的业务扩充到行车记录仪的领域啦，以后给下面分厂打电话就可以把<strong>装有指定品牌的行车记录仪的奔驰或宝马</strong> 送货上门啦！大黄先生默默拨通了电话:</p><ul><li>剧本四 装有行车记录仪的奔驰汽车送到大黄家(<a href="#2.3">抽象工厂模式，戳我看概念</a>)</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line">产品</span><br><span class="line">//汽车接口</span><br><span class="line">interface Car&#123;</span><br><span class="line"></span><br><span class="line">  public void move();</span><br><span class="line">   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//宝马汽车类</span><br><span class="line">class Bwm implements Car&#123;</span><br><span class="line"></span><br><span class="line"> public void move()&#123;</span><br><span class="line">     System.out.println(&quot;我可是宝马老铁，我开动了，速度可快了呢！&quot;)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//奔驰汽车类</span><br><span class="line">class Benz implements Car&#123;</span><br><span class="line"></span><br><span class="line"> public void move()&#123;</span><br><span class="line">     System.out.println(&quot;我是奔驰呀，我开动了，我的稳定性很好&quot;)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//行车记录仪接口</span><br><span class="line">interface Tachograph()&#123;</span><br><span class="line">public void record();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//A品牌行车记录仪</span><br><span class="line">class TachographA() implements Tachograph&#123;</span><br><span class="line">public void record()&#123;</span><br><span class="line"> System.out.println(&quot;我是A品牌行车记录仪，我开始记录了&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//B品牌行车记录仪</span><br><span class="line">class TachographB() implements Tachograph&#123;</span><br><span class="line">public void record()&#123;</span><br><span class="line"> System.out.println(&quot;我是B品牌行车记录仪，我开始记录了&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》</span><br><span class="line">     工厂</span><br><span class="line"></span><br><span class="line">//工厂升级了，不止生产汽车，还生产行车记录仪</span><br><span class="line">interface CarAndTachographFactory&#123;</span><br><span class="line">   </span><br><span class="line">  public Car createCar();</span><br><span class="line"></span><br><span class="line">  public Tachograph creatTachograph();</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//既生产宝马又生产A品牌行车记录仪的工厂</span><br><span class="line">class BwmAndTachographAFactory()&#123;</span><br><span class="line">  </span><br><span class="line">  private BwmAndTachographAFactory()&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    //单例模式,即只提供送货上门</span><br><span class="line">    public static BwmAndTachographAFactory getInstence()&#123;</span><br><span class="line"></span><br><span class="line">       return new BwmAndTachographAFactory();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  public Car createCar()&#123;</span><br><span class="line">return new Bwm();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public Tachograph creatTachograph()&#123;</span><br><span class="line">    return new  TachographA();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//既生产奔驰又生产B类行车记录仪的工厂</span><br><span class="line">class BenzAndTachographBFactory()&#123;</span><br><span class="line"></span><br><span class="line">   private BenzAndTachographBFactory()&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    //单例模式,即只提供送货上门</span><br><span class="line">    public static BenzAndTachographBFactory getInstence()&#123;</span><br><span class="line"></span><br><span class="line">       return new BenzAndTachographBFactory();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  public Car createCar()&#123;</span><br><span class="line">return new Benz();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public Tachograph creatTachograph()&#123;</span><br><span class="line">    return new  TachographB();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》</span><br><span class="line"> 使用者</span><br><span class="line"></span><br><span class="line">//大黄先生类（调用类）</span><br><span class="line">public class DaHuang()&#123;</span><br><span class="line">   //依赖汽车接口</span><br><span class="line">   private Car car;</span><br><span class="line">   //依赖行车记录仪接口 </span><br><span class="line">   private Tachograph tachograph;</span><br><span class="line"></span><br><span class="line">   public void drive()&#123;</span><br><span class="line">   //给生产奔驰和A品牌行车记录仪的厂家打电话，叫他们把奔驰车送来</span><br><span class="line">   car = BenzAndTachographBFactory.getInstence().createCar();</span><br><span class="line">   //把A品牌行车记录仪也送过来</span><br><span class="line">   tachograph = BenzAndTachographBFactory.getInstence().creatTachograph();</span><br><span class="line">   //启动车</span><br><span class="line">   car.move();</span><br><span class="line">   //记录</span><br><span class="line">   tachograph.record();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样一来，大黄就不用再把注意力放在如何得到汽车和行车记录仪，只需要给生产指定产品组合的工厂 打call ，等待工厂为他造好就可以了。 </p><h3 id="3.2">3.2 Why</h3><p>看了上面的引子和概念，没错想必你还是一脸的懵逼。这里特意准备了几个问题，供你参考。</p><ul><li>看了这么多，所以为什么我们不要自己去 new 对象，反而要写这么多啰嗦的代码？</li></ul><blockquote><p>(1).就像引子中的多次强调的，当一个调用者的关注点仅仅是调用产品中的方法，而不想亲自创建这个具体产品的对象时，通过工厂模式可以让调用模块更加规范专注于结构上的编码。<br>(2). 实际上当我们在程序中，使用了 new 关键字，就会在内存中开辟一块地址空间，这个看似简单的过程，要经过很多的判断，例如要生成哪个子对象实例，是否需要计算或取得对象的初始设置，或在生成你需要的对象之前必须先生成一些辅助功能的对象等等判断，这不就好像一个造汽车的过程吗？<br>(3). 合作开发时的考虑，有的时候需要多人协作来完成一些项目，不同人员那肯定是写不同层次的代码如，底层，应用层，调用层，当编写调用层的人想要去获取应用层是实例，那就尴尬了，应用层根本不是他写的呀，擅自实例化肯定有危险，所以写应用层的人要为他提供工厂，让调用层实例。</p></blockquote><ul><li>直接去弄一个Factory把需要实例化的具体产品实例化不就好了吗？</li></ul><blockquote><p>这真的是一个好问题，也困扰了我很久。但实际上确实有问题中的这种工厂类（反射机制）。以下是我自己的见解，我认为所说的三种工厂设计模式是<strong>通过多态去实例化一类的产品</strong>，想一下如果你每实例化一个产品（注意是一个），都在万能类中去反射获得一个实例，你需要传入这个产品的具体类名，那这和你去 new 一个对象有什么区别? 因为这个具体的产品（类名）还是在调用的时候被暴露了！ </p></blockquote><ul><li>怎么有那么多的接口(抽象类)？工厂接口，产品接口…?</li></ul><blockquote><p>为什么会有这么多的接口，实际上一提到接口就一定会想到多态。如引子里面所描述的产品宝马汽车和奔驰汽车都是汽车这一类产品（产品接口），而工厂接口则进行了一个规定，即我的实现类或子类，必须去生产汽车这类产品，加入以后汽车产品新增了奥迪汽车，那只需要在实现一个奥迪汽车工厂用来生产奥迪就好了。保证了我们程序的可扩展性。</p></blockquote><ul><li>为什么调用者只依赖于抽象的产品接口？</li></ul><blockquote><p>实际上这是面向接口百年城的内容，这个问题和上一个问题可以一起回答，上一个问题是为什么有产品接口和工厂接口，我可以用一个词来回答你！多态！多态！还他md是多态！想一下要是不依赖于产品接口，那你的调用者要依赖一个甚至是多个具体的产品，并且一旦这个具体的产品有所改动，那整个调用者都会跟着改动。在一定程度上解耦合，依赖接口还不依赖具体实现，在替换实现类的时候，可以将影响减到最小。</p></blockquote><h2 id="4">4. When</h2><p>说了这么多，这三种工厂模式什么时候使用呢？在 MVC 设计模式下，service 与 DAO 不正好是调用者和产品的关系吗？ service 层并不在乎 DAO 如何创建，却需要 DAO 中的方法。 而设计 DAO 的方式多种多样，举几个小例子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//一个DAO接口，需要子类实现增删改查操作</span><br><span class="line">interface DAO&#123;</span><br><span class="line"></span><br><span class="line">boolean updata(arg...);</span><br><span class="line">boolean insert(arg...);</span><br><span class="line">boolean list&lt;Object&gt; get(arg...);</span><br><span class="line">boolean Object&lt;Object&gt; getList(arg...);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>简单工厂</li></ul><p>我们知道，简单工厂模式一般只有一个具体工厂类，所以当具体产品较少时，适合使用简单工厂。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">//只有两个具体实现</span><br><span class="line">class StudentDAOImp implements DAO&#123;</span><br><span class="line">      略....</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class BookDAOImp implemets DAO&#123;</span><br><span class="line">  略....</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//工厂接口</span><br><span class="line">interface IDAOFactory()&#123;</span><br><span class="line">     static DAO getDAO(String target);</span><br><span class="line">&#125;</span><br><span class="line">//简单接口</span><br><span class="line"></span><br><span class="line">class DAOFactory()&#123;</span><br><span class="line"> staticpublic DAO getDAO(String target)&#123;</span><br><span class="line">switch(target)&#123;</span><br><span class="line">         case &quot;stu&quot; :</span><br><span class="line"> return new StudentDAOImp();</span><br><span class="line">break;</span><br><span class="line"> case &quot;book&quot; :</span><br><span class="line">return new BookDAOImp();</span><br><span class="line">break;</span><br><span class="line">     &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>工厂方法 </li></ul><p>实际简单工厂是上工厂方法的特例，所以当你认为你的某类DAO产品有点多，并且很有可能还会新增这类DAO的具体实现，那就使用工厂方法模式，为该类DAO的每个具体实现派生具体工厂类。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class StudentDAOFactory()&#123;</span><br><span class="line"> staticpublic DAO getDAO(String target)&#123;</span><br><span class="line"> </span><br><span class="line">     return new StudentDAOImp();</span><br><span class="line"> </span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class BookDAOFactory()&#123;</span><br><span class="line"> staticpublic DAO getDAO(String target)&#123;</span><br><span class="line"> </span><br><span class="line">     return new  BookDAOImp();</span><br><span class="line"> </span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>抽象工厂</li></ul><p>实际上，有些时候我们的可能DAO并没有那么简单，发现并不是单纯的增删改查就万事大吉，针对不同的表有不同的操作，比如 StudentDAO 和 BookDAO 并抽取不出太多相同的操作。那这个时候 StudentDAO 和 BookDAO 就属于两种产品类，但却属于同一产品族。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//如下，这是两个不同的产品</span><br><span class="line">interface StudentDAO&#123;</span><br><span class="line">    List&lt;Student&gt; getStudents(args...);</span><br><span class="line">List&lt;Student&gt; findById(int id);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface BookDAO&#123;</span><br><span class="line">    int getBookId(args...);</span><br><span class="line">boolean deleteBook(int args); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>针对不同的DAO产品，那具体DAO产品的实现肯定不同</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">//使用JDBC实现的StudentDAO</span><br><span class="line">class StudentDAOByJdbc implements StudentDAO&#123;</span><br><span class="line"></span><br><span class="line">   略...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//使用MyBatis框架实现的StudentDAO</span><br><span class="line">class StudentDAOByMyBatis implements StudentDAO&#123;</span><br><span class="line"></span><br><span class="line">   略...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//使用JDBC实现的BookDAO</span><br><span class="line">class BookDAOByMyBatis implements BookDAO&#123;</span><br><span class="line"></span><br><span class="line">   略...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//使用MyBatis框架实现的BookDAO</span><br><span class="line">class BookDAOByMyBatis implements BookDAO&#123;</span><br><span class="line"></span><br><span class="line">   略...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重点在于抽象工厂</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">interface IDAOFactory &#123;</span><br><span class="line"></span><br><span class="line">   StudentDAO getStudentDAO();</span><br><span class="line">   BookDAO getBookDAO(); </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class JdbcDAOFactory implements IDAOFactory&#123;</span><br><span class="line">    StudentDAO getStudentDAO()&#123;</span><br><span class="line">      return new StudentDAOByJdbc();</span><br><span class="line">&#125;</span><br><span class="line">    BookDAO getBookDAO()&#123;</span><br><span class="line">  return new BookDAOByJdbc();</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class MyBatisDAOFactory implements IDAOFactory&#123;</span><br><span class="line">    StudentDAO getStudentDAO()&#123;</span><br><span class="line">      return new StudentDAOByMyBatis();</span><br><span class="line">&#125;</span><br><span class="line">    BookDAO getBookDAO()&#123;</span><br><span class="line">  return new BookDAOByMyBatis();</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>事实上，当然不会有人写直接在程序中两套DAO接口，但是当我们遇到更好的DAO解决办法（比如有Jdbc升级到MyBatis），如果再去修改原有的DAO实现，是一件很恐怖的事情，所以可以将将新写好的一套具体DAO的实现封装在实现了抽象工厂的具体工厂中，在调用层代用这个工厂中的DAO实例就OK了！！</p><h2 id="5">5. 总结</h2><ul><li>总结</li></ul><blockquote><p>1.工厂模式中，重要的是工厂类，而不是产品类。产品类可以是多种形式，多层继承或者是单个类都是可以的。但要明确的，工厂模式的接口只会返回一种类型的实例，这是在设计产品类的时候需要注意的，最好是有父类或者共同实现的接口。</p><p>2.使用工厂模式，返回的实例一定是工厂创建的，而不是从其他对象中获取的。</p><p>3.工厂模式返回的实例可以不是新创建的，返回由工厂创建好的实例也是可以的。</p><p>4.简单工厂 ： 用来生产同一等级结构中的任意产品。（对于增加新的产品，无能为力）</p><p>5.工厂方法 ：用来生产同一等级结构中的固定产品。（支持增加任意产品）</p><p>6.抽象工厂 ：用来生产不同产品族的全部产品。（对于增加新的产品，无能为力；支持增加产品族）  </p><p>7.以上三种工厂 方法在等级结构和产品族这两个方向上的支持程度不同。所以要根据情况考虑应该使用哪种方法。  </p><p>8.简单工厂优点：客户端可以免除直接创建产品对象的责任，而仅仅是“消费”产品。简单工厂模式通过这种做法实现了对责任的分割。</p><p>9.工厂方法有点：允许系统在不修改具体工厂角色的情况下引进新产品。</p><p>10.抽象工厂优点：向客户端提供一个接口，使得客户端在不必指定产品具体类型的情况下，创建多个产品族中的产品对象 </p></blockquote><h2 id="6">6. 参考</h2><p>图书：<br>GoF《设计模式》</p><p>博客：<br><a href="http://zyjustin9.iteye.com/blog/2094960" target="_blank" rel="noopener">http://zyjustin9.iteye.com/blog/2094960</a></p><p><a href="http://blog.csdn.net/hguisu/article/details/7505909" target="_blank" rel="noopener">http://blog.csdn.net/hguisu/article/details/7505909</a></p><p><a href="http://blog.csdn.net/u014600626/article/details/52131016" target="_blank" rel="noopener">http://blog.csdn.net/u014600626/article/details/52131016</a></p><p><a href="http://blog.csdn.net/u013604031/article/details/50595107" target="_blank" rel="noopener">http://blog.csdn.net/u013604031/article/details/50595107</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; class=&quot;headerlink&quot; title=&quot;目录&quot;&gt;&lt;/a&gt;目录&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#0&quot;&gt;0.阅读指南&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#1&quot;&gt;1. 前言&lt;/a&gt;&lt;/li&gt;
&lt;li
      
    
    </summary>
    
    
      <category term="设计模式" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Java优雅的处理异常</title>
    <link href="http://yoursite.com/2017/12/11/Java%E4%BC%98%E9%9B%85%E7%9A%84%E5%A4%84%E7%90%86%E5%BC%82%E5%B8%B8/"/>
    <id>http://yoursite.com/2017/12/11/Java优雅的处理异常/</id>
    <published>2017-12-11T11:23:31.000Z</published>
    <updated>2017-12-11T11:25:27.846Z</updated>
    
    <content type="html"><![CDATA[<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li><a href="#0">0. 写在前面</a></li><li><a href="#1">1. 掀起Java异常的裙子来</a><ul><li><a href="#1.1">1.1 个人对异常机制的理解</a></li><li><a href="#1.2">1.2 Java异常扫盲行动</a></li><li><a href="#1.3">1.3 Java处理异常手段</a></li><li><a href="#1.3.1">1.3.1 Java抛出异常 throw、throws</a></li><li><a href="#1.3.2">1.3.2 Java捕获异常</a></li></ul></li><li><a href="#2">2. 优雅的处理异常</a></li><li><a href="#3">3. 结语</a></li></ul><h2 id="0">0. 写在前面</h2><p>终于要说<strong>Java异常</strong>了，按照国际惯例，在前言里面BB几句，找找感觉。开始自学Java时前面大概还顺风顺水，但是到了异常这里，原地爆炸，实在不理解Java的这个机制是干啥用的。后来了解到 C++ 等高级语言也有类似的机制(事实证明，Java异常机制仿照了C++)，<strong>很长一段时间都是看见异常就很机械性的往外抛，或try catch（这里指受检异常），不明就里</strong>。慢慢发现，不止我自己是这样迷迷糊糊碰到异常就交给编译器（alt+enter 或者其他的快捷键），<strong>仿佛好多人都在刻意逃避异常—————这个不正常的家伙</strong>。</p><h2 id="1">1. 掀起Java异常的裙子来</h2><p>虽然 Java 里面有异常处理机制，并且把它当成了一个对象，但是要明确的是，<strong>绝对不应该用正常的眼光态度看待异常</strong>！好像公司正在开会，你虽然也是这个公司的员工，但却一丝不挂的来参加会议，说明肯定是你有问题！绝对一点说，异常就是某种意义上的错误，就是问题<strong>它可能会导致程序失败</strong>！ </p><h3 id="1.1">1.1 个人对异常机制的理解</h3><p>可以想象一下，当你的程序需要读取一个文件时，编译器会疯狂提示你去处理一个<code>IOEXception</code>(或者是<code>FileNotFoundException</code>这里只是举一个例子)，有没有想过为什么？编译器帮我们做的太多，以至于我们没有时间去好好思考Java设计人员的良苦用心。当我们程序运行期间，如果意外停止了，那一定是因为有错误（废话）。比如开始的那个问题，根本还没有传一个文件咋就让我处理异常?假设程序在运行期间真的出现了<code>IOException</code> 这时候你还会去看控制台打印出来的错误报告？绝对不可能，这是在一个程序运行期间，已将交给用户操作了;不处理？程序就此中断，你失去了一位用户。所以很庆幸Java提供了异常这个东西，我们可以提前去处理可能出现的异常，有可能是给用户一个提示信息，有可能是把错误信息放到日志里面，保证了程序没有因为一个错误而毫无征兆的终止（这句话太严谨了，给自己打call）！<strong>总之异常就是程序在运行期间不期而至的各种状况，而Java这种硬性要求似的处理异常机制对程序的健壮性是有好处的</strong>。</p><h3 id="1.2">1.2 Java异常扫盲大行动</h3><p>帮大家和自己顺便复习一下Java异常</p><ul><li>Java 异常的体系</li></ul><p>![]<a href="http://p0bl99g4r.bkt.clouddn.com/exception.PNG" target="_blank" rel="noopener">http://p0bl99g4r.bkt.clouddn.com/exception.PNG</a>)</p><p>如图 <code>Throwable</code> 是所有错误和异常的父类，一切皆可抛，说的就是他老人家。他的两个子类，<code>Error</code>和<code>Exception</code>。说一句，当你的程序出现了 <code>Error</code> 说明你中奖了，<code>Error</code> 指的是合理应用程序不应该去捕获的严重问题，问题很大，比如虚拟机崩溃之类的，出现<code>Error</code>这类问题没交给 JVM 吧，没有比他更专业的了。我们以下说的都是 <code>Exception</code> 中的内容。</p><ul><li>Exception </li></ul><p>它指出了合理的应用程序想要捕获的条件。Exception又分为两类：一种是CheckedException(受检异常)，一种是UncheckedException(非受检异常)。这两种Exception的区别主要是CheckedException需要用try…catch…显示的捕获UncheckedException不需要捕获。<strong>通常UncheckedException又叫做RuntimeException</strong>。</p><blockquote><p>于可恢复的条件使用被检查的异常（CheckedException），对于程序错误（言外之意不可恢复，大错已经酿成）使用运行时异常（RuntimeException）。—— 《effective java》</p></blockquote><p>我们常见的RuntimeExcepiton有IllegalArgumentException、IllegalStateException、NullPointerException、IndexOutOfBoundsException等等。对于那些CheckedException就不胜枚举了，我们在编写程序过程中try…catch…捕捉的异常都是CheckedException。io包中的IOException及其子类，这些都是CheckedException。</p><ul><li>非受查异常(UncheckedException)</li></ul><p>有一句话说的特别好，所有的 <code>RuntimeException</code> 都是程序员的问题。的确，当出现空指针、数组越界这些不需要被处理的问题，一定是我们的逻辑部分有问题。这类异常 Java编译器 并不会检查它，程序中可能出现这类异常，即使没有用try-catch语句捕获它，也没有用throws子句声明抛出它，也会编译通过。事实上我并不喜欢 <code>RuntimeException</code> 这种说法，因为所有的异常不都是发生运行时吗？</p><ul><li>受查异常(CheckedException)</li></ul><p>序语法角度讲是必须进行处理的异常，如果不处理，程序就不能编译通过。如IOException、SQLException等以及用户自定义的Exception异常，<strong>一般情况下不自定义检查异常</strong>。</p><h3 id="1.3">1.3 Java处理异常手段</h3><p>起初这里真的不想说太多，毕竟主题是优雅的处理异常，闲的无聊打开了《Java核心技术》看了一圈，默默的添加上了这一小节，学无止境…这里说的 Java处理异常的手段，大体上来讲就两种，抛出 和 捕获。　</p><h3 id="1.3.1">1.3.1 Java抛出异常 throw、throws</h3><p>英语好的同学可能一眼就能瞧出上面的两个英文啥意思，抛！这两种抛的方式都是消极处理异常的方式，注意这里的消极并不是一个贬义词。</p><ul><li>throw</li></ul><p>说实话，学习Java不到两年，这个 throw 用到的次数真的是用一个手都能数的过来。因为 throw 一般会用于程序出现某种逻辑时程序员主动抛出某种特定类型的异常。这就很尴尬了，我的编程习惯往往是通过逻辑判断去避免异常，怪不得我没怎么用到这个大兄弟。当然，Java设计者给咱们提供了，他就一定是有用的！</p><ul><li>throw 的用法:在方法体中通过逻辑判断，主动抛出特定类型的<strong>异常对象</strong>！注意异常对象这四个字！</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) throws NumberFormatException&#123;  </span><br><span class="line">        String s = &quot;abc&quot;;  </span><br><span class="line">        if(s.equals(&quot;abc&quot;)) &#123; </span><br><span class="line">//抛出一个异常对象 </span><br><span class="line">            throw new NumberFormatException();  </span><br><span class="line">        &#125; else &#123;  </span><br><span class="line">            System.out.println(s);  </span><br><span class="line">        &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的这段代码，是我随便在网上copy的。目的就是举个例子，你可以看到抛出一个异常非常的简单，首先找到一个合适的异常类，然后创建这个异常类的对象(new)，最后抛出。需要说明的是，<strong>一旦这个异常抛出了，当前的这个方法也就终止了，即这个方法没有执行完</strong>。这是一句非常重要的结论！因为，在以后学习 <strong>事务</strong> 这个很重要的知识点时，一个很重要的环节就是用到了 throw ，来决定这个方法是否执行成功。所以，throw 并不是用不到哟~</p><ul><li>throws </li></ul><p>说完了 throw，再来聊一聊 throws 。这个 throws 很常用，不同于 throw 出现在方法体，throws 出现在方法声明。意思也很简单，就是把<strong>方法中可能出现的受查异常，通过 throws 抛出，交给上一级处理</strong> 。具体例子就不贴了，说一下 throws 的规范使用姿势。</p><blockquote><p>1) 我们不必将所有可能出现的异常都抛出，如非受查异常，因为这些异常要么根本不可控要么都可以在我们的逻辑判断下避免。<br>2) 当你调用一个受查异常的方法，如 FileInputStream 的构造器，可以抛出异常。<br>3) 程序运行中发现错误，方法体中利用 throw 抛出了某种异常，使用 throws 在方法声明处将其抛出交给上层处理。如上面throw用法的代码。<br>4) 子类如果覆盖了父类中的方法，子类方法中声明的受查异常不能比父类方法声明的更通用。如父类抛了一个IOException，子类不能抛出 IOException 的父类 Exception 。<br>5) 如果父类方法没有抛出受查异常，那么子类方法也不可以抛出受查异常。</p></blockquote><h3 id="1.3.2">1.3.2 Java捕获异常</h3><p>首先来看一句情话</p><blockquote><p>世界上最真情的相依，是你在try我在catch。无论你发什么脾气，我都默默承受，静静处理。 大多数新手对java异常的感觉就是：try…catch…。没错，这是用的最多的，也是最实用的。</p></blockquote><p>try…catch… 遇到的可能比 throws 还要多，不想科普太多，简单的说一下个人理解。 </p><ul><li>catch 你真的会用吗</li></ul><p>很长一段时间，我照着视频生硬的在 catch 下面使用 Thrwoable.printStackTrace() 将异常信息打印到控制台。天真的认为，这是多么优秀简洁的代码呀！想想那时天真的自己真的是图样图森破，catch 就是对 try 块中的异常做出的处理，在调试阶段，我们当然可以通过控制台查看异常信息，看看到底是哪里出了问题。可是如果项目发布了，交给用户使用，这是程序捕获异常，你会让他去控制台看看到底出了啥问题？ 乃一物~~ <strong>所以我们可以在 catch 块中做的很多，因为一旦到了 catch 块中，try 里面的代码就不会被执行了！</strong> 举一个 JavaWeb 的例子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">//以下是伪代码，场景也可不太严谨，仅仅举个例子</span><br><span class="line"></span><br><span class="line">try&#123;</span><br><span class="line"></span><br><span class="line">//获取前台用户上传的文件 userFile</span><br><span class="line">balabalabala...</span><br><span class="line"></span><br><span class="line">// readExcel方法可以读取 Excel 格式文件，如果不是 Excel 格式抛出 IOException  </span><br><span class="line">readExcel(userFile);</span><br><span class="line"></span><br><span class="line">&#125;catch(IOException e)&#123;</span><br><span class="line"> </span><br><span class="line">//用户传来的不是 Excel 格式文件，捕获该异常,给用户提示</span><br><span class="line"></span><br><span class="line">request.setattrabute(&quot;msg&quot;,&quot;请检查您上传文件格式&quot;);</span><br><span class="line"></span><br><span class="line">//当然，我们还要删除用户上传的文件</span><br><span class="line">userFile.delete();</span><br><span class="line"></span><br><span class="line">//转发到用户刚才的页面</span><br><span class="line">request.getRequestDispatcher(&quot;xxxx.html&quot;).forward(request,response);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>try-catch-finally</li></ul><p>try-catch-finally ，无论有没有捕获到异常，finally块中的代码都会被执行。很好理解的概念，可是很多教程都把这个问题讲的很复杂 。在 finally 中我们需要注意一点 <strong>不要在 finally 中将方法 return !</strong>因为这是一个非常危险的操作，他会覆盖原有的返回值。</p><p>一个很常见的操作就是在 finally 中关闭资源，举个常见写法的例子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">InputStream in = ...;</span><br><span class="line"></span><br><span class="line">try&#123;</span><br><span class="line">balabalabala...</span><br><span class="line">&#125;catch(IOException e)&#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">//在 finally 中关闭资源</span><br><span class="line">&#125;finally&#123;</span><br><span class="line"></span><br><span class="line">try&#123;</span><br><span class="line">in.close;</span><br><span class="line">&#125;catch(IOException e)&#123;</span><br><span class="line">     e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>try-with-resourse</li></ul><p>上面的代码确实会在 finally 中会关闭输入流，但是有没有觉得很奇怪和臃肿，在关闭 输入流 时还要对 IOException 进行捕获。这简直太不优雅了！强大的Java 开发者在 <strong> Java SE 7 的版本中 引入了 try-with-resourse </strong>。上面的带码可以简化成这个样子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">File file = new File(&quot;D:\\1.txt&quot;);</span><br><span class="line">File file1 = new File(&quot;D:\\2.txt&quot;);</span><br><span class="line">try(InputStream inputStream = new FileInputStream(file)</span><br><span class="line">OutputStream outputStream = new FileOutputStream(file1))&#123;</span><br><span class="line">balabalabala</span><br><span class="line">&#125; catch (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你或许会说，这并没有关闭资源啊。别急，<strong>事实上当一个资源 实现了 AutoCloseable接口 或者 Closeable 接口，并实现了 close() 方法，在 try 块退出时，就会自动调用该资源的 close()，无论正常退出或者存在异常</strong>。 当然，这个方法或许不是一本万利，接口中的 close 方法也会抛出异常，就是说 close 抛出的异常会被压制，并被自动捕获，添加到下面的 catch 块中的异常中。但是如果你想要你的代码更加高级，优雅这种方式绝对是一个加分项。</p><h2 id="2">2. 优雅的处理异常</h2><p>优雅的处理异常，多么优雅的主题。事实上异常机制的处理有太多争论了，就像开头说的我们都在有意无意的去逃避异常。这一节，我总结了书上的理论，和编程中的一点体验去说一下关于异常的处理。</p><ul><li>1.异常处理不能代替逻辑判断</li></ul><p>看个例子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//逻辑判断</span><br><span class="line">String param = ....;</span><br><span class="line">if(param != null)</span><br><span class="line">System.out.print(param);</span><br><span class="line"></span><br><span class="line">//错误示范</span><br><span class="line">try&#123;</span><br><span class="line"></span><br><span class="line">String param = ....;</span><br><span class="line">System.out.print(param);</span><br><span class="line"></span><br><span class="line">&#125;catch(Exception e)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或许你会说，直接用 try…catch 去捕获这个空指针异常省的自己去判断，大错特错！《Java核心技术Ｉ》里面写的清楚明白，相比于简单的测试，异常处理会消耗大量的时间。<strong>我们只在异常的情况下使用异常！</strong></p><ul><li>2.不要过分细化异常</li></ul><p>不要将每一条语句分别装在一个独立的 try 语句块中。使用多个 catch 去捕获一个 try 块中的异常。例子就不举了。</p><ul><li>3.利用异常的层次结构</li></ul><p>跟我读三遍，Java异常是对象X3！异常和其他 Java对象一样，也有自己的方法，自己的爸爸和儿子，所以在捕获异常时不要用一个 Exception 或者 Throwable 一夫当关万夫莫开。选择使用哪种正确类型异常对程序的可读性很有必要。</p><ul><li>4.不要放任异常</li></ul><p>如果你捕获异常，那请你在 catch 块中做点什么吧！</p><ul><li>5.不要羞于异常的传递</li></ul><p>我记得在我刚开始编程时，我认为那些看到异常就往外抛的行为真的是不负责任，你有错误都不改正！实际上，当然还是我天真！我记得我说过，所谓的架构师就是把问题甩给别人…我们在底层（这里指被调用层）编写出来带异常的的方法，往往不知道该如何正确处理，过早的处理调用者就无法把错误消息传给更高级，所以，异常该抛就抛吧！</p><ul><li>6.不要不捕获异常（注意是个双重否定）</li></ul><p>第5点说让我们放下顾虑，勇敢的抛出异常，那是不是一直抛到最上层的调用者，然后最上层也把它抛出去？当然不是！要找到最恰当的时机去捕获，去做一些处理。</p><ul><li>7.捕获异常的时机</li></ul><p>什么时机才是捕获异常的大好时机？要看你的具体需求，如果你想在出现异常时给用户一些提示信息，那就要在最上层或者次上层捕获。如果你在测试阶段，想做一个判断，在异常出现时打印一句话，那就直接在异常出现的地方捕获。</p><ul><li>8.出现异常时对用户要友好</li></ul><p>当程序出现异常，在测试阶段会导致程序不能正常运行。已发布的项目，要是也按照这个套路来，程序终止了，留在用户在那里一脸懵逼，这就是程序员的噩梦，说明你没有考虑到异常出现时要怎样给用户一个交代！</p><ul><li>9.配合日志</li></ul><p>如果项目（JavaWeb）发布到了tomcat上面，那tomcat上的log日志会记录这个程序的运行状态，出现异常可以日志上面的记录的信息去查看哪里出了问题。如果项目没有发布在 tomcat ，可以使用一些日志框架如 log4j ，将每次出现异常的情况打印在上面。</p><ul><li>补充：对于非受查异常使用逻辑判断去代替异常的捕获</li></ul><p>在网上经常看到一些讲解异常的博客，出现用 try…catch 去捕获非受查异常这种奇葩例子（比如不会空指针，数组越界），看的我很难受！<strong>不要让程序的性能为你的逻辑错误而买单！</strong>获取参数时先判断是否为空，遍历数组时考虑一下数组下标！</p><h2 id="3">3. 结语</h2><p>浅谈了 Java 异常机制，还有好多没总结到，比如自定义异常类，异常对象的方法，异常链（确实不想了解）等等，就瞎写到这里吧。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; class=&quot;headerlink&quot; title=&quot;目录&quot;&gt;&lt;/a&gt;目录&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#0&quot;&gt;0. 写在前面&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#1&quot;&gt;1. 掀起Java异常的裙子来&lt;/
      
    
    </summary>
    
    
      <category term="JavaSE" scheme="http://yoursite.com/tags/JavaSE/"/>
    
  </entry>
  
  <entry>
    <title>初识bash</title>
    <link href="http://yoursite.com/2017/12/11/%E5%88%9D%E8%AF%86bash/"/>
    <id>http://yoursite.com/2017/12/11/初识bash/</id>
    <published>2017-12-11T11:19:19.000Z</published>
    <updated>2017-12-13T10:50:27.779Z</updated>
    
    <content type="html"><![CDATA[<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li><a href="#1">1. shell</a><ul><li><a href="#1.1">1.1 what</a></li><li><a href="#1.2">1.2 why</a></li><li><a href="#1.3">1.3 Linux中的shell</a></li></ul></li><li><a href="#2">2. bash</a><ul><li><a href="#2.1">2.1 bash的功能</a></li><li><a href="#2.2">2.2 bash的内置命令</a></li></ul></li><li><a href="#3">3. 变量</a><ul><li><a href="#3.1">3.1 what &amp; why</a></li><li><a href="#3.2">3.2 how</a></li><li><a href="#3.3">3.3 环境变量的功能</a></li><li><a href="#3.4">3.4 变量的有效范围</a></li><li><a href="#3.5">3.5 变量的键盘读取</a></li><li><a href="#3.6">3.6 变量内容的删除、替代、替换</a></li></ul></li><li><a href="#4">4. 命令别名与历史命令</a><ul><li><a href="#4.1">4.1 命令别名alias</a></li><li><a href="#4.2">4.2 历史命令history</a></li></ul></li><li><a href="#5">5. Bash Shell 的环境操作</a><ul><li><a href="#5.1">5.1 bash 的环境配置文件</a><ul><li><a href="#5.1.1">5.1.1 login shell 读取文件介绍</a></li><li><a href="#5.1.2">5.1.2 non-login shell 读取文件介绍</a></li></ul></li><li><a href="#5.2">5.2 bash 操作与通配符</a></li><li><a href="#5.2.1">5.2.1 bash默认组合键</a></li><li><a href="#5.2.2">5.2.2 通配符与特殊符号</a></li></ul></li><li><a href="#6">6. 总结</a></li></ul><h2 id="id">1. shell</h2><p>Shell 是个什么东西？接触了 Linux 后总能听到有人 Shell来Shell去，英文里面 shell 是蛋壳的意思，当你了解了 Linux下shell 的含义，你会觉得很贴切。</p><h3 id="1.1">1.1 what</h3><ul><li>系统软件与硬件的关系</li></ul><p>众所周知，没有软件的计算机只会滋滋放电，<strong>操作系统就是一组软件，计算机的硬件想要工作，需要操作系统对硬件进行管理</strong>。操作系统<strong>通过内核(kernel)对硬件进行管理</strong>。</p><ul><li>应用软件如何工作</li></ul><p>当你打开你的音乐软件听歌时，计算机的音响会发出声音，那是不是普通的应用软件也可以对硬件进行操作呢？<strong>当然不是! 如果任意软件都可以对硬件直接进行操作，那你的计算机早就炸了！</strong> 我们平时用的应用软件则是在操作系统上运行的，比如你经常听到某某软件的Windows版本，Linux版本。上面说到唯一可以与硬件通信的是系统的内核(kernel)，<strong>所以应用软件工作时，首先会和系统的内核进行沟通(把用户传来的指令发给内核)，在由内核对计算机硬件进行控制</strong>。</p><p><em>其实在这里我就已经把 shell 的含义说出来了，shell 就是让用户用来操作应用程序的方式，比如命令行、图形桌面等等，通过 shell 去对你的应用软件进行操作，软件与内核沟通，内核对硬件进行控制，如果把硬件比作蛋黄，那么最外层的shell不就正是蛋壳吗?</em></p><ul><li>shell 的种类</li></ul><p>shell是用来操作应用程序的，所以广义上来说只要是可以操作应用程序的接口(方法)，都可以叫他 shell（<strong>命令行，图形界面都是广义上的 shell</strong>）。<strong>狭义上的 shell 指的就是命令行上操作程序的接口 ，比如bash</strong>。</p><p><em>如果不做注释，下面所有出现的 shell 指的都是狭义上的。</em></p><h3 id="1.2">1.2 why</h3><p>有没有想过为打开 Linux(不限发行版本) 的各种教材，几乎全部都是让我们在 shell 下进行操作，为什么呢？因为重要被！有下面几点原因</p><ul><li>1.一致性</li></ul><p>习惯了 Winodws系统的人很难去让他摆弄命令行，下意识会使用Linux的图形界面，但是 Linux 与 Windows 很大的不同是 Linux 发行版本众多，不是每个发行版本的图形界面都一个德性（样子）的，比如我的ubuntu就比 centOS 界面美观，所以不同的发行版本界面风格和界面操作是不一样的，但是<strong>每个Linux的发行版本使用的 shell 几乎都是一样的，当你把shell玩转了,轻轻松松切换各种发行版本</strong>！</p><ul><li>2.速度快</li></ul><p>市面上流行的服务器几乎都是Linux系统，当你远程控制服务器时，考虑到网络网络延迟、连接稳定等原因，你一会选择速度更快更稳定的shell来操作你的远程主机，而不是图形界面。</p><ul><li>3.shell是Linxu的精髓</li></ul><p>使用 shell，你会对 Linux 的原理更加透彻，让你对自己Linux主机有充分的主动权！<strong>shell 才是 Linux 的精髓之所在</strong>！</p><h3 id="1.3">1.3 Linux中的shell们</h3><p>注意到小标题有一个“们”，shell 的旗下的小弟有很多，这里就不一一列举了(向写出这些shell的革命前辈献上膝盖)。<strong>你可以通过 /etc/shells 查看你的Linux中支持多少种shell</strong>。我的虚拟机中支持四种：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">dombro@ubuntu:~$ cat /etc/shells</span><br><span class="line"># /etc/shells: valid login shells</span><br><span class="line">/bin/sh</span><br><span class="line">/bin/dash</span><br><span class="line">/bin/bash</span><br><span class="line">/bin/rbash</span><br></pre></td></tr></table></figure><p>Linux 中每个用户使用的shell不一定相同，可以通过 /etc/passwd 文件查看每个用户登陆后使用的shell,看最一个数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dombro:x:1000:1000:ubuntu,,,:/home/dombro:/bin/bash</span><br><span class="line">dongbo:x:1001:1002:,,,:/home/dongbo:/bin/bash</span><br></pre></td></tr></table></figure><p><strong>Linxu下面默认的 shell 是 /bin/bash</strong>！</p><h2 id="2">2. bash</h2><p>/bin/bash 是Linxu默认的shell，有必要去了解一下,我暂时还真的没接触过别的…</p><h3 id="3">2.1 bash的功能</h3><p>说是功能，不如说是优点。bash 主要有下面这几种优点</p><ul><li>1.命令记忆功能(history)</li></ul><p>估计所有玩过Linux的人都会说这是一个相当棒的功能，在命令行中按上下键就可以找到前后输入的命令。有没有觉得很神奇？事实上，你上一次登录状态下的所有命令都会被记在用户主文件夹下的.bash_history中，像这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">dombro@ubuntu:~$ cat .bash_history</span><br><span class="line">cd /home/</span><br><span class="line">cd /usr</span><br><span class="line">history</span><br><span class="line">alias</span><br><span class="line">tee --help</span><br><span class="line">who</span><br><span class="line">who | tee who.out</span><br><span class="line">cat who.out</span><br><span class="line">bind -p</span><br><span class="line">vim who.out</span><br><span class="line">vim --help</span><br><span class="line">vi --help</span><br><span class="line">vim --help</span><br></pre></td></tr></table></figure><p>而本次的登录时的命令会被保存在内存中，退出时，这些在内存中的历史命令被写入~.bash_history文件中。但是这样一来也有一个坏处，如果你的主机被攻击了，黑客可以很轻松的获得你曾经执行过的敏感命令（密码输入），所以将记录命令的数目减少点~<a href="#4.2">具体的历史命令在4.2小节查看</a></p><ul><li>2.命令与文件补齐(tab)</li></ul><p>别跟我说你没用过这个功能，在实际输入命令或者文件名时一定要多多使用[tab]，来让bash自动的帮你补齐，省时省力！举个例子：把所有c开头的命令显示出来</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">dombro@ubuntu:~$ c[tab][tab]</span><br><span class="line">Display all 122 possibilities? (y or n)</span><br><span class="line">c++                        column</span><br><span class="line">c2ph                       combinediff</span><br><span class="line">c89                        comm</span><br><span class="line">c89-gcc                    command</span><br><span class="line">c99                        command_not_found_handle</span><br><span class="line">c99-gcc                    compare</span><br><span class="line">cal                        compare-im6</span><br><span class="line">calendar                   compgen</span><br><span class="line">calibrate_ppa              compiz</span><br><span class="line">caller                     compiz-decorator</span><br><span class="line">canberra-gtk-play          complete</span><br><span class="line">下面省略</span><br></pre></td></tr></table></figure><ul><li>3.命令别名的设置(alias)</li></ul><p>试一下直接输入<code>ll</code>命令，会不会显示出文件夹下文件的信息？实际上 Linxu 下面并没有 <code>ll</code> 这个命令啦，<code>ll</code>只是一个命令的别名，如果你嫌命令太长不好记，可以把命令设置别名像这样</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alias command=&apos;alias_command&apos;</span><br></pre></td></tr></table></figure><p>如果你想知道你设置了哪些别名直接在命令行下<code>alias</code>就好</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">dombro@ubuntu:~$ alias</span><br><span class="line">alias alert=&apos;notify-send --urgency=low -i &quot;$([ $? = 0 ] &amp;&amp; echo terminal || echo error)&quot; &quot;$(history|tail -n1|sed -e &apos;\&apos;&apos;s/^\s*[0-9]\+\s*//;s/[;&amp;|]\s*alert$//&apos;\&apos;&apos;)&quot;&apos;</span><br><span class="line">alias egrep=&apos;egrep --color=auto&apos;</span><br><span class="line">alias fgrep=&apos;fgrep --color=auto&apos;</span><br><span class="line">alias grep=&apos;grep --color=auto&apos;</span><br><span class="line">alias l=&apos;ls -CF&apos;</span><br><span class="line">alias la=&apos;ls -A&apos;</span><br><span class="line">alias ll=&apos;ls -alF&apos;</span><br><span class="line">alias ls=&apos;ls --color=auto&apos;</span><br></pre></td></tr></table></figure><p><a href="#4.2">具体的命令别名在4.1小节查看</a></p><ul><li>4.程序脚本(shell script)</li></ul><p>有没有经常听说脚本文件这个词？Linxu下的shell脚本程序可以做更多的事！</p><ul><li>5.通配符(wildcard)</li></ul><p>你一定是用过 *、%等通配符！这也是bash为我们提供的！</p><h3 id="2.2">2.2 bash的内置命令</h3><p>上面说，我们在 shell 下面通过命令操作应用程序，那是不是所有命令都是来自于应用程序？absolutely not！为了方便 shell 操作(感觉可以提高性能)，bash 为我们内置了许多命令比如 cd、umask..</p><ul><li>使用 type 命令</li></ul><p>使用 type 命令可以告诉我们这个命令是不是 一个bash内置命令 ！用法：<code>type [-tpa] command</code>。例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">dombro@ubuntu:~$ type ll</span><br><span class="line">ll is aliased to `ls -alF&apos;</span><br><span class="line">#当你看到 alias字眼 意味着这个命令是一个别名</span><br><span class="line">dombro@ubuntu:~$ type java</span><br><span class="line">java is /usr/java/jdk1.8.0_144/bin/java</span><br><span class="line">#当你看到 一串绝对路径 证明这个命令是一个外部命令</span><br><span class="line">dombro@ubuntu:~$ type cd</span><br><span class="line">cd is a shell builtin</span><br><span class="line">#当你看到 builtin 证明这个命令是一个内置命令</span><br><span class="line"></span><br><span class="line">#使用 -t 选项 ： 会直接返回一个单词告诉你这个命令的意义</span><br><span class="line">dombro@ubuntu:~$ type -t cd</span><br><span class="line">builtin</span><br><span class="line">dombro@ubuntu:~$ type -t java</span><br><span class="line">file</span><br><span class="line">dombro@ubuntu:~$ type -t ll</span><br><span class="line">alias</span><br><span class="line"></span><br><span class="line">#使用 -p 选项 ： 只有 command 为外部命令时才会显示完整文件名</span><br><span class="line">dombro@ubuntu:~$ type -p ls</span><br><span class="line">#什么都没显示，说明 ls 是一个内置命令</span><br><span class="line">dombro@ubuntu:~$ type -p java</span><br><span class="line">/usr/java/jdk1.8.0_144/bin/java</span><br><span class="line"></span><br><span class="line">#使用 -a 选项 : 由 PATH 变量定义的路径中，将所有 command 的命令都列出来，包含 alias别名</span><br><span class="line">dombro@ubuntu:~$ type -a ls</span><br><span class="line">ls is aliased to `ls --color=auto&apos;</span><br><span class="line">ls is /bin/ls</span><br><span class="line">#PATH中的ls</span><br></pre></td></tr></table></figure><p>type除了可以判断我们知道的命令是不是内置命令，还有一个作用，type只会寻找可以被执行的文件，即 type 在于找出可执行文件。</p><h2 id="3">3. 变量</h2><p><em>变量是 bash 中非常重要的东西</em>！</p><h3 di="3.1">3.1 what&amp;why</h3><p>Linux 下的变量和程序语言所说的变量在定义上几乎差不多，都是用一个固定串去表示一个不固定的内容。就是用一个简单的字眼代替一个容易变动的数字！</p><ul><li>方便操作的变量</li></ul><p>我们都知道 Linux 是多用户的，多任务的环境，每个人登陆后都会获取一个shell 。上面提到了，每个人的 shell 可能是不同的，有可能 用户1的shell 是bash，用户2的shell就是csh，系统如何去判断呢？是每次用户登录都会读取 /etc/passwd？ 我想不是这样的，每个用户使用的 shell 类型(文件)记录在一个叫 <code>SHELL</code> 的变量中，比如当我以主用户登录时 <code>SHELL</code> 中的值就是 <code>/bin/bash</code> ，系统则直接读取这个 <code>SHELL</code> 变量就好了。<strong>是不是有点类似程序语言中通过条件判断，为一个变量取不同值呢？</strong></p><p><em>更方便的变量操作还有 MAIL ，邮件操作当你执行 <code>mail</code> 这个命令时，根据用户不同 <code>MAIL</code> 变量的值为对应用户邮件目录，所以你才会准确无误的获取到你的邮件，而不需要知道你邮件的具体地址</em>。</p><ul><li>影响 bash 环境操作的变量</li></ul><p>你肯定听过 <code>PATH变量</code> 这个词。可不可以在任意目录下执行某个命令与 <code>PATH变量</code> 有很大的关系，系统就是通过 PATH 这个变量记录的路径去查找命令的。<br>说的明白点，上面举的<code>SHELL</code>的例子、<code>MAIL</code>的例子，等等<strong>这些用来在用户登录之前（准确来说是进入shell之前）得到该用户的一些数据的变量就叫环境变量</strong>。常见的环境变量有 <code>PATH</code>、<code>SHELL</code>、<code>MAIL</code>、<code>HOME</code>等。</p><ul><li>脚本程序设计(shell script)的变量</li></ul><p>在脚本程序中同样可以使用变量，这个用法和编程时的用法是一样的。</p><h3 id="3.2">3.2 how</h3><ul><li>变量与变量代表的内容</li></ul><p>可以使用 <code>echo $变量名</code> 或 <code>echo ${变量名}</code> 的方式去查看变量的内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dombro@ubuntu:~$ echo $PATH</span><br><span class="line">/usr/java/jdk1.8.0_144/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin</span><br><span class="line">#&#123;变量名&#125;效果是一样的</span><br><span class="line">dombro@ubuntu:~$ echo $&#123;PATH&#125;</span><br><span class="line">/usr/java/jdk1.8.0_144/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin</span><br></pre></td></tr></table></figure><p>使用<code>=</code>来设置变量，举个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dombro@ubuntu:~$ myname=dombro</span><br><span class="line">dombro@ubuntu:~$ echo $myname</span><br><span class="line">dombro</span><br></pre></td></tr></table></figure><p><em>当变量未被设置是默认为空。</em></p><ul><li>变量设置规则</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">1．变量与变量内容以一个等号“=”来连接，如下所示：</span><br><span class="line">“myname=dombro”</span><br><span class="line">2．等号两边不能直接接空格符，如下所示为错误的：</span><br><span class="line">“myname=dombro”或“myname=dombro Tsai”</span><br><span class="line">3．变量名称只能是英文字母与数字，但是开头字符不能是数字，如下为错误的：</span><br><span class="line">“2myname=dombro”</span><br><span class="line">4．变量内容若有空格符可使用双引号“&quot;”或单引号“&apos;”将变量内容结合起来，但是</span><br><span class="line">双引号内的特殊字符如$等，可以保有原本的特性，如下所示：</span><br><span class="line">若“var=&quot;lang is $LANG&quot;”，则“echo $var”可得“lang is en_US”</span><br><span class="line">单引号内的特殊字符则仅为一般字符（纯文本），如下所示：</span><br><span class="line">若“ar=&apos;lang is $LANG&apos;”，则“echo $var”可得“lang is $LANG”</span><br><span class="line">5．可用转义字符“\”将特殊符号（如[Enter]、$、\、空格符、！等）变成一般字符。</span><br><span class="line">6．在一串命令中，还需要通过其他的命令提供的信息，可以使用反单引号“`命令`”或“$（命令）”。特别注意，那个是键盘上方的数字键 1 左边那个按键，而不是单引号。例如想要取得内核版本的设置：</span><br><span class="line">“version=$（uname-r）”再“echo $version”可得“2.6.18-128.el5”</span><br><span class="line">7．若该变量为了增加变量内容时，则可用&quot;$变量名称&quot;或$&#123;变量&#125;累加内容，如下所示：</span><br><span class="line">“PATH=&quot;$PATH&quot;:/home/bin”</span><br><span class="line">8．若该变量需要在其他子进程执行，则需要以export来使变量变成环境变量：</span><br><span class="line">“export PATH”</span><br><span class="line">9．通常大写字符为系统默认变量，自行设置变量可以使用小写字符，方便判断（纯粹依照用户兴趣与嗜好）。</span><br><span class="line">10．取消变量的方法为使用“unset变量名称”，例如取消myname的设置：</span><br><span class="line">“unset myname”</span><br></pre></td></tr></table></figure><ul><li>范例：让变量用在下个shell程序</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">dombro@ubuntu:~$ name=dombro</span><br><span class="line">dombro@ubuntu:~$ echo $name</span><br><span class="line">dombro</span><br><span class="line">dombro@ubuntu:~$ bash</span><br><span class="line">#进入到子进程</span><br><span class="line">dombro@ubuntu:~$ echo $name</span><br><span class="line">#并没有出现在原进程中设置的变量值</span><br><span class="line">dombro@ubuntu:~$ exit</span><br><span class="line">#退出该进程</span><br><span class="line">exit</span><br><span class="line">dombro@ubuntu:~$ export name</span><br><span class="line">#使用 export</span><br><span class="line">dombro@ubuntu:~$ bash</span><br><span class="line">dombro@ubuntu:~$ echo $name</span><br><span class="line">#再次进入子进程，查看name变量，出现了变量值</span><br><span class="line">dombro</span><br></pre></td></tr></table></figure><ul><li>范例：双引号与单引号的区别</li></ul><p>双引号与单引号的区别在于，双引号可以保留变量内容，而单引号则是一般字符</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">dombro@ubuntu:~$ myname=&quot;$name is me&quot;</span><br><span class="line">dombro@ubuntu:~$ echo $myname</span><br><span class="line">dombro is me</span><br><span class="line">dombro@ubuntu:~$ myname=&apos;$name is me&apos;</span><br><span class="line">dombro@ubuntu:~$ echo $myname</span><br><span class="line">$name is me</span><br></pre></td></tr></table></figure><ul><li>范例：反单引号 ` 的作用</li></ul><p>在一串命令中，在 ` 内的命令将会被先执行，而其执行出来的结果将作为外部的输入信息。下面例子将进入用户目前内核的模块目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dombro@ubuntu:~$ cd /lib/modules/`uname -r`/kernel</span><br><span class="line">dombro@ubuntu:/lib/modules/4.4.0-98-generic/kernel$</span><br><span class="line"></span><br><span class="line">#其实上面的做了两个操作，首先进行反单引号内的 uname -r 得到内核版本 4.4.0-98-generic ，再将该结果带入cd命令。</span><br></pre></td></tr></table></figure><p>实际上使用括号() 来代替 ` 比较好，因为反单引号太容易看错了。</p><h3 id="3.3">3.3 环境变量的功能</h3><p>上面说环境变量在我们未进入shell程序之前被读取，环境变量可以帮助我们完成很多功能，我们可以通过 <code>env</code> 和 <code>export</code>来查看所有的环境变量。</p><ul><li>使用 env 查看环境变量</li></ul><p>在你的 Linux 的 bash 中输入 env，会把你所有的环境变量都列出来。是在是太多了，就不把我的贴上来了，简单介绍几个常见的环境变量。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">HOME</span><br><span class="line">代表用户的主文件夹。还记得我们可以使用cd～去到自己的主文件夹吗？或者利用cd就可以直接回到用户主文件夹了。那就是使用这个变量，有很多程序都可能会用到这个变量的值。</span><br><span class="line">SHELL</span><br><span class="line">它告知我们目前这个环境使用的shell是哪个程序？Linux默认使用/bin/bash的。</span><br><span class="line">HISTSIZE</span><br><span class="line">这个与“历史命令”有关，即是我们曾经执行过的命令可以被系统记录下来，而记录的“条数”则是由这个值来设置的。</span><br><span class="line">MAIL</span><br><span class="line">当我们使用mail这个命令在收信时系统会去读取的邮件信箱文件（mailbox）。</span><br><span class="line">PATH</span><br><span class="line">就是执行文件查找的路径，目录与目录中间以冒号（:）分隔，由于文件的查找是依序由PATH的变量内的目录来查询，所以目录的顺序也是重要的。</span><br><span class="line">LANG</span><br><span class="line">这个重要。就是语系数据，很多信息都会用到它。举例来说，当我们在启动某些Perl的程序语言文件时，它会主动去分析语系数据文件，如果发现有它无法解析的编码语系，可能会产生错误。一般来说，我们中文编码通常是 zh_CN.gb2312 或者是 zh_CN.UTF-8，这两个编码偏偏不容易被解译出来，所以有的时候，可能需要修改一下语系数据。这部分我们会在下个小节做介绍的。</span><br><span class="line">RANDOM</span><br><span class="line">这是“随机数”的变量。目前大多数的distributions都会有随机数生成器，那就是/dev/random这个文件。我们可以通过这个随机数文件相关的变量（$RANDOM）来随机取得随机数值。在BASH 的环境下，这个 RANDOM 变量的内容介于 0～32767 之间，所以你只要 echo$RANDOM时，系统就会主动随机取出一个介于0～32767的数值。万一我想要使用0～9之间的数值呢？利用declare声明数值类型，然后这样做就可以了：</span><br><span class="line">[root@www ～]# declare -i number=$RANDOM*10/32768 ; echo $number</span><br><span class="line">8 &lt;== 此时会随机取出 0～9 之间的数值。</span><br><span class="line">大致上是有这些环境变量，里面有些比较重要的参数，在下面我们都会另外进行一些说明的。</span><br></pre></td></tr></table></figure><ul><li>使用 set 查看所有变量</li></ul><p>Linux 下面不止有环境变量，上面我们自己还定义了几个变量，那要如何去查看？就可以使用 <code>set</code> 这个命令。<code>set</code> 命令可以查看包括环境变量、还有与 bash 操作接口有关的变量，以及用户自定义的变量。只要使用 set</p><p>列举几个重要的变量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">dombro@ubuntu:~$ set</span><br><span class="line">BASH=/bin/bash</span><br><span class="line">BASH_VERSION=&apos;4.3.48(1)-release&apos;</span><br><span class="line">COLUMNS=80</span><br><span class="line">BASH=/bin/bash &lt;== bash 的主程序放置路径</span><br><span class="line">BASH_VERSINFO=（[0]=&quot;3&quot; [1]=&quot;2&quot; [2]=&quot;25&quot; [3]=&quot;1&quot; [4]=&quot;release&quot;</span><br><span class="line">[5]=&quot;i686-redhat-linux-gnu&quot;） &lt;== bash 的版本。</span><br><span class="line">BASH_VERSION=&apos;3.2.25（1）-release&apos; &lt;== 也是 bash 的版本。</span><br><span class="line">COLORS=/etc/DIR_COLORS.xterm &lt;== 使用的颜色记录文件</span><br><span class="line">COLUMNS=115 &lt;== 在目前的终端机环境下，使用的字段有几个字符长度</span><br><span class="line">HISTFILE=/root/.bash_history &lt;== 历史命令记录的放置文件，隐藏文件</span><br><span class="line">HISTFILESIZE=1000 &lt;== 保存的（与上个变量有关）的文件命令的最大记录条数。</span><br><span class="line">HISTSIZE=1000 &lt;== 目前环境下可记录的历史命令最大条数。</span><br><span class="line">HOSTTYPE=i686 &lt;== 主机安装的软件主要类型。我们用的是 i686 兼容机器软件</span><br><span class="line">IFS=$&apos; \t\n&apos; &lt;== 默认的分隔符</span><br><span class="line">LINES=35 &lt;== 目前的终端机下的最大行数</span><br><span class="line">MACHTYPE=i686-redhat-linux-gnu &lt;== 安装的机器类型</span><br><span class="line">MAILCHECK=60 &lt;== 与邮件有关。每 60 秒去扫描一次信箱有无新信。</span><br><span class="line">OLDPWD=/home &lt;== 上个工作目录。我们可以用 cd - 来使用这个变量。</span><br><span class="line">OSTYPE=linux-gnu &lt;== 操作系统的类型。</span><br><span class="line">PPID=20025 &lt;== 父进程的 PID（会在后续章节才介绍）</span><br><span class="line">PS1=&apos;[\u@\h \W]\$ &apos; &lt;== PS1 就厉害了。这个是命令提示符，也就是我们常见的</span><br><span class="line">[root@www ～]# 或 [dmtsai ～]$ 的设置值。可以改动的。</span><br><span class="line">PS2=&apos;&gt; &apos; &lt;== 如果你使用转义符号（\） 第二行以后的提示符也可以被列出来。</span><br><span class="line">name=VBird &lt;== 刚才设置的自定义变量</span><br><span class="line">$ &lt;== 目前这个 shell 所使用的 PID</span><br><span class="line">? &lt;== 刚才执行完命令的回传码。</span><br><span class="line">一般来说，不论是否为环境变量，只要跟我们目前这个shell的操作接口有关的变量，通常都会被设置为大写字符，也就是说，基本上，在Linux默认的情况中，使用&#123;大写的字母&#125;来设置的变量一般为系统内定需要的变量。那么上面那些变量当中，有哪些是比较重要的？大概有这几个吧！</span><br><span class="line">PS1（提示符的设置）</span><br><span class="line">这是PS1（数字的1，不是英文字母），这个东西就是我们的“命令提示符”。当我们每次按下[Enter]按键去执行某个命令后，最后要再次出现提示符时，就会主动去读取这个变量值了。上面 PS1 内显示的是一些特殊符号，这些特殊符号可以显示不同的信息，每个 distributions的 bash 默认的 PS1 变量内容可能有些区别，你可以用 man bash 查询一下 PS1 的相关说明，以理解下面的一些符号意义。</span><br><span class="line">\d：可显示出“星期月日”的日期格式，如“Mon Feb 2”。</span><br><span class="line">\H：完整的主机名。举例来说，我练习机为“Ubuntun”。</span><br><span class="line">\h：仅取主机名在第一个小数点之前的名字，如主机为“www”，后面的省略。</span><br><span class="line">\t：显示时间，为24小时格式的“HH:MM:SS”。</span><br><span class="line">\T：显示时间，为12小时格式的“HH:MM:SS”。</span><br><span class="line">\A：显示时间，为24小时格式的“HH:MM”。</span><br><span class="line">\@：显示时间，为12小时格式的“am/pm”样式。</span><br><span class="line">\u：目前用户的账号名称，如“root”。</span><br><span class="line">\v：BASH的版本信息，如测试主版本为3.2.25（1），仅取“3.2”显示。</span><br><span class="line">\w：完整的工作目录名称，由根目录写起的目录名称。但主文件夹会以～替代。</span><br><span class="line">\W：利用basename函数取得工作目录名称，所以仅会列出最后一个目录名。</span><br><span class="line">\#：执行的第几个命令。</span><br><span class="line">\$：提示符，如果是root时，提示符为#，否则就是$。</span><br><span class="line">好了让我们来看看 CentOS 默认的 PS1 内容：[\u@\h \W]\$，现在你知道那些反斜杠后的数据意义了吧？要注意，那个反斜杠后的数据为 PS1 的特殊功能，与 bash 的变量设置没关系。不要搞混了。那你现在知道为何你的命令提示符是“[root@www～]#”了吧？好了，那么假设我想要有类似下面的提示符：</span><br><span class="line">[root@www /home/dmtsai 16:50 #12]#</span><br><span class="line">那个#代表第12次执行的命令。那么应该如何设置PS1呢？可以这样：</span><br><span class="line">[root@www ～ ]# cd /home</span><br><span class="line">[root@www home]# PS1=&apos;[\u@\h \w \A #\#]\$ &apos;</span><br><span class="line">[root@www /home 17:02 #85]#</span><br><span class="line"># 看到了吗？提示符...</span><br><span class="line"></span><br><span class="line">“$”本身也是个变量。这个代表的是目前这个Shell的线程代号，即是所谓的PID（Process ID）。更多的进程观念，我们会在第四部分的时候提及。想要知道我们的shell的PID，用“echo $$”即可，出现的数字就是你的PID号码。</span><br><span class="line">?（关于上个执行命令的回传码）</span><br><span class="line">问号也是一个特殊的变量？没错！在bash里面这个变量很重要。这个变量是上一个执行的命令所回传的值，上面这句话的重点是“上一个命令”与“回传值”两个地方。当我们执行某些命令时，这些命令都会回传一个执行后的代码。一般来说，如果成功执行该命令，则会回传一个0值，如果执行过程发生错误，就会回传“错误代码”才对。一般就是以非0的数值来替代。我们以下面的例子来说明：</span><br><span class="line">[root@www ～]# echo $SHELL</span><br><span class="line">/bin/bash &lt;==可顺利显示，没有错误。</span><br><span class="line">[root@www ～]# echo $?</span><br><span class="line">0 &lt;==因为没问题，所以回传码为 0</span><br><span class="line">[root@www ～]# 12name=VBird</span><br><span class="line">-bash: 12name=VBird: command not found &lt;==发生错误了，bash回报有问题</span><br><span class="line">[root@www ～]# echo $?</span><br><span class="line">127 &lt;==因为有问题，回传错误代码（非0）</span><br><span class="line"># 错误代码回传码依据软件而有不同，我们可以利用这个代码来找出错误的原因。</span><br><span class="line">[root@www ～]# echo $?</span><br><span class="line">0</span><br><span class="line">#怎么又变成正确了？这是因为“?”只与“上一个执行命令”有关，</span><br><span class="line"># 所以，我们上一个命令是执行“echo $? ”，当然没有错误，所以是 0 没错。</span><br><span class="line">OSTYPE，HOSTTYPE，MACHTYPE（主机硬件与内核的等级）</span><br></pre></td></tr></table></figure><ul><li>export 自定义变量转成环境变量</li></ul><p>在<a href="#3.2">3.2小节如何使变量用在下一个shell中</a>，其实我们已经使用了 <code>export</code> 这个命令，实际上在该例子中第二次输入的 <code>bash</code> 命令是一个子进程。有必要讲一下 Linux 执行命令的行为，<strong>当你登录 Linux 并取得一个 bash 后，你的 bash 就是一个独立的进程，被称为 PID 的就是。你在 bash 所执行的任何命令都是有这个 bash 衍生出来的，那些被执行的命令就被称为子进程了，最初的 bash 就叫做父进程</strong>。 为什么要了解这个概念？<strong>因为子进程会继承父进程的环境变量，但子进程不会继承父进程的自定义变量</strong>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dombro@ubuntu:~$ export 变量名称  </span><br><span class="line"># 可以把一个自定义变量变为环境变量</span><br></pre></td></tr></table></figure><p>如果 <code>export</code> 后面没有接任何参数，则会把所有的环境变量显示出来</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">declare -x CLASSPATH=&quot;.:/usr/java/jdk1.8.0_144/lib:/usr/java/jdk1.8.0_144/jre/lib&quot;</span><br><span class="line">declare -x CLUTTER_IM_MODULE=&quot;xim&quot;</span><br><span class="line">declare -x COMPIZ_CONFIG_PROFILE=&quot;ubuntu&quot;</span><br><span class="line">declare -x DBUS_SESSION_BUS_ADDRESS=&quot;unix:abstract=/tmp/dbus-c9fpv2E1HK&quot;</span><br><span class="line">....省略了很多</span><br></pre></td></tr></table></figure><h3 id="3.4">3.4 变量的有效范围</h3><p>咳咳，这是一段纯文字的内容。通过上面的环境变量与自定义变量，我们知道变量是有范围的。当程序之间出现父子进程的关系，则变量可否被引用与 export 有关。<strong>被 export 后的变量，我们可以称他为环境变量。环境变量可以被子进程引用，但是其他自定义的变量内容不会被子进程引用</strong>。有没有想过为什么？</p><p>当启动一个 shell ,操作系统会分配一块记忆块给shell使用，此内存内的变量可以被子进程取用。若在父进程利用export功能，可以让自定义变量写到上述的记忆块当中(环境变量)。当启动子进程时，子shell 可以将 父shell 环境变量所在的记忆块导入自己的环境变量块当中。</p><p><em>需要注意的是，这个环境变量与 bash的操作环境 意思不太一样，举例来说，PS1 并不是环境变量，但是这个 PS1 会影响到 bash的接口(命令提示符)</em></p><h3 id="3.5">3.5 变量的键盘读取</h3><p>上面说的变量都是直接定义的，<strong>变量还可以通过用户由键盘输入，还可以为变量声明属性，如数组或数字</strong>。</p><ul><li>read 命令 ： 读取来子键盘的输入</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@www ～]# read [-pt] variable</span><br><span class="line">参数：</span><br><span class="line">-p ：后面可以接提示符。</span><br><span class="line">-t ：后面可以接等待的“秒数。”这个比较有趣，不会一直等待用户。</span><br></pre></td></tr></table></figure><p>范例一 ：使用 read,由键盘输入变量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dombro@ubuntu:~$ read test</span><br><span class="line">hello   &lt;==== 我就是在这里输入的</span><br><span class="line">dombro@ubuntu:~$ echo $test</span><br><span class="line">hello</span><br></pre></td></tr></table></figure><p>范例二 ：给用户一些提示，并提供30秒的时间</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dombro@ubuntu:~$ read -p &quot;Please input your name&quot; -t 15 named</span><br><span class="line">Please input your name dombro</span><br><span class="line">dombro@ubuntu:~$ echo $named</span><br><span class="line">dombro</span><br></pre></td></tr></table></figure><p><em>read 之后不加任何参数，直接加上变量名称，那么下面就会主动出现一个空白行等待你的输入（如范例一）。如果加上-t后面接秒数，例如上面的范例二，那么30秒之内没有任何操作时，该命令就会自动略过了，如果是加上-p，在输入的光标前就会有比较多可以用的提示符给我们参考。在命令的执行里面，这样比较美观</em>。</p><ul><li>declare / typeset</li></ul><p>declare 和 typeset 具有相同的功能——声明变量类型。如果 declare 后面没有加任何参数，bash 会把所有比变量名称与内容调出，就好像set一样。下面是 declare 用法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@www ～]# declare [-aixr] variable</span><br><span class="line">参数：</span><br><span class="line">-a ：将后面名为 variable 的变量定义成为数组（array）类型</span><br><span class="line">-i ：将后面名为 variable 的变量定义成为整数数字（integer）类型</span><br><span class="line">-x ：用法与 export 一样，就是将后面的 variable 变成环境变量</span><br><span class="line">-r ：将变量设置成为 readonly 类型，该变量不可被更改内容，也不能重设</span><br></pre></td></tr></table></figure><p>范例一 ： 使用 -i 选项设置整型变量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dombro@ubuntu:~$ declare -i sum=100+200   </span><br><span class="line">dombro@ubuntu:~$ echo $sum</span><br><span class="line">300</span><br></pre></td></tr></table></figure><p>注意：<strong>所有变量默认的都是字符串类型，这里使用 -i 选项设置sum变量为整型变量，所以在 echo 时才会把 100+200 的整型结果显示出来</strong>。</p><p>范例二 ： 使用 -x 选项将 sum 变为环境变量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dombro@ubuntu:~$ declare -x sum   </span><br><span class="line">dombro@ubuntu:~$ env | grep sum</span><br><span class="line">sum=300</span><br></pre></td></tr></table></figure><p>范例三 ： 使用 -r 选项让 sum 变为只读属性，不可改动</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dombro@ubuntu:~$ declare -r sum</span><br><span class="line">dombro@ubuntu:~$ sum=121</span><br><span class="line">bash: sum: readonly variable</span><br></pre></td></tr></table></figure><p>范例四 ： 让 sum 变成非环境变量的自定义变量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dombro@ubuntu:~$ declare +x sum &lt;=== 将 - 变成 + 可以进行取消操作</span><br><span class="line">dombro@ubuntu:~$ declare -p sum &lt;=== -p 可以单独列出变量的类型</span><br><span class="line">declare -ir sum=&quot;300&quot;</span><br></pre></td></tr></table></figure><p>范例五 ： 使用 -a 选项声明数组</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">dombro@ubuntu:~$ declare -a names</span><br><span class="line">dombro@ubuntu:~$ names[0]=tom</span><br><span class="line">dombro@ubuntu:~$ names[1]=jim</span><br><span class="line">dombro@ubuntu:~$ names[2]=jack</span><br><span class="line">dombro@ubuntu:~$ echo $names[0],$names[1],$names[2]</span><br><span class="line">tom[0],tom[1],tom[2] &lt;=== 注意到并没有使用&#123;&#125;所以结果错误</span><br><span class="line">dombro@ubuntu:~$ echo $&#123;names[0]&#125;,$&#123;names[1]&#125;,$&#123;names[2]&#125;</span><br><span class="line">tom,jim,jack &lt;=== 出现正确结果</span><br></pre></td></tr></table></figure><p><strong>建议直接 ${数组}的方式来读取数组，会准确无误</strong>。</p><h3 id="3.6">3.6 变量内容的删除、替代、替换</h3><ul><li>变量内容的删除</li></ul><p>删除变量你可以使用 <code>unset</code> 命令，但你有想过如果想删除变量的部分内容怎么擦做吗？</p><p>首先你需要知道几个符号所表示的意义</p><blockquote><p># 表示从左往右(从前向后)，删除符合替换文字”最短的” 那一个<br>## 表示从左往右(从前向后)，删除符合替换文字”最长的” 那一个<br>* 表示通配符<br>% 表示从右向左(从后向前)，删除合替换文字”最短的” 那一个<br>%% 表示从右向左(从后向前)，删除合替换文字”最长的” 那一个</p></blockquote><p>范例一 ： 从左向右删除最短匹配串</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">dombro@ubuntu:~$ path=$&#123;PATH&#125;  &lt;=== 首先把 PATH 变量赋给 自定义的path</span><br><span class="line">dombro@ubuntu:~$ echo $path &lt;=== 查看一下</span><br><span class="line">/usr/java/jdk1.8.0_144/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin</span><br><span class="line">dombro@ubuntu:~$ echo $&#123;path#/*bin:&#125;</span><br><span class="line">&lt;=== path 代表要操作的变量</span><br><span class="line">&lt;=== # 代表从左向右删除最短</span><br><span class="line">&lt;=== /*bin: 则代表删除变量中最短的 &apos;/&apos; 到 &apos;bin:&apos; 这个串 </span><br><span class="line">/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin</span><br><span class="line">&lt;=== 发现最短的匹配串是 /usr/java/jdk1.8.0_144/bin: 便将其删除</span><br></pre></td></tr></table></figure><p>范例二 ： 从左向右删除最长匹配串</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">dombro@ubuntu:~$ echo $path</span><br><span class="line">/usr/java/jdk1.8.0_144/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin</span><br><span class="line">dombro@ubuntu:~$ echo $&#123;path##/*bin:&#125;</span><br><span class="line">&lt;=== ## 代表从左向右删除最长</span><br><span class="line">/usr/games:/usr/local/games:/snap/bin</span><br><span class="line">&lt;=== 发现最长的匹配串是 /usr/java/jdk1.8.0_144/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:</span><br></pre></td></tr></table></figure><p>范例三 ： 从右向左删除最短匹配串</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">dombro@ubuntu:~$ echo $path</span><br><span class="line">/usr/java/jdk1.8.0_144/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin</span><br><span class="line">dombro@ubuntu:~$ echo $&#123;path%:*bin&#125;</span><br><span class="line">&lt;=== % 代表从右向左删除最短匹配串</span><br><span class="line">/usr/java/jdk1.8.0_144/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games</span><br><span class="line">&lt;=== 发现最短的匹配串是 :/snap/bin</span><br></pre></td></tr></table></figure><p>范例四 ： 从右向左删除最长匹配串</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dombro@ubuntu:~$ echo $path</span><br><span class="line">/usr/java/jdk1.8.0_144/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin</span><br><span class="line">dombro@ubuntu:~$ echo $&#123;path%%:*bin&#125;</span><br><span class="line">/usr/java/jdk1.8.0_144/bin</span><br><span class="line">&lt;=== 发现最长的匹配串是 :/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin</span><br></pre></td></tr></table></figure><p><em>注意我们通过 <code>echo</code> 命令只是进行查看而已，并没有进行删除，你可以通过`path=${path%%:</em>bin}` 来达到删除变量内容的目的*</p><ul><li>变量内容的替代</li></ul><p>首先你要知道下面两个符号的意义</p><blockquote><p>${变量/旧字符串/新字符串} 若变量内容符合旧字符串，则第一个旧字符串会被新字符串替换。<br>${变量//旧字符串/新字符串} 变量内容符合旧字符串，则全部旧字符串会被新字符串替换。</p></blockquote><p>范例一 ： 替代第一个旧字符串</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dombro@ubuntu:~$ echo $path</span><br><span class="line">/usr/java/jdk1.8.0_144/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin</span><br><span class="line">dombro@ubuntu:~$ echo $&#123;path/bin/BIN&#125;</span><br><span class="line">/usr/java/jdk1.8.0_144/BIN:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin</span><br></pre></td></tr></table></figure><p>范例一 ： 替代全部旧字符串</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dombro@ubuntu:~$ echo $path</span><br><span class="line">/usr/java/jdk1.8.0_144/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin</span><br><span class="line">dombro@ubuntu:~$ echo $&#123;path//bin/BIN&#125;</span><br><span class="line">/usr/java/jdk1.8.0_144/BIN:/usr/local/sBIN:/usr/local/BIN:/usr/sBIN:/usr/BIN:/sBIN:/BIN:/usr/games:/usr/local/games:/snap/BIN</span><br></pre></td></tr></table></figure><ul><li>变量的测试与内容的替换</li></ul><p>范例一 ： 测试变量是否存在，若不存在直接付给该变量一个值 <code>变量=${变量-变量值}</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dombro@ubuntu:~$ echo $username</span><br><span class="line">&lt;=== 为空说明没有这个变量</span><br><span class="line">dombro@ubuntu:~$ username=$&#123;username-dombro&#125;</span><br><span class="line">dombro@ubuntu:~$ echo $username</span><br><span class="line">dombro</span><br></pre></td></tr></table></figure><p><em>范例中的重点在于 - ，他表示当变量不存在时，为该变量赋 -后面字符串 的值</em>。</p><p>范例二 ： 当变量未设置或变量为空字符串时直接付给变量一个值 <code>变量=${变量:-变量值}</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">dombro@ubuntu:~$ username=&quot;&quot;</span><br><span class="line">dombro@ubuntu:~$ echo $username</span><br><span class="line">&lt;=== 为空串</span><br><span class="line">dombro@ubuntu:~$ username=$&#123;username-dombro&#125;</span><br><span class="line">dombro@ubuntu:~$ echo $username</span><br><span class="line">&lt;=== 并不能更改，因为username已被设置为空串</span><br><span class="line">dombro@ubuntu:~$ username=$&#123;username:-dombro&#125;</span><br><span class="line">dombro@ubuntu:~$ echo $username</span><br><span class="line">dombro</span><br></pre></td></tr></table></figure><ul><li>变量综合范例</li></ul><p>这里针对上面提出的替换内容做一个综合范例，帮助理解</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">dombro@ubuntu:~$ str=&quot;oldvar&quot;;var=$&#123;str-newvar&#125;</span><br><span class="line">dombro@ubuntu:~$ echo var=&quot;$var&quot;,str=&quot;$str&quot;</span><br><span class="line">var=oldvar,str=oldvar &lt;=== 由于str变量存在，所以并未被设为newvar</span><br><span class="line">dombro@ubuntu:~$ unset str;var=$&#123;str=newvar&#125;</span><br><span class="line">dombro@ubuntu:~$ echo var=&quot;$var&quot;,str=&quot;$str&quot;</span><br><span class="line">var=newvar,str=newvar &lt;=== 由于str变量不存在，所以可以使用 = 被设为newvar</span><br><span class="line">dombro@ubuntu:~$ str=&quot;oldvar&quot;;var=$&#123;str=newvar&#125;</span><br><span class="line">dombro@ubuntu:~$ echo var=&quot;$var&quot;,str=&quot;$str&quot;</span><br><span class="line">var=oldvar,str=oldvar &lt;== 由于str变量存在，所以使用 = 并不能设为newvar</span><br><span class="line">dombro@ubuntu:~$ unset str;var=$&#123;str?no var&#125;</span><br><span class="line">bash: str: no var &lt;=== 变量 str 不存在，变量如果不存在使用 ? 会显示提示信息</span><br><span class="line">dombro@ubuntu:~$ str=&quot;oldvar&quot;;var=$&#123;str?no var&#125;</span><br><span class="line">dombro@ubuntu:~$ echo var=&quot;$var&quot;,str=&quot;$str&quot;</span><br><span class="line">var=oldvar,str=oldvar &lt;=== 变量存在，则不会显示提示信息</span><br></pre></td></tr></table></figure><h2 id="4">4. 命令别名与历史命令</h2><p><a href="#2.1">2.1小节bash的功能</a> 中介绍了 bash 两个很优秀的功能，命令的别名与历史命令，下面分别介绍一下</p><h3 id="4.1">4.1 命令别名 alias</h3><p>可以说命令别名是一个很有趣的功能，尤其是当你的惯用命令很长的时候。通过例子看一下</p><ul><li>使用别名命令 alias 让命令变得简单</li></ul><p>有时候要输入的命令很长是一件很烦人的事情…这时候就可以使用命令的别名 <code>alias 别名=&#39;命令参数&#39;</code> 这种写法。</p><p>范例一：将命令 <code>ls -a|more</code> 设为 <code>lm</code> 别名</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">dombro@ubuntu:~$ alias lm=&apos;ls -l|more&apos;</span><br><span class="line">dombro@ubuntu:~$ lm</span><br><span class="line">total 72</span><br><span class="line">-rw-rwxr-- 1 dombro dombro    0 Aug 27 10:38 at_example.txt</span><br><span class="line">drwxr-xr-x 3 dombro dombro 4096 Oct 22 14:00 Desktop</span><br><span class="line">drwxr-xr-x 2 dombro dombro 4096 Aug 13 17:18 Documents</span><br><span class="line">drwxr-xr-x 2 dombro dombro 4096 Aug 13 17:18 Downloads</span><br><span class="line">-rw-r--r-- 1 dombro dombro 8980 Aug 13 17:08 examples.desktop</span><br><span class="line">-rw-r--r-- 1 dombro dombro 5490 Nov 13 13:48 manpath.config</span><br><span class="line">-rw-rw-r-- 1 dombro dombro 5504 Nov 13 13:44 man.test.config</span><br><span class="line">drwxr-xr-x 2 dombro dombro 4096 Aug 13 17:18 Music</span><br><span class="line">-rwxr-xr-x 1 dombro dombro   27 Aug 29 20:49 newfile</span><br><span class="line">drwxr-xr-x 2 dombro dombro 4096 Aug 13 17:18 Pictures</span><br><span class="line">drwxr-xr-x 2 dombro dombro 4096 Aug 13 17:18 Public</span><br><span class="line">drwxrwxr-x 3 dombro dombro 4096 Aug 31 15:16 school</span><br><span class="line">drwxrwxr-x 2 dombro dombro 4096 Nov 13 13:22 temp</span><br><span class="line">drwxr-xr-x 2 dombro dombro 4096 Aug 13 17:18 Templates</span><br><span class="line">-rw-rw-r-- 1 dombro dombro    0 Nov 13 13:09 testfile</span><br><span class="line">drwxr-xr-x 2 dombro dombro 4096 Aug 13 17:18 Videos</span><br></pre></td></tr></table></figure><p>可以注意到命令别名与命令执行效果是一样一样的~</p><ul><li>命令别名设置可以替代既有命令</li></ul><p>这句话是不是有点不易理解？为什么要使用别名替代既有命令？比如你在删除(rm)时，需要特别小心，要加上 <code>-i</code> 这个选项</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dombro@ubuntu:~$ rm -i at_example.txt</span><br><span class="line">rm: remove regular empty file &apos;at_example.txt&apos;? n</span><br></pre></td></tr></table></figure><p>每次都加这个 <code>-i</code> 感觉很麻烦，所以我们可以设置 <code>rm -i</code> 的别名为 <code>rm</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dombro@ubuntu:~$ alias rm=&apos;rm -i&apos;</span><br><span class="line">dombro@ubuntu:~$ rm at_example.txt</span><br><span class="line">rm: remove regular empty file &apos;at_example.txt&apos;? n</span><br></pre></td></tr></table></figure><ul><li>查看当前所有命令别名</li></ul><p>直接输入 alias 会直接列出当前所有别名</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">dombro@ubuntu:~$ alias</span><br><span class="line">alias egrep=&apos;egrep --color=auto&apos;</span><br><span class="line">alias fgrep=&apos;fgrep --color=auto&apos;</span><br><span class="line">alias grep=&apos;grep --color=auto&apos;</span><br><span class="line">alias l=&apos;ls -CF&apos;</span><br><span class="line">alias la=&apos;ls -A&apos;</span><br><span class="line">alias ll=&apos;ls -alF&apos;</span><br><span class="line">alias lm=&apos;ls -l|more&apos;</span><br><span class="line">alias ls=&apos;ls --color=auto&apos;</span><br><span class="line">alias rm=&apos;rm -i&apos;</span><br></pre></td></tr></table></figure><ul><li>unalias 移除命令的别名</li></ul><p>没什么说的，使用 <code>unalias 命令别名</code> 就可以把命令别名去掉</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dombro@ubuntu:~$ unalias lm</span><br><span class="line">dombro@ubuntu:~$ lm</span><br><span class="line">lm: command not found</span><br></pre></td></tr></table></figure><h3 id="4.2">4.2 历史命令</h3><p>有关与历史命令不举过多例子，说几个概念吧</p><ul><li>history 命令</li></ul><p>1.直接输入 <code>history</code> 会将目前内存内的所有 history 记忆列出来</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">dombro@ubuntu:~$ history</span><br><span class="line">    1  cd /home/</span><br><span class="line">    2  cd /usr</span><br><span class="line">    3  history</span><br><span class="line">    4  alias</span><br><span class="line">    5  tee --help</span><br><span class="line">    6  who</span><br><span class="line">    7  who | tee who.out</span><br><span class="line">    8  cat who.out</span><br><span class="line">    9  bind -p</span><br><span class="line">   10  vim who.out</span><br><span class="line">   11  vim --help</span><br><span class="line">   12  vi --help</span><br><span class="line">   13  vim --help</span><br><span class="line">...后面省略</span><br></pre></td></tr></table></figure><p>2.<code>history [数字n]</code> 会列出最近 n 条命令行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">dombro@ubuntu:~$ history 20</span><br><span class="line">  660  clear</span><br><span class="line">  661  str=&quot;oldvar&quot;;var=$&#123;str-newvar&#125;</span><br><span class="line">  662  echo var=&quot;$var&quot;,str=&quot;$str&quot;</span><br><span class="line">  663  unset str;var=$&#123;str=newvar&#125;</span><br><span class="line">  664  echo var=&quot;$var&quot;,str=&quot;$str&quot;</span><br><span class="line">  665  str=&quot;oldvar&quot;;var=$&#123;str=newvar&#125;</span><br><span class="line">  666  echo var=&quot;$var&quot;,str=&quot;$str&quot;</span><br><span class="line">  667  unset str;var=$&#123;str?no var&#125;</span><br><span class="line">  668  str=&quot;oldvar&quot;;var=$&#123;str?no var&#125;</span><br><span class="line">  669  echo var=&quot;$var&quot;,str=&quot;$str&quot;</span><br><span class="line">  670  alias lm=&apos;ls -l|more&apos;</span><br><span class="line">  671  lm</span><br><span class="line">  672  rm -i at_example.txt</span><br><span class="line">  673  alias rm=&apos;rm -i&apos;</span><br><span class="line">  674  rm at_example.txt</span><br><span class="line">  675  alias</span><br><span class="line">  676  unalias lm</span><br><span class="line">  677  lm</span><br><span class="line">  678  history</span><br><span class="line">  679  history 20</span><br></pre></td></tr></table></figure><p>3.<code>history -w</code> 这种情况会将内存中的历史记录写入 <code>~/.bash_history</code> 文件中</p><p>4.<code>history -c</code> 将目前shell中所有history内容全部删除</p><p>5.<code>history -a historyfile</code> 将目前新增的history命令新增写入historyfile中，若没有加historyfile,则默认为 <code>~/.bash_history</code></p><p>6.<code>history -r historyfile</code> 将historyfile的内容读到目前这个shell的history记忆中</p><ul><li>不使用 <code>history</code> 执行命令</li></ul><p><strong>地球人都知道可以通过 ↑ ↓ 去查找执行过的历史命令</strong> ，这里介绍几个其他的方法</p><p>1.<code>!number</code> 执行第 number 条命令</p><p>2.<code>!command</code> <strong>有最近的命令向前搜寻命令串开头为<code>command</code>的那个命令</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dombro@ubuntu:~$ !cl</span><br><span class="line"></span><br><span class="line">&lt;=== 执行了 clear 命令，所以清屏了</span><br></pre></td></tr></table></figure><p>3.<strong><code>!!</code> 就是执行上一命令的意思，相当于按 ↑ 在按 [Enter]</strong></p><h2 id="5">5. Bash Shell 的环境操作</h2><p>emmm，下面这一部分有点生硬。我试着写的通俗易懂一点。 首先你需要注意一点，<strong>上面所有提到的自定义变量，命令别名在你注销 bash 后就会失效(也就是下次登录那些变量别名就都没有了)</strong>！</p><h3 id="5.1">5.1 bash 的环境配置操作</h3><p>是不是会很好奇当我们进入 Linux 时，明明什么都没有进行，但是一进入bash就会取得一堆变量？千万不要感到很神奇，其实计算机科学中所有的为我们做的事情，肯定是有一个地方储存。你肯定会想到 Linxu 中所有东西都是以文件形式存在的这句话！<strong>没错，Linux 下面存在一些环境配置文件，让 bash　启动时直接读取这些配置文件，以规划好bash的环境操作</strong>。环境变量的配置文件还可以将用户设置的变量、别名写入其中！</p><ul><li>login shell</li></ul><blockquote><p>在取得 bash 时需要完整的登录流程的，就称为 login shell。</p></blockquote><p>翻译成普通话就是：你在控制台（通过命令行）输入了账号密码登录了Linux，就叫 login shell。</p><ul><li>non-login shell</li></ul><blockquote><p>取得 bash 接口的方法不需要重复登录的举动</p></blockquote><p>翻译成普通话就是：你没有在，命令行输入了账号密码登录了Linux，就叫 non-login shell。例如用 X-windows 使用 <code>ctrl</code>+<code>alt</code>+<code>t</code> 进入 shell时，就是 non-login shell。</p><p>介绍 login-shell 和 non-login shell 的原因是因为，这两种取得 bash 的情况，读取的配置文件数据并不一致。</p><h4 id="5.1.1">5.1.1 login shell 读取文件介绍</h4><p>我们总是要登录系统的，所以先介绍login shell读取的文件。login shell 其实自会读取这两个配置文件：</p><p>1./etc/profile:系统整体设置，你最好不要修改这个文件；</p><p>2.~/.bash_profile 或 ~/.bash_login 或 ~/.profile :属于用户个人设置，你要该自己的数据就写入这里。</p><p><em>前方高能预警，这两个文件的的内容可是hin复杂的，真的好不想写这里…</em></p><ul><li>/etc/profile 内容概述</li></ul><blockquote><p>你可以使用 vim 去读取这个文件，这个文件可以利用用户的标识符(UID)来决定很多重要变量数据，也是每个用户登录取得 bash 时一定会读取的配置文件。所以如果你想要帮所有用户设置整体环境，那就是在这里修改。不过还是不要随便修改这个文件。</p></blockquote><p>下面是这个文件设置的主要变量：</p><p>PATH : 会根据UID决定PATH变量要不要含有sbin的系统命令目录。</p><p>MAIL : 根据账号设置好用户额 mailbox 到/var/spool/mail/账号名。</p><p>USER : 根据用户的账号设置此变量的内容。</p><p>HOSTORYSIZE : 历史命令记录条数。</p><p>HOSTNAME : 根据主机的hostname命令决定此变量内容。</p><p>/etc/profile 可不止会做这些事情而已，还会调取外部设置数据；至于调去哪些，我想这并不是重点的内容。 <strong>你只需要记住，bash 的login shell情况下所读取的整体环境配置文件只有/etc/profile，但是/etc/profile还会调用其他的配置文件，目的是让我们的bash接口变得非常友善</strong>。</p><ul><li>用户个人偏好设置文件</li></ul><p>login shell 所读取的个人偏好配置文件其实主要有三个，介绍了三个文件</p><blockquote><p>~/.bash_profile<br>~/.bash_login<br>~/.profile</p></blockquote><p><strong>实际上bash的 login shell 设置只会按照顺序读取上面三个文件的其中一个。也就是说如果 ~/bash_profile 存在，那么其他两个文件无论存不存在都不会去读取</strong>。我的Ubuntu下面就只有 ~/.profile 文件。</p><p>你可以将用户个人偏好设置看作是 /etc/profile 的一个补充！也就是说当 shell 通过读取 /etc/profile 之后，如果你有一些自己的变量设置，你可以在你的个人偏好设置文件中进行设置。</p><p>实际上在读取完个人偏好设置文件内容后会在调用 ~/.bashrc 设置的内容。</p><ul><li>source 命令：读入环境变量配置文件的命令</li></ul><p>由于 /etc/profile 和个人偏好设置都是在取得 login shell 的时候才会读取的配置文件，所以当你将你的偏好配置写入上述文件后，通常是的注销登录该设置才会生效。 source 命令就可以帮助我们解决这个麻烦事！</p><p><code>source 配置文件名</code> 就可以将你刚刚对环境配置文件的修改生效。这个操作很常见的，比如你要将 java javac 加入到 PATH变量 中去，在修改环境配置文件后，一定要使用 <code>source</code> 命令才会时 java 这个命令生效。</p><h4 id="5.1.2">5.1.2 non-login shell 读取文件介绍</h4><p>当你取得 non-shell 时，该 bash 配置文件仅会读取 ~/.bashrc 而已。<br>而 ~/.bashrc  会调用 /etc/bashrc 这个文件（不同的发行版本调用的文件名会不太一样，但步骤上大同小异）。为什么？因为 /etc/bashrc 这个文件会帮助 bash 定义出下面的数据：</p><p>根据不同的UID设置规定 umask 的值；</p><p>根据不同的UID规定提示符(也就是PS1变量)；</p><p>调用 /etc/profile.d/*sh 的设置</p><ul><li>5.1 小节</li></ul><p>说实话，这个部分真的觉得很鸡肋啊有没有？有很多知识点都没有记写，但是我认为环境配置文件确是获取 bash 之前最重要的一环，根据用户的信息，bash 在读取环境配置文件后才会确定当前用户的环境配置是什么。是不是很炫酷？ 你只要记住</p><p>1./etc/profile 这个环境配置文件是所有用户在login shell登录时都会读取的环境配置文件，他包含了一些基本的设置。</p><p>2./etc/profile 文件还会调用其他一些文件 如 /etc/inputrc、/etc/profile.d/*sh、/etc/sysconfig/i18n等等，调用的目的除了获取一些必要的配置信息还有就是让我们的bash 接口变得友善。</p><p>3.你或许会注意到 个人偏好配置文件 都是在用户主目录下，所以这个里面的配置主要是为了对 /etc/profile 的补充，我们尽量只去修该偏好文件里的内容，不要轻易去修改/etc/profile 的内容。</p><p>4.个人偏好设置文件会再调用 ~/.bashrc 这个文件</p><p>5.non-login shell 只会读取 ~/.bashrc 这个文件，但这个文件会再调用 /etc/bashrc 这个文件。</p><p>6.在对环境配置文件进行更改后，应该使用 source 使其改动写入当前 bash 。</p><p>7.下面图片列出 bash 在两种 shell 读取配置文件的过程，很直接:</p><p><img src="http://p0bl99g4r.bkt.clouddn.com/bash7.jpg" alt=""></p><h2 id="6">6. bash 操作与通配符</h2><p>bash 为我们提供了很多操作组合键和通配符。目的当然是为我们营造一个最舒适的用户环境，所以不会用的话是不是感觉有点亏？</p><h3 id="6.1">6.1 bash默认组合键</h3><p>有没有使用过 [ctrl] + c 这个组合键终止过一个命令？第一次摆弄 Linux 时我以为 Linxu 下面 [ctrl] + c 和 windows 下面一样是复制的意思…结果当然复制不成功，还以为是 Linux 出问题了（T_T）。下面给出 bash 的默认组合键。</p><p><img src="http://p0bl99g4r.bkt.clouddn.com/bash2.jpg" alt="bash组合按键图片"></p><h3 id="6.2">6.2 通配符与特殊符号</h3><ul><li>bash 通配符</li></ul><p>bash 的操作环境中还有一个非常有用的功能，那就是通配(wildcard)。下面列出的几个通配符，相信你是一定用到过的。</p><p><img src="http://p0bl99g4r.bkt.clouddn.com/bash2.jpg" alt="bash通配符图片"></p><p>范例一：使用 * 找出/etc/下面以字母m为开头的文件名</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:/etc# ls -dl m*</span><br></pre></td></tr></table></figure><p>范例二：使用 ? 找出/etc/下面文件名刚好是五个字母的文件名</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dombro@ubuntu:~$ ll -d /etc/?????</span><br></pre></td></tr></table></figure><p>? 代表着一定有一个字母</p><p>范例三 ： 找出 /etc/下面文件名含有数字的文件名</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dombro@ubuntu:~$ ll -d /etc/*[0-9]*</span><br></pre></td></tr></table></figure><p>[] 中括号代表一定会出现其中的一个字符，而[-] 代表包含 - 两端编码顺序内的所有字符</p><p>范例四 : 找出 /et    c/ 下面文件名开头非为小写字母的文件名</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dombro@ubuntu:~$ ll -d /etc/[^A-Z]*</span><br></pre></td></tr></table></figure><p>[^] 代表不包含^后面的字符</p><ul><li>bash 特殊符号</li></ul><p>在 bash 下面有一些符号拥有特殊的意义，所以在给文件起名字的时候尽量避开他们！用图片给出</p><p><img src="http://p0bl99g4r.bkt.clouddn.com/bash2.jpg" alt=""></p><h2 id="6">6. 总结</h2><p>标题列的是 初始bash 所以这篇笔记只是简单对 bash 有了一个了解。对 bash 的特点有一个大致上的了解。后续会提到 bash 的管道命令、重定向等等。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; class=&quot;headerlink&quot; title=&quot;目录&quot;&gt;&lt;/a&gt;目录&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#1&quot;&gt;1. shell&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#1.1&quot;&gt;1.1 what&lt;/a&gt;&lt;/l
      
    
    </summary>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>磁盘与Linux分区</title>
    <link href="http://yoursite.com/2017/12/11/%E7%A3%81%E7%9B%98%E4%B8%8ELinux%E5%88%86%E5%8C%BA/"/>
    <id>http://yoursite.com/2017/12/11/磁盘与Linux分区/</id>
    <published>2017-12-11T11:15:18.000Z</published>
    <updated>2017-12-11T11:18:44.113Z</updated>
    
    <content type="html"><![CDATA[<p>Linux系统安装在哪里？当然是在硬盘上。</p><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li><a href="#1">1. 计算机磁盘（机械）</a><ul><li><a href="#1.1">1.1 硬盘的物理组成</a></li><li><a href="#1.2">1.2 盘片上的数据</a></li><li><a href="#1.3">1.3 传输接口</a></li></ul></li><li><a href="#2">2. 磁盘分区</a><ul><li><a href="#2.1">2.1 磁盘连接的方式与设备文件名的关系</a></li><li><a href="#2.2">2.2 主引导分区与分区表</a></li><li><a href="#2.3">2.3 磁盘分区原因</a></li><li><a href="#2.3">2.4 扩展分区与逻辑分区</a></li></ul></li><li><a href="#3">3. 文件系统与目录树的关系</a><ul><li><a href="#3.1">3.1 目录树结构</a></li><li><a href="#3.2">3.2文件系统与目录树的关系(挂载)</a></li></ul></li></ul><h2 id="1">1. 计算机硬盘（机械）</h2><p>计算机上面的存储设备设备包括硬盘、软盘、MO、CD、DVD、磁带机、U盘等，都是可以用来存储数据的。而其中最常见的就是硬盘了。注意这里说的都是传统的机械硬盘。</p><h3 id="1.1">1.1 硬盘的物理组成</h3><p>大家应该都看过硬盘吧。硬盘依据桌面型与笔记本又分为3.5英寸及2.5英寸的大小。我们以3.5英寸的硬盘来说明。硬盘其实是由许多的盘片、机械手臂、磁头与主轴马达所组成的。它大概是长酱婶的</p><p><img src="http://p0bl99g4r.bkt.clouddn.com/disk.jpg" alt=""></p><p>实际的<strong>数据都是写在具有磁性物质的盘片上</strong>，而读写主要是通过在机械手臂上的读取头（Head）来完成。实际运行时，主轴马达让盘片转动，然后机械手臂可伸展让读取头在盘片上面进行读写的操作。另外由于单一盘片的容量有限，因此有的硬盘内部会有两个以上的盘片。</p><h3 id="1.2">1.2 盘片上的数据</h3><p>整个盘片上面好像有多个同心圆绘制出的饼图，而由圆心以放射状的方式分割出磁盘的最小存储单位，那就是<strong>扇区（Sector），在物理组成分面，每个扇区大小为512bytes，这个值是不会改变的</strong>。而扇区组成一个圆就成为磁道（Track），如果是在多硬盘上面，在所有盘片上面的同一个磁道可以组成一个柱面（Cylinder），柱面也是一般我们分割硬盘时的最小单位了！<br>在计算整个硬盘的存储量时，简单的计算公式就是：header数量x每个header负责的柱面数量 x 每个柱面所含有的扇区数量 x 扇区的容量，单位换算为：header x cylinder/header x secter/cylinder x 512bytes/secter，简单的写法如下：Head x Cylinder x Sector x 512bytes。不过要注意的是，一般硬盘制造商在显示硬盘的容量时，大多是以十进制来编号，因此市售的500GB硬盘，理论上仅会有460GB左右的容量。盘片其实是酱婶的</p><p><img src="http://p0bl99g4r.bkt.clouddn.com/sector.png" alt=""></p><h3 id="1.3">1.3 传输接口</h3><p>目前硬盘与主机系统的连接主要有下面传输接口规格</p><ul><li>IDE接口</li></ul><blockquote><p>IDE接口插槽所使用的排线较宽，每条排线上面可以接两个 IDE 设备，由于可以接两个设备，为了判别两个设备的主/从（Master/Slave）架构，因此这种磁盘驱动器上面需要调整跳针（Jump）成为Master或Slave才行。这种接口的最高传输速度为Ultra 133规格，即每秒理论传输速度可达133MB。</p></blockquote><ul><li>SATS接口</li></ul><blockquote><p>每条SATA连接线仅能接一个SATA设备。SATA接口除了速度较快之外，由于其排线较细小，所以有利于主机壳内部的散热与安装。目前SATA已经发展到了第二代，其速度由SATA-1的每秒150MB提升到SATA-2每秒300MB的传输速度，因此目前主流的个人计算机硬盘已经被SATA替代了。</p></blockquote><ul><li>SCSI接口</li></ul><blockquote><p>另一种常见于工作站等级以上的硬盘传输接口为SCSI接口，这种接口的硬盘在控制器上含有一块处理器，所以除了运转速度快之外，也比较不会耗费CPU资源。在个人计算机上面这种接口的硬盘不常见。</p></blockquote><h2 id="2">2. 磁盘分区</h2><p>Linux系统是安装在计算机组件的磁盘部分。一块磁盘是可以被分区成多个分区（partition），以 Windows 观点来看，你可能会有一块磁盘并且将它分区成为 C:, D:, E:盘。那个 C, D, E就是分区。但是Linux的设备都是以文件的类型存在，那分区的文件名又是什么？如何进行磁盘分区，磁盘分区有哪些限制？是我们这个小节所要探讨的内容。</p><h3 id="2.1">2.1 磁盘连接的方式与设备文件名的关系</h3><p>由上面<a href="#1.3">传输接口</a>可以知道，常见的个人计算机磁盘接口有两种，IDE和SATA（主流）接口。称可连接到IDE接口的设备为IDE设备，<strong>不管是磁盘还是光盘设备</strong>。<br>以IDE接口来说，由于一个IDE扁平电缆可以连接两个IDE设备，通常主机又都会提供两个IDE接口，因此最多可以接到四个IDE设备。也就是说，如果你已经有一个光盘设备了，那么最多就只能再接三块IDE接口的磁盘。这两个IDE接口通常被称为IDE1（primary）及IDE2（secondary），而每条扁平电缆上面的IDE设备可以被区分为Master（主设备）与Slave（从设备）。IDE设备和文件名的关系是酱婶的</p><p><img src="http://p0bl99g4r.bkt.clouddn.com/IDE.jpg" alt=""></p><p>再以SATA接口来说，由于SATA/USB/SCSI等磁盘接口都是使用SCSI模块来驱动的，因此这些接口的磁盘设备文件名都是/dev/sd[a-p]的格式。但是与IDE接口不同的是，SATA/USB接口的磁盘根本就没有一定的顺序，那如何决定它的设备文件名呢？这个时候就得要根据Linux内核检测到磁盘的顺序了</p><ul><li>SATA设备文件名例子</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">如果你的PC上面有两个SATA磁盘以及一个USB磁盘，而主板上面有六个SATA的插槽。这两个SATA磁盘分别安插在主板上的SATA1, SATA5插槽上，请问这三个磁盘在Linux中的设备文件名是什么？</span><br><span class="line">答：由于是使用检测到的顺序来决定设备文件名，并非与实际插槽代号有关，因此设备的文件名如下：</span><br><span class="line">1．SATA1插槽上的文件名：/dev/sda</span><br><span class="line">2．SATA5插槽上的文件名：/dev/sdb</span><br><span class="line">3．USB磁盘（开机完成后才被系统识别）：/dev/sdc</span><br></pre></td></tr></table></figure><p>这就是在Linux系统中不同接口的磁盘设备文件名，即 IDE接口的设备文件名为 /dev/hd[a-d] SATA接口的设备文件名为 /dev/sd[a-p]<br>可是知道了这些当然还不够!现在知道了每个磁盘设备文件名是什么，那磁盘的每个分区又该叫什么？为什么要这么纠结磁盘与设备的文件名捏？因为在<strong>Linux下面一切都是以文件的方式存在的</strong>！</p><h3 id="2.2">2.2 主引导分区与分区表</h3><p>上面提到了<a href="#1.1">磁盘的组成</a>（由盘片、机械臂、磁头、主轴马达组成）和<a href="#1.2">盘片上的数据</a>，盘片上可以分出扇区和柱面两种单位，每个扇区有512byte那么大。在这么多的扇区里面<strong>磁盘的第一个扇区最重要</strong>！！因为<strong>第一块扇区记录了整块磁盘最重要的两个信息————主引导分区和分区表</strong></p><ul><li>主引导分区(Master Boot Record,MBR)</li></ul><blockquote><p>可以安装引导加载程序的地方，有446bytes。MBR是非常重要的。系统在开机时会主动去读取这个区块的内容，这样系统才会知道你的程序放在哪了该如何进行开机。</p></blockquote><ul><li>磁盘分区表</li></ul><blockquote><p>你拿到的整块硬盘就像原木，你必须要在这根木头上切割出你想要的区段，这个区段才能在制作成为你想要的家具。同样地道理，硬盘进行分区才能更好的被利用。<br>磁盘上面的<strong>起始与结束柱面</strong>(也就是柱面的号码)就是分区的最小单位，也就是文件系统的最小单位。其实就是利用柱面的参考柱面的号码进行磁盘的分区的。在分区表所在的64byte容量中，总共分为四组记录区，每组记录了该区段的起始与结束的柱面号码。若是以硬盘为长方形来看如下图</p></blockquote><p><img src="http://p0bl99g4r.bkt.clouddn.com/partition01.jpg" alt=""></p><p>假设上图设备文件名为 /dev/hda 时，那么自四个分区在Linux系统中的设备文件名分别为 P1:/dev/hda1、P2:/dev/hda2、P3:/dev/hda3、P4:/dev/hda4 <strong>重点在于文件名后面的数字，这个数字与该分区所在的位置有关</strong>。由于分区表就只有64byte，最多只能容纳四个分区，这四个分区被称为主（Primary）或扩展(Extened)分区。</p><ul><li>分区本质</li></ul><blockquote><p>1.其实<strong>所谓的分区就是针对那个64bytes的分区表进行设置而已</strong>。<br>2.硬盘默认的分区表仅能写入四组分区信息。这四组分区信息我们称为主(Primary)或扩展(Extended)分区。<br>3.分区的最小单位为柱面<br>4.当系统写入磁盘时，一定会参考磁盘分区表，才能针对某个分区进行数据处理。</p></blockquote><h3 id="2.3">2.3 磁盘分区原因</h3><p>有没有想过这个问题，磁盘为什么要进行分区？处于以下两个方面的考虑</p><ul><li>数据的安全性</li></ul><p>因为每个分区的数据是分开的。所以，当你需要将某个分区的数据重整时，例如你要重新安装Windows时，可以将C盘中其他重要数据移到其他分区，例如将邮件、桌面数据移动到D盘去，那么重装系统并不会影响到D盘。所以善用分区，可以让你的数据更安全。</p><ul><li>系统的性能考虑</li></ul><p>由于分区将数据集中在某个柱面的区段，例如上图 当中第一个分区位于柱面号码 1～100号，如此一来当有数据要读取自该分区时，磁盘只会搜寻前面1～100的柱面范围，由于数据集中了，将有助于数据读取的速度与性能！所以说，分区是很重要的。</p><h3 id="2.4">2.4 扩展分区与逻辑分区</h3><p>有没有想过这个问题，既然分区表只有记录四组数据的空间，那是不是一块硬盘最多可以分出四个分区？我默默的看了一眼放在H盘下面的岛国动作片，显然我的电脑不止四个分区。可以做到不止四个分区的操作是如何达到的呢？答案就是扩展分区</p><ul><li>扩展分区</li></ul><p>扩展分区的想法是，既然第一个扇区所在的分区表只能记录四条数据，那我是否可以利用额外的扇区来记录更多的分区信息？就像下图</p><p><img src="http://p0bl99g4r.bkt.clouddn.com/partition02.jpg" alt=""></p><p>图中P1为主分区，P2则为扩展分区。这个扩展分区的目的是使用额外的扇区来记录分区信息，扩展分区本身并不能拿来格式化，因为他并不是一个可以挂载的文件系统。我们可以通过扩展分区所指向的那个区块继续做分区的记录。</p><ul><li>逻辑分区</li></ul><p>扩展分区指向的区块在进行切割出来的就是逻辑分区。由于逻辑分区是由扩展分区继续分区出来的，所以他可以使用的柱面范围就是扩展分区设定的范围！<br>逻辑分区的数量依操作系统而不同，在Linux系统中，IDE硬盘最多有59个逻辑分区（5号到63号），SATA硬盘则有11个逻辑分区（5号到15号）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">同样，上图分区在Linux系统中的设备文件名分别如下：</span><br><span class="line">P1:/dev/hda1</span><br><span class="line">P2:/dev/hda2</span><br><span class="line">L1:/dev/hda5</span><br><span class="line">L2:/dev/hda6</span><br><span class="line">L3:/dev/hda7</span><br><span class="line">L4:/dev/hda8</span><br><span class="line">L5:/dev/hda9</span><br><span class="line">仔细看看，怎么设备文件名没有/dev/hda3 与/dev/hda4 呢？因为前面四个号码都是保留给Primary或Extended用的。所以逻辑分区的设备名称号码就由5号开始了，这是个很重要的特性，不能忘记。</span><br></pre></td></tr></table></figure></p><ul><li>主分区、扩展分区与逻辑分区的特性的简单定义</li></ul><blockquote><p>主分区和扩展分区最多可以有四个(硬盘限制)<br>扩展分区最多只能有一个(操作系统限制)<br>逻辑分区是由扩展分区持续切割出来的分区<br>能够被格式化后作为数据访问的为主分区和逻辑分区。扩展分区无法格式化</p></blockquote><h2 id="3">3. 文件系统与目录树的关系</h2><p>在Linux中所有文件都是以文件形态来呈现的。</p><h3 id="3.1">3.1 目录树结构</h3><p>Linux内的所有数据都是以文件的形态来呈现的，所以，整个Linux系统最重要的地方就是在于目录树结构。所谓的目录树结构（directory tree）就是以根目录为主，然后向下呈现分支状的目录结构的一种文件结构。所以，整个目录树结构最重要的就是那个根目录（root directory），这个根目录的表示方法为一条斜线“/”，所有的文件都与目录树有关。目录树的呈现方式如图</p><p><img src="http://p0bl99g4r.bkt.clouddn.com/directory.jpg" alt=""></p><p>整个Linux系统使用的是目录树结构，但是我们的文件数据其实是放置在磁盘分区当中的，如何结合目录树的架构与磁盘内的数据，这就涉及到了挂载</p><h3 id="3.2">文件系统与目录树的关系(挂载)</h3><p>挂载就是利用一个目录当成进入点，将磁盘分区的数据放置在该目录下，也就是说，<strong>进入该目录就可以读取该分区的意思</strong>。这个操作就叫挂载。<strong>这个进入点我们称为挂载点</strong> 。由于整个Linux系统最重要的是根目录，因此根目录一定需要挂载到某个分区的。至于其他的目录则可依用户自己的需求来给予挂载到不同的分区。<br>举个栗子</p><p><img src="http://p0bl99g4r.bkt.clouddn.com/mount.jpg" alt=""></p><p>图 中假设我的硬盘分为两区，partition 1 挂载到根目录，至于 partition 2 则是挂载到/home这个目录。这也就是说，当我的数据放置在/home 内的各次目录时，数据是放置到 partition 2 的，如果不是放在/home 下面的目录，那么数据就会被放置到 partition 1。<br>其实判断某个文件在哪个partition下面是很简单的（前提是你要知道有哪些patrition），通过反向追踪即可。以上图来说，当我想要知道/home/vbird/test 这个文件在哪个 partition 时，由test –&gt; vbird –&gt; home –&gt;/，看哪个“进入点”先被查到那就是使用的进入点了。所以test使用的是/home这个进入点而不是/</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>简单归纳了计算机磁盘和Linux文件系统的关系</p><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><p>整理笔记参考了 <a href="http://linux.vbird.org/linux_basic/0210filepermission.php#filepermission_perm" target="_blank" rel="noopener">《鸟哥的Linux私房菜》</a> 一书。这本书我是买的<a href="http://sale.jd.com/act/W5hugLDc1R.html" target="_blank" rel="noopener">京东阅读</a>的正版电子书籍。<br><br>如果不想买书看的话可以直接戳<a href="http://linux.vbird.org/" target="_blank" rel="noopener">这里进入鸟哥Linux私房菜的线上博客 : http://linux.vbird.org/</a>。请大家支持正版！！<br><br>至于笔记中的命令我是都敲过一遍的并进行了理解，并不是单纯的复制粘贴呦！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Linux系统安装在哪里？当然是在硬盘上。&lt;/p&gt;
&lt;h2 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; class=&quot;headerlink&quot; title=&quot;目录&quot;&gt;&lt;/a&gt;目录&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#1&quot;&gt;1. 计算机磁盘（机械）&lt;/a&gt;&lt;ul&gt;
&lt;
      
    
    </summary>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>vim编辑器</title>
    <link href="http://yoursite.com/2017/12/11/vim%E7%BC%96%E8%BE%91%E5%99%A8/"/>
    <id>http://yoursite.com/2017/12/11/vim编辑器/</id>
    <published>2017-12-11T11:10:44.000Z</published>
    <updated>2017-12-11T11:37:59.052Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux-vim编辑器"><a href="#Linux-vim编辑器" class="headerlink" title="Linux vim编辑器"></a>Linux vim编辑器</h1><p>没接触Linux之前就经常听到 vi、vim 这两个词，后来简单接触过vi编辑器，今天就来一探究竟。</p><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li><a href="#1">1. what</a></li><li><a href="#2">2. why</a></li><li><a href="#3">3. how</a></li><li><a href="#4">4. do</a></li><li><a href="#5">5. more</a><ul><li><a href="#5.1">5.1 Windows 与 Linux 换行字符</a></li><li><a href="#5.2">5.2 编码转换</a></li></ul></li><li><a href="#6">6. 说明</a></li></ul><h2 id="1">1. what? 什么是vim编辑器</h2><p>Linux 中所有内容都是以文件形式存在的，所以作为系统管理员(root)重要工作就是修改某些软件的配置文件(MySql、tomcat、MongoDB等都需要配置启动)，所以就必须要学会使用一种以上的命令行界面的文本编辑器。Linux发行版本众多，但<strong>所有发行版本都会有的一款文本编辑器就是vi编辑器</strong>。而 vim编辑器 就是 vi编辑器的升级版，支持语法高亮，还可以拿来编程，优点一大堆。</p><h2 id="2">2. why? 为啥要学vim编辑器</h2><p>这原因嘛，主要有四点</p><ol><li>所有类 UNIX 系统都会内置 vi编辑器。</li><li>很多软件的编辑接口会主动调用vi编辑器，这是最重要的一点原因，太多命令默认使用vi作为数据的编辑接口，所以一定要学会 vi 呀。</li><li>vim 具有编程能力，可以根据字体颜色辨别语法的正确性，快来试试吧~</li><li>编辑速度相当快。</li></ol><p>对vim编辑器(以下简称 vim) 是不是有好感了？ 其实 vim 的官方给vim的定位是程序开发工具，而不是文字处理软件，vim加入了很多功能如支持正则表达式的查找框架，多文件编辑等等等….总之 vim 用了都说好，你值的拥有。</p><h2 id="3">3. how? 怎么使用vim编辑器</h2><p>基本上 vi 分为三种模式:一般模式、编辑模式、命令行模式。下面会给出三种模式的按钮说明，不用全记（你有精力我也不拦你），记住每种模式常用按钮操作就可以啦！</p><ul><li>一般模式</li></ul><p>在一般模式下可以进行光标移动、复制粘贴、查找替换等操作</p><p><img src="http://p0bl99g4r.bkt.clouddn.com/vim2.jpg" alt=""></p><p><img src="http://p0bl99g4r.bkt.clouddn.com/vim1.jpg" alt=""></p><p><img src="http://p0bl99g4r.bkt.clouddn.com/vim6.jpg" alt=""></p><ul><li>一般模式切换到编辑模式可用按钮</li></ul><p><img src="http://p0bl99g4r.bkt.clouddn.com/vim5.jpg" alt=""></p><ul><li>一般模式切换到命令行模式可用按钮</li></ul><p><img src="http://p0bl99g4r.bkt.clouddn.com/vim3.jpg" alt=""></p><p><img src="http://p0bl99g4r.bkt.clouddn.com/vim4.jpg" alt=""></p><h2 id="4">4. do? vim编辑器可以做什么</h2><ul><li>块选择(Visual Block)</li></ul><p>上述的简单vi操作，几乎都是以航为单位操作。下面介绍对一块范围的操作。</p><p><img src="http://p0bl99g4r.bkt.clouddn.com/vi7.jpg" alt=""></p><ul><li>多文件编辑</li></ul><p>这是一个很爽的操作，你可以通过键盘复制一个文件的内容到另一个文件 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim file1 file2</span><br></pre></td></tr></table></figure><p>这样 vim 就会编辑两个文件了，图片是操作：</p><p><img src="http://p0bl99g4r.bkt.clouddn.com/vi8.jpg" alt=""></p><ul><li>多窗口的功能</li></ul><p>vim 另一个强大的功能就是”切割窗口”，将一个或多个文件切割成多个窗口，在命令行模式通过</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">：sp&#123;file&#125;</span><br><span class="line">file 可有可无，如果有则在该窗口中启动另一个文件，没有则是同一文件的两个窗口间</span><br></pre></td></tr></table></figure><p><img src="http://p0bl99g4r.bkt.clouddn.com/vi9.jpg" alt=""></p><ul><li>vim 环境设置与记录：~/.vimrc，~/.viminfo</li></ul><blockquote><p>有没有发现，如果我们以vim软件来查找一个文件内部的某个字符串时，这个字符串会被反白，而下次我们再次以vim编辑这个文件时，该查找的字符串反白情况还是存在呢。甚至于在编辑其他文件时，如果其他文件内也存在这个字符串，竟然还是主动反白。另外，当我们重复编辑同一个文件时，当第二次进入该文件时，光标竟然就在上次离开的那一行上面。<br>这是因为我们的vim会主动将你曾经做过的行为记录下来，好让你下次可以轻松作业。那个记录操作的文件就是：～/.viminfo。如果你曾经使用过vim，那你的主文件夹应该会存在这个文件才对。这个文件是自动产生的，你不必自行创建。而你在vim里头所做过的操作就可以在这个文件内部查询到。<br>此外，每个distributions对vim的默认环境都不太相同，举例来说，某些版本在查找到关键字时并不会高亮度反白，有些版本则会主动帮你进行缩排的行为。但这些其实都可以自行设置的，那就是vim 的环境设置。vim 的环境设置参数有很多，如果你想要知道目前的设置值，可以在一般模式时输入“:set all”来查阅，不过设置选项实在太多了，在这里仅列出一些平时比较常用的一些简单的设置值，提供给你参考。<br>所谓的缩排，就是当您按下[Enter]编辑新的一行时，光标不会在行首，而是在与上一行的第一个非空格符处对齐。</p></blockquote><p><img src="http://p0bl99g4r.bkt.clouddn.com/vi10.jpg" alt=""></p><p>整体vim的设置值一般是放置在/etc/vimrc这个文件中，不过，不建议你修改它。你可以修改～/.vimrc这个文件（默认不存在，请你自行手动创建），将你所希望的设置值写入。<br>举例来说，可以是这样的一个文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@www ～]# vim ～/.vimrc</span><br><span class="line">&quot;这个文件的双引号（&quot;） 是批注</span><br><span class="line">set hlsearch &quot;高亮度反白</span><br><span class="line">set backspace=2 &quot;可随时用退格键删除</span><br><span class="line">set autoindent &quot;自动缩排</span><br><span class="line">set ruler &quot;可显示最后一行的状态</span><br><span class="line">set showmode &quot;左下角那一行的状态</span><br><span class="line">set nu &quot;可以在每一行的最前面显示行号</span><br><span class="line">set bg=dark &quot;显示不同的底色色调</span><br><span class="line">syntax on &quot;进行语法检验，颜色显示</span><br><span class="line">在这个文件中，使用“set hlsearch”或“ :set hlsearch”，即最前面有没有冒号“:”效果都是一样的。至于双引号则是批注符号，不要用错批注符号，否则每次使用vim时都会发生警告信息。</span><br><span class="line">创建好这个文件后，当你下次重新以vim编辑某个文件时，该文件的默认环境设置就是这么设置的。这样是否很方便你的操作？所以多利用vim的环境设置功能吧！</span><br></pre></td></tr></table></figure></p><h2 id="5">5. more! 更多操作</h2><p>这一小节下面，介绍两个常见的文件编辑问题，不定义与 vim 有关</p><h3 id="5.1">5.1 Windows 与 Linux 换行字符</h3><p>熟悉 Windows 和 Linux 文本编辑的同学可能知道，这<strong>两种系统的换行方式是不一样的，Windows 是以 “\r\n”(^M$) 换行（即CRLF这两个符号），而 Linux 是以 “\n”($) 换行（即LF这个符号）</strong>。两种系统不同的换行符，造成的影响很大！ 比如将 Windos 下面的文件放到 Linux 下面时，你会发现每行都会多出来一个 “^M” ，如果这是一个在 Windows 下面编写的脚本文件，可能会造成程序无法执行的尴尬事件！ 如何解决？当然是将文件换行变为 Linux 可读的样子(LF)就好了呀。你会不会想到用 vim 将每行多出来的 “^M” 删掉？这也太没人性了，<strong>Linux 提供了简单的命令来进行格式转换</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@www ～]# dos2UNIX [-kn] file [newfile]</span><br><span class="line">[root@www ～]# UNIX2dos [-kn] file [newfile]</span><br><span class="line">参数：</span><br><span class="line">-k ：保留该文件原本的 mtime 时间格式（不更新文件上次内容经过修订的时间）</span><br><span class="line">-n ：保留原本的旧文件，将转换后的内容输出到新文件，如： dos2UNIX -n oldfile newfile</span><br></pre></td></tr></table></figure><p>在不同系统之间复制一些纯文本文件时，千万记得要使用UNIX2doc或doc2UNIX来转换一下换行格式。</p><h3 id="5.2">5.2 编码的转换</h3><p>还有一个很大的问题就是编码的转换，想要将big5编码转成utf8，怎么办?答案是使用 iconv 这个命令。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@www ～]# iconv --list</span><br><span class="line">[root@www ～]# iconv -f 原本编码 -t 新编码 filename [-o newfile]</span><br><span class="line">参数：</span><br><span class="line">--list ：列出 iconv 支持的语系数据</span><br><span class="line">-f ：from ，后接原本的编码格式；</span><br><span class="line">-t ：to ，即后来的新编码要是什么格式；</span><br><span class="line">-o file：如果要保留原本的文件，那么使用 -o 新文件名，可以建立新编码文件。</span><br></pre></td></tr></table></figure><p>当你输入命令 iconv –list ，会列出一大堆信息，那就是 iconv 支持的编码。</p><ul><li>举个例子</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">将 /tmp/vitest/vi.big5 转成 utf8 编码。</span><br><span class="line">[root@www ～]# cd /tmp/vitest</span><br><span class="line">[root@www vitest]# iconv -f big5 -t utf8 vi.big5 -o vi.utf8</span><br><span class="line">[root@www vitest]# file vi*</span><br><span class="line">vi.big5: ISO-8859 text, with CRLF line terminators</span><br><span class="line">vi.utf8: UTF-8 Unicode text, with CRLF line terminators</span><br><span class="line">你会发现有明显的不同</span><br></pre></td></tr></table></figure><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><p>整理笔记参考了 <a href="http://linux.vbird.org/linux_basic/0210filepermission.php#filepermission_perm" target="_blank" rel="noopener">《鸟哥的Linux私房菜》</a> 一书。这本书我是买的<a href="http://sale.jd.com/act/W5hugLDc1R.html" target="_blank" rel="noopener">京东阅读</a>的正版电子书籍。<br><br>如果不想买书看的话可以直接戳<a href="http://linux.vbird.org/" target="_blank" rel="noopener">这里进入鸟哥Linux私房菜的线上博客 : http://linux.vbird.org/</a>。请大家支持正版！！<br><br>至于笔记中的命令我是都敲过一遍的并进行了理解，并不是单纯的复制粘贴呦！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Linux-vim编辑器&quot;&gt;&lt;a href=&quot;#Linux-vim编辑器&quot; class=&quot;headerlink&quot; title=&quot;Linux vim编辑器&quot;&gt;&lt;/a&gt;Linux vim编辑器&lt;/h1&gt;&lt;p&gt;没接触Linux之前就经常听到 vi、vim 这两个词，后来
      
    
    </summary>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux文件与文件系统的打包</title>
    <link href="http://yoursite.com/2017/12/11/Linux%E6%96%87%E4%BB%B6%E4%B8%8E%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%89%93%E5%8C%85/"/>
    <id>http://yoursite.com/2017/12/11/Linux文件与文件系统的打包/</id>
    <published>2017-12-11T11:08:38.000Z</published>
    <updated>2017-12-11T11:08:38.771Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>文件与文件系统的压缩与打包</title>
    <link href="http://yoursite.com/2017/12/11/%E6%96%87%E4%BB%B6%E4%B8%8E%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%8E%8B%E7%BC%A9%E4%B8%8E%E6%89%93%E5%8C%85/"/>
    <id>http://yoursite.com/2017/12/11/文件与文件系统的压缩与打包/</id>
    <published>2017-12-11T11:07:28.000Z</published>
    <updated>2017-12-11T11:09:58.366Z</updated>
    
    <content type="html"><![CDATA[<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li><a href="#0">前言</a></li><li><a href="#1">1.压缩文件的用途与技术</a></li><li><a href="#2">2.Linux 系统常见的压缩命令</a><ul><li><a href="#2.1">2.1 gzip,zcat</a></li><li><a href="#2.2">2.2 bzip2,bzcat</a></li></ul></li><li><a href="#3">3.打包命令：tar</a><ul><li><a href="#3.1">3.1 tar</a></li></ul></li><li><a href="#4">4.完整备份工具：dump</a><ul><li><a href="#4.1">4.1 dump</a></li><li><a href="#4.2">4.2 restore</a><h2 id="0">前言</h2></li></ul></li></ul><p>在Linux下面有相当多的压缩指令命令可以运行操作。这些压缩指令命令可以让我们更方便地从网络上面下载大型的文件呢！此外，我们知道在Linux下面的扩展名是没有什么很特殊的意义的，不过，针对这些压缩指令命令所做出来的压缩文件，为了方便记忆，还是会有一些特殊的命名方式。</p><h2 id="1">1. 压缩文件的用途与技术</h2><br>文件太大会导致占据过大的磁盘空间，从网上下载资源时文件过大也会导致传输速度变慢。文件压缩技术就可以解决这类问题。较大型的文件通过文件压缩，可以将它的磁盘使用量降低，可以达到减低文件大小的效果，有的压缩程序还可以进行大小限制，是一个大型文件分成数个小型文件。<br><br>目前计算机系统中都是使用 byte 单位来计量，但计算机最小单位是 bit ，且 1byte=8bit 这意味着每个 byte 当中会有 8 个空格，每个空格可以是 0或1 。当我们将数据记录到计算机，为了满足操作系统数据的访问会将数据转为 byte 的形态来记录，这意味着当数据不满足 1byte 大小，该 byte 里面会有很多拿来“补位”的空格。一些计算机工程师利用复杂的计算方式，将这些没有使用到的空间丢出来，让文件占用的空间变小，这就是压缩技术。<br><br><br><h2 id="2">2. Linux 系统常见的压缩命令</h2><p>Linux 支持的压缩命令非常多，且不同的命令所用的压缩技术命不相同，当然彼此之间就无法相互压缩/解压缩文件。所以，虽然文件扩展名在 Linux 中并没什么卵用，但为了让我们人类知道某个压缩文件是那种压缩命令制作出来的，好用来对照着解压缩，<strong>所以压缩文件的扩展名还是 hin 有必要滴</strong>。以下是几个常见的压缩文件扩展名：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">*.Z compress程序压缩文件（已经不流行，淘汰啦！）</span><br><span class="line">*.gz gzip程序压缩的文件；</span><br><span class="line">*.bz2 bzip2程序压缩的文件；</span><br><span class="line">*.tar tar程序打包的数据，并没有压缩过；</span><br><span class="line">*.tar.gz tar程序打包的文件，其中经过gzip的压缩；</span><br><span class="line">*.tar.bz2 tar程序打包的文件，其中经过bzip2的压缩。</span><br></pre></td></tr></table></figure></p><p><strong>Linux 中最常见的压缩命令就是 gZip和bzip2</strong>。</p><h3 id="2.1">2.1 gZip,zcat</h3><p><strong>gZip 是应用最广的压缩命令</strong>。目前 gZip 可以解开 compress，Zip 与gZip等软件压缩文件。以下是命令语法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@www~]#gzip [-cdtv#] 文件名</span><br><span class="line">[root@www ~]# zcat 文件名.gz</span><br><span class="line">参数：</span><br><span class="line">-c ：将压缩的数据输出到屏幕上，可通过数据流重定向来处理；</span><br><span class="line">-d ：解压缩的参数；</span><br><span class="line">-t ：可以用来检验一个压缩文件的一致性，看看文件有无错误；</span><br><span class="line">-v ：可以显示出原文件/压缩文件的压缩比等信息；</span><br><span class="line">-# ：压缩等级，-1最快，但是压缩比最差，-9 最慢，但是压缩比最好默认是 –6。</span><br><span class="line">``` </span><br><span class="line">- 范例：使用 gZip 进行压缩,默认状态下原文件会被压缩成 .gz 文件，原文件就不存在了。</span><br></pre></td></tr></table></figure></p><p>[root@www ~]#cd /tmp<br>[root@www tmp]#cp/ etc/man.config .<br>[root@www tmp]#gzip -v man.config<br>man.config: 56.1% – replaced with man.config.gz<br>[root@www tmp]# ll /etc/man.config /tmp/man*<br>-rw-r–r–1root root 4617 Jan 6 2007 /etc/man.config<br>-rw-r–r–1root root 2057 Nov 10 17:14 /tmp/man.config.gz &lt;==gzip压缩比较佳<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 范例：用 zcat 将上一范例压缩的文本文件读出来</span><br></pre></td></tr></table></figure></p><p>[root@www tmp]# zcat man.config.gz</p><h1 id="此时屏幕上会显示该压缩文件解压后的文件内容。"><a href="#此时屏幕上会显示该压缩文件解压后的文件内容。" class="headerlink" title="此时屏幕上会显示该压缩文件解压后的文件内容。"></a>此时屏幕上会显示该压缩文件解压后的文件内容。</h1><h1 id="zcat可以读取纯文本文件被压缩后的压缩文件。"><a href="#zcat可以读取纯文本文件被压缩后的压缩文件。" class="headerlink" title="zcat可以读取纯文本文件被压缩后的压缩文件。"></a>zcat可以读取纯文本文件被压缩后的压缩文件。</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 范例：将第一个范例的文件解压缩</span><br></pre></td></tr></table></figure><p>[root@www tmp]#gzip -d man.config.gz</p><h1 id="与gzip相反，gzip-d-会将原本的-gz-删除，产生原本的-man-config-文件。"><a href="#与gzip相反，gzip-d-会将原本的-gz-删除，产生原本的-man-config-文件。" class="headerlink" title="与gzip相反，gzip -d 会将原本的 .gz 删除，产生原本的 man.config 文件。"></a>与gzip相反，gzip -d 会将原本的 .gz 删除，产生原本的 man.config 文件。</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 范例：将上一范例解压缩的文件用最佳压缩比压缩，并保留原来的文件</span><br></pre></td></tr></table></figure><p>[root@www tmp]#gzip -9 -c man.config &gt; man.config.gz</p><p>#其实gzip的压缩已经优化过了，所以虽然gzip提供1~9的压缩等级，不过使用默认的6就非常好用了。因此上述的范例四可以不要加入那个-9的参数。</p><p>#范例的重点在那个-c与&gt;的使用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;h3 id=&quot;2.2&quot;&gt;2.2 bzip2,bzcat&lt;/h3&gt;</span><br><span class="line"></span><br><span class="line">如果gzip是为了替代compress并提供更好的压缩比而成立的，那么bzip2则是为了取代gzip并提供更佳的压缩比而来的。bzip2真是很不错的东西，这玩意的压缩比竟然比gzip还要好。至于bzip2的用法几乎与gzip相同。</span><br></pre></td></tr></table></figure></p><p>[root@www ~]#bzip2[-cdkzv#] 文件名<br>[root@www ~]# bzcat 文件名.bz2<br>参数：<br>-c ：将压缩过程中产生的数据输出到屏幕上；<br>-d ：解压缩的参数；<br>-k ：保留原文件，而不会删除原始的文件；<br>-z ：压缩的参数；<br>-v ：可以显示出原文件/压缩文件的压缩比等信息；<br>-# ：与gzip同样的，都是在计算压缩比的参数，-9 最佳，-1最快。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 范例： 将文件以 bzip2 进行压缩</span><br></pre></td></tr></table></figure></p><p>[root@www tmp]#bzip2-z man.config</p><h1 id="此时-man-config-会变成-man-config-bz2"><a href="#此时-man-config-会变成-man-config-bz2" class="headerlink" title="此时 man.config 会变成 man.config.bz2"></a>此时 man.config 会变成 man.config.bz2</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 范例：将上一范例内容读出来</span><br></pre></td></tr></table></figure><p>[root@www tmp]# bzcat man.config.bz2</p><h1 id="此时屏幕上会显示-man-config-bz2-解压缩之后的文件内容。"><a href="#此时屏幕上会显示-man-config-bz2-解压缩之后的文件内容。" class="headerlink" title="此时屏幕上会显示 man.config.bz2 解压缩之后的文件内容。"></a>此时屏幕上会显示 man.config.bz2 解压缩之后的文件内容。</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 范例： 将第一个范例的文件解压缩</span><br></pre></td></tr></table></figure><p>[root@www tmp]#bzip2 -d man.config.bz2<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 范例： 用最佳压缩比压缩，并保留原文件</span><br></pre></td></tr></table></figure></p><p>[root@www tmp]#bzip2 -9 -c man.config &gt; man.config.bz2<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;h2 id=&quot;3&quot;&gt;3. 打包命令 tar&lt;/h2&gt;</span><br><span class="line"></span><br><span class="line">上面提到的 gip、bzip2大多仅针对单一文件来进行压缩。而将多个文件过目录包成一个大文件的命令功能，称他为 &quot;打包命令&quot; 。Linux 下面这种打包命令就是大名鼎鼎的 **tar** 。 **tar 不仅可以将多个目录或文件打包成一个大文件，还可以通过 gZip/bzip2 的支持，将该文件同时进行压缩**。目前 Windows 的WinRAR 也支持 .tar.gz 文件名的解压缩。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;h3 id=&quot;3.1&quot;&gt;3.1 tar&lt;/h3&gt;</span><br><span class="line"></span><br><span class="line">tar 的参数很多，具体可以找男人 man 一下</span><br></pre></td></tr></table></figure></p><p>[root@www ~]#tar [-j|-z] [cv] [-f 新建的文件名] filename… &lt;==打包与压缩<br>[root@www ~]#tar [-j|-z] [tv] [-f新建的文件名] &lt;==查看文件名<br>[root@www ~]#tar [-j|-z] [xv] [-f 新建的文件名] [-C 目录] &lt;==解压缩<br>参数：<br>-c ：新建打包文件，可搭配 -v 来查看过程中被打包的文件名（filename）。<br>-t ：查看打包文件的内容含有哪些文件名，重点在查看文件名。<br>-x ：解打包或解压缩的功能，可以搭配 -C（大写） 在特定目录解开。<br>特别留意的是，-c, -t, -x 不可同时出现在一串命令行中。<br>-j ：通过bzip2的支持进行压缩/解压缩，此时文件名最好为 <em>.tar.bz2。<br>-z ：通过gzip的支持进行压缩/解压缩，此时文件名最好为 </em>.tar.gz。<br>-v ：在压缩/解压缩的过程中，将正在处理的文件名显示出来。<br>-f filename：-f 后面要接被处理的文件名。建议 -f 单独写一个参数。<br>-C 目录 ：这个参数用在解压缩时，若要在特定目录解压缩，可以使用这个参数。<br>其他后续练习会使用到的参数介绍：<br>-p ：保留备份数据的原本权限与属性，常用于备份（-c）重要的配置文件。<br>-P ：保留绝对路径，即允许备份数据中含有根目录存在之意。<br>–exclude=FILE：在压缩的过程中，不要将 FILE 打包。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 最简单的使用 tar 就只要记忆下面的方式即可</span><br><span class="line"></span><br><span class="line">&gt; 压 缩：tar -jcv -f filename.tar.bz2 要被压缩的文件或目录名称</span><br><span class="line">查 询：tar -jtv -f filename.tar.bz2</span><br><span class="line">解压缩：tar -jxv -f filename.tar.bz2 -C 欲解压缩的目录</span><br><span class="line">filename.tar.bz2 使我们自己取的文件名，tar 并不会主动创建文件名，要我们自定义。所以扩展名就显得很重要了。如果不加 -j|-z 的话，文件名是\*.tar 就行。 使用 -j|-z 最好根据 压缩软件的支持取名为\* .tar.gz或\*.tar.bz2。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- 范例：使用 tar 加入 -j 或 -z 的参数备份 /etc/目录</span><br></pre></td></tr></table></figure></p><p>[root@www ~]#tar -zpcv -f /root/etc.tar.gz /etc<br>tar: Removing leading `/‘ from member names &lt;==注意这个警告消息<br>/etc/<br>….中间省略….<br>/etc/esd.conf<br>/etc/crontab</p><h1 id="由于加上-v-这个参数，因此正在作用中的文件名就会显示在屏幕上。"><a href="#由于加上-v-这个参数，因此正在作用中的文件名就会显示在屏幕上。" class="headerlink" title="由于加上 -v 这个参数，因此正在作用中的文件名就会显示在屏幕上。"></a>由于加上 -v 这个参数，因此正在作用中的文件名就会显示在屏幕上。</h1><h1 id="如果你可以翻到第一页，会发现出现上面的错误信息，下面会讲解。"><a href="#如果你可以翻到第一页，会发现出现上面的错误信息，下面会讲解。" class="headerlink" title="如果你可以翻到第一页，会发现出现上面的错误信息，下面会讲解。"></a>如果你可以翻到第一页，会发现出现上面的错误信息，下面会讲解。</h1><h1 id="至于-p的参数，重点在于保留原本文件的权限与属性之意。"><a href="#至于-p的参数，重点在于保留原本文件的权限与属性之意。" class="headerlink" title="至于 -p的参数，重点在于保留原本文件的权限与属性之意。"></a>至于 -p的参数，重点在于保留原本文件的权限与属性之意。</h1><p>[root@www ~]#tar -jpcv -f /root/etc.tar.bz2 /etc</p><h1 id="显示的消息会跟上面一模一样。"><a href="#显示的消息会跟上面一模一样。" class="headerlink" title="显示的消息会跟上面一模一样。"></a>显示的消息会跟上面一模一样。</h1><p>[root@www ~]# ll /root/etc*<br>-rw-r–r–1root root 8740252 Nov 15 23:07 /root/etc.tar.bz2<br>-rw-r–r–1root root 13010999 Nov 15 23:01/root/etc.tar.gz</p><h1 id="为什么建议你使用-j-这个参数？从上面的数值你可以知道了吧？"><a href="#为什么建议你使用-j-这个参数？从上面的数值你可以知道了吧？" class="headerlink" title="为什么建议你使用 -j 这个参数？从上面的数值你可以知道了吧？"></a>为什么建议你使用 -j 这个参数？从上面的数值你可以知道了吧？</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 使用 tar 文件的数据内容（可查看文件名），与备份文件名有否根目录的意义</span><br></pre></td></tr></table></figure><p>[root@www ~]#tar -jtv -f /root/etc.tar.bz2<br>….前面省略….<br>-rw-r–r– root/root 1016 2008-05-25 14:06:20 etc/dbus-1/session.conf<br>-rw-r–r– root/root 153 2007-01-07 19:20:54 etc/esd.conf<br>-rw-r–r– root/root 255 2007-01-06 21:13:33 etc/crontab<br>如果加上-v 这个参数时，详细的文件权限/属性都会被列出来。<br>如果只是想要知道文件名而已，那么就将-v去掉即可。<br>从上面的数据我们可以发现一件很有趣的事情，那就是每个文件名都没了根目录了。<br>这也是上一个练习中出现的那个警告信息“tar:Removing leading <code>/&#39; from member names（删除了文件名开头的</code>/‘）”所告知的情况。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">去掉根目录的原因主要是为了安全。我们使用tar备份的数据可能会需要解压缩回来使用，在 tar 所记录的文件名（就是我们刚才使用 tar -jtvf 所查看到的文件名）那就是解压缩后的实际文件名。如果去掉了根目录，假设你将备份数据在/tmp 中解开，那么解压缩的文件名就会变成“/tmp/etc/xxx”。但如果没有去掉根目录，解压缩后的文件名就会是绝对路径，即解压缩后的数据一定会被放置到/etc/xxx去。如此一来，你的原本的/etc/下面的数据就会被备份数据所覆盖过去了。</span><br><span class="line"></span><br><span class="line">- 将文件名中的根目录也备份下来，并查看以下内分文件内容文件名</span><br></pre></td></tr></table></figure></p><p>[root@www ~]#tar -jpPcv -f /root/etc.and.root.tar.bz2 /etc<br>….中间过程省略….<br>[root@www ~]#tar -jtf /root/etc.and.root.tar.bz2<br>/etc/dbus-1/session.conf<br>/etc/esd.conf<br>/etc/esd.conf<br>/etc/crontab</p><h1 id="这次查阅文件名不含-v-参数，所以仅有文件名而已，没有详细属性-权限等参数。"><a href="#这次查阅文件名不含-v-参数，所以仅有文件名而已，没有详细属性-权限等参数。" class="headerlink" title="这次查阅文件名不含 -v 参数，所以仅有文件名而已，没有详细属性/权限等参数。"></a>这次查阅文件名不含 -v 参数，所以仅有文件名而已，没有详细属性/权限等参数。</h1><p>有发现不同点了吧？如果加上-P 参数，那么文件名内的根目录就会存在。不过，个人建议，还是不要加上-P 这个参数来备份。毕竟很多时候，我们备份是为了要未来追踪问题用的，倒不一定需要还原回原本的系统中。所以拿去根目录后，备份数据的应用会比较有弹性，也比较安全。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 使用 tar 解打包</span><br></pre></td></tr></table></figure></p><p>[root@www ~]#tar-jxv -f /root/etc.tar.bz2<br>[root@www ~]# ll<br>….（前面省略）….<br>drwxr-xr-x 105 root root 12288 Nov 1104:02 etc<br>….（后面省略）….<br>此时该打包文件会在本目录下进行解压缩的操作。所以，你等一下就会在主文件夹下面发现一个名为 etc 的目录<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">如果想在 /tmp 文件夹下解开这个打包文件，当然可以 `cd/tmp` 但是有一种更简单的方法在指定路径下解压</span><br><span class="line"></span><br><span class="line">- 使用 -C 在指定路径下解压缩</span><br></pre></td></tr></table></figure></p><p>[root@www ~]#tar -jxv -f /root/etc.tar.bz2 -C /tmp<br>[root@www ~]# ll /tmp<br>….（前面省略）….<br>drwxr-xr-x 105 root root 12288 Nov 1104:02 etc<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">- 仅解开单一文件</span><br></pre></td></tr></table></figure></p><h1 id="1-先找到我们要的文件名，假设解开-shadow-文件好了："><a href="#1-先找到我们要的文件名，假设解开-shadow-文件好了：" class="headerlink" title="1. 先找到我们要的文件名，假设解开 shadow 文件好了："></a>1. 先找到我们要的文件名，假设解开 shadow 文件好了：</h1><p>[root@www ~]#tar -jtv -f /root/etc.tar.bz2 |grep’shadow’<br>-r——– root/root 1230 2008-09-29 02:21:20 etc/shadow-<br>-r——– root/root 622 2008-09-29 02:21:20 etc/gshadow-<br>-r——– root/root 636 2008-09-29 02:21:25 etc/gshadow<br>-r——– root/root 1257 2008-09-29 02:21:25 etc/shadow &lt;==这是我们要的。</p><h1 id="先找出重要的文件名。其中那个grep是“选取”关键字的功能。"><a href="#先找出重要的文件名。其中那个grep是“选取”关键字的功能。" class="headerlink" title="先找出重要的文件名。其中那个grep是“选取”关键字的功能。"></a>先找出重要的文件名。其中那个grep是“选取”关键字的功能。</h1><h1 id="2-将该文件解开。语法与实际方法如下："><a href="#2-将该文件解开。语法与实际方法如下：" class="headerlink" title="2. 将该文件解开。语法与实际方法如下："></a>2. 将该文件解开。语法与实际方法如下：</h1><p>[root@www ~]#tar -jxv -f 打包文件.tar.bz2 待解开文件名<br>[root@www ~]#tar -jxv -f /root/etc.tar.bz2 etc/shadow<br>etc/shadow<br>[root@www ~]# ll etc<br>total 8<br>-r——–1root root 1257 Sep29 02:21shadow &lt;==只有一个文件。</p><p>#此时只会解开一个文件而已。不过，重点是那个文件名。你要找到正确的文件名。</p><h1 id="在本例中，你不能写成-etc-shadow-，因为它是记录在-etc-tar-bz2-内的文件名。"><a href="#在本例中，你不能写成-etc-shadow-，因为它是记录在-etc-tar-bz2-内的文件名。" class="headerlink" title="在本例中，你不能写成 /etc/shadow ，因为它是记录在 etc.tar.bz2 内的文件名。"></a>在本例中，你不能写成 /etc/shadow ，因为它是记录在 etc.tar.bz2 内的文件名。</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 打包某目录但不包含该目录下的某些文件做法 --exclude</span><br></pre></td></tr></table></figure><p>[root@www ~]#tar -jcv -f /root/system.tar.bz2 –exclude=/root/etc*  –exclude=/root/system.tar.bz2 /etc/root<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">上面这个例子在打包的时候，将/root/etc* 和本身排除在外进行打包</span><br><span class="line"></span><br><span class="line">- 仅备份比某个时刻还要新的文件 --newer-mtime --newer</span><br><span class="line"></span><br><span class="line">其中 --newer 表示后续的日期包含 mtime（文件内容更改时间）与ctime（文件站状态如权限与属性更改时间），--newer-mtime 只包含 mtime</span><br></pre></td></tr></table></figure></p><p>[root@www ~]#tar-jcv -f /root/etc.newer.then.passwd.tar.bz2  –newer-mtime=”2008/09/29” /etc/*<br>….（中间省略）….<br>/etc/smartd.conf &lt;==真的有备份的文件<br>….（中间省略）….<br>/etc/yum.repos.d/ &lt;==目录都会被记录下来<br>tar: /etc/yum.repos.d/CentOS-Base.repo: file iSunchanged; not dumped</p><h1 id="最后一行显示的是“没有被备份的”，也即-not-dumped-的意思。"><a href="#最后一行显示的是“没有被备份的”，也即-not-dumped-的意思。" class="headerlink" title="最后一行显示的是“没有被备份的”，也即 not dumped 的意思。"></a>最后一行显示的是“没有被备份的”，也即 not dumped 的意思。</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">范例中的仅仅把 /etc/ 文件下,文件内容更改时间 mtime 比 2008/09/29 新的文件进行打包。这个命令是一个对差异文件备份特别方便的命令。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- 基本名称 tarfile tarball</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">tar 打包出来的文件有没有进行压缩所得到的文件称谓的不同。如果只是打包而已，就是 `tar -cv -f file.tar` 而已，这个文件称之为 tarfile。如果还有压缩支持 `tar -jcv -f file.tar.bz2` 即使用 gZip 或 bZip2 进行压缩压缩，称呼为 tarball。当然，这就是一个基本称谓而已。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">此外，tar 除了可以将数据打包成为文件之外，还能够将文件打包到某些特别的设备去，举例来说，磁带机（tape）就是一个常见的例子。磁带机由于是一次性读取/写入的设备，因此我们不能够使用类似 cp 等命令来复制的。那如果想要将/home, /root, /etc 备份到磁带机（/dev/st0）时，就可以使用“tar -cv -f /dev/st0 /home /root /etc”，很简单容易吧？磁带机用在备份（尤其是企业应用）是很常见的工作。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- tar 特殊应用 **利用管道命令与数据流**</span><br><span class="line"></span><br><span class="line">在 tar 的使用中，有一种方式最特殊，那就是通过标准输入输出的数据流重定向（standard input/standard output），以及管道命令（pipe）的方式，将待处理的**文件一边打包一边解压缩到目标目录去**。下面是范例</span><br></pre></td></tr></table></figure><h1 id="将-etc-整个目录一边打包一边在-tmp中解开"><a href="#将-etc-整个目录一边打包一边在-tmp中解开" class="headerlink" title="将 /etc 整个目录一边打包一边在 /tmp中解开"></a>将 /etc 整个目录一边打包一边在 /tmp中解开</h1><p>[root@www ~]#cd /tmp<br>[root@www ~]#tar -cvf - /etc |tar-xvf -</p><h1 id="这个操作有点像是cp-r-etc-tmp依旧是有其有用途的。"><a href="#这个操作有点像是cp-r-etc-tmp依旧是有其有用途的。" class="headerlink" title="这个操作有点像是cp -r /etc /tmp依旧是有其有用途的。"></a>这个操作有点像是cp -r /etc /tmp依旧是有其有用途的。</h1><h1 id="要注意的地方在于输出文件变成-而输入文件也变成-，又有一个-存在。"><a href="#要注意的地方在于输出文件变成-而输入文件也变成-，又有一个-存在。" class="headerlink" title="要注意的地方在于输出文件变成 - 而输入文件也变成 - ，又有一个 | 存在。"></a>要注意的地方在于输出文件变成 - 而输入文件也变成 - ，又有一个 | 存在。</h1><h1 id="这分别代表-standard-output-standard-input-与管道命令。"><a href="#这分别代表-standard-output-standard-input-与管道命令。" class="headerlink" title="这分别代表 standard output, standard input 与管道命令。"></a>这分别代表 standard output, standard input 与管道命令。</h1><h1 id="简单的想法中，你可以将-想成是在内存中的一个设备（缓冲区）。"><a href="#简单的想法中，你可以将-想成是在内存中的一个设备（缓冲区）。" class="headerlink" title="简单的想法中，你可以将 - 想成是在内存中的一个设备（缓冲区）。"></a>简单的想法中，你可以将 - 想成是在内存中的一个设备（缓冲区）。</h1><h1 id="在当前目录下-ll-你会发现，目录下会直接出现-解压后的-etc"><a href="#在当前目录下-ll-你会发现，目录下会直接出现-解压后的-etc" class="headerlink" title="在当前目录下 ll 你会发现，目录下会直接出现 解压后的 etc/"></a>在当前目录下 ll 你会发现，目录下会直接出现 解压后的 etc/</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">上面的例子中，想要将 /etc 下面的数据直接复制到目前路径下 /tmp，但是又觉得直接复制 cp -r /etc /tmp 有点麻烦，那么就直接以这个方式来打包，其中，命令里面的 - 就是表示那个被打包的文件。由于我们不想让那个中间文件存在，所以就用这个方式来进行复制行为。</span><br><span class="line"></span><br><span class="line">- 系统备份范例</span><br><span class="line"></span><br><span class="line">系统上有非常多的重要目录需要进行备份，而且其实我们也不建议你将备份数据放置到/root目录下。假设目前你已经知道重要的目录有下面这几个：</span><br><span class="line">/etc/（配置文件）</span><br><span class="line">/home/（用户的主文件夹）</span><br><span class="line">/var/spool/mail/（系统中，所有账号的邮件信箱）</span><br><span class="line">/var/spool/cron/（所有账号的工作调度配置文件）</span><br><span class="line">/root（系统管理员的主文件夹）</span><br><span class="line">/home/loop*不需要备份，而且/root下面的压缩文件也不需要备份，另外假设你要将备份的数据放置到/backups，并且该目录仅有 root 有权限进入。此外，每次备份的文件名都希望不相同，例如使用backup-system-20171011.tar.bz2 之类的文件名来处理。那你该如何处理这个备份数据呢？（请先动手操作试试，再来查看一下下面的参考解答。）</span><br></pre></td></tr></table></figure><p>#1. 先处理要放置备份数据的目录与权限：<br>[root@www ~]# mkdir /backups<br>[root@www ~]#chmod 700 /backups<br>[root@www ~]# ll -d /backups<br>drwx—— 2 root root 4096 Nov 30 16:35 /backups</p><h1 id="2-假设今天是-2017-10-11-，则新建备份的方式如下："><a href="#2-假设今天是-2017-10-11-，则新建备份的方式如下：" class="headerlink" title="2. 假设今天是 2017/10/11 ，则新建备份的方式如下："></a>2. 假设今天是 2017/10/11 ，则新建备份的方式如下：</h1><p>[root@www ~]#tar -jcv -f /backups/backup-system-20171011.tar.bz2 \</p><blockquote><p>–exclude=/root/<em>.bz2 –exclude=/root/</em>.gz –exclude=/home/loop* \<br>/etc /home /var/spool/mail /var/spool/cron /root<br>…. 这是一个超级漫长的过程….<br>[root@www ~]# ll -h /backups/<br>-rw-r–r–1root root 8.4M Nov 30 16:43 backup-system-20091130.tar.bz2<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;h2 id=&quot;4&quot;&gt;4. 完整备份工具：dump&lt;/h2&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">某些夜黑人静的夜晚，你想要针对文件系统进行备份或者存储功能时，不能不谈到这个 dump 命令。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;h3 id=&quot;4.1&quot;&gt;4.1 dump&lt;/h3&gt;</span><br><span class="line"></span><br><span class="line">假设你的 /home 是独立的一个文件系统，那你第一次进行过dump后，再进行第二次dump时，你可以指定不同的备份等级，假如指定等级为1时，此时新备份的数据只会记录与第一次备份所有差异的文件而已。</span><br><span class="line">比如，第一次备份时使用的是 level 0，这个等级也是完整的备份。等到第二次备份时，实时文件系统内的数据已经与 level 0 不一样了，而level1 仅只是比较目前的文件系统与 level 0 之间的差异后，备份有变化过的文件而已。至于 level 2则是与 level 1 进行比较。</span><br><span class="line"></span><br><span class="line">- dump 对单一文件备份的限制</span><br><span class="line"></span><br><span class="line">`dump` 支持对整个文件系统或者是单一目录，但是**对单一目录的支持比较不足**，废话要不然还要 `tar`干啥。</span><br><span class="line">如果是单一文件系统，那么该文件系统可以使用完整的dump功能，包括利用0~9的数个level来备份，同时，备份时可以使用挂载点或者是设备文件名（例如/dev/sda5 之类的设备文件名）来进行备份。 但如果带备份数据只是目录，并非单一文件系统就包括以下限制</span><br><span class="line"></span><br><span class="line">&gt; 所有的备份数据都必须要在该目录（本例为/home/someone/）下面；</span><br><span class="line">&gt;且仅能使用 level 0，即仅支持完整备份而已；</span><br><span class="line">&gt;不支持-u参数，即无法创建/etc/dumpdates这个level备份的时间记录文件。</span><br><span class="line">&gt;dump 的参数虽然非常繁杂，不过如果只是想要简单的操作时，你只要记得下面的几个参数就很够用了。</span><br><span class="line"></span><br><span class="line">- dump 简单操作</span><br></pre></td></tr></table></figure></p></blockquote><p>[root@www ~]# dump [-Suvj] [-level] [-f 备份文件] 待备份数据<br>[root@www ~]# dump -W<br>参数：<br>-S ：仅列出后面的待备份数据需要多少磁盘空间才能够备份完毕；<br>-u ：将这次 dump的时间记录到 /etc/dumpdateS文件中；<br>-v ：将 dump的文件过程显示出来；<br>-j ：加入bzip2的支持，将数据进行压缩，默认bzip2压缩等级为 2；<br>-level：就是我们谈到的等级，从 -0 ~ -9 共10个等级；<br>-f ：有点类似tar，后面接产生的文件，可接例如 /dev/st0 设备文件名等；<br>-W ：列出在 /etc/fstab 里面的具有 dump设置的分区是否有备份过。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 用 dump 备份完整的文件系统</span><br></pre></td></tr></table></figure></p><h1 id="1-先找出系统中最小的那个文件系统，如下所示："><a href="#1-先找出系统中最小的那个文件系统，如下所示：" class="headerlink" title="1. 先找出系统中最小的那个文件系统，如下所示："></a>1. 先找出系统中最小的那个文件系统，如下所示：</h1><p>[root@www ~]# df -h<br>Filesystem Size Used Avail Use% Mounted on<br>/dev/hdc2 9.5G 3.7G 5.3G 42% /<br>/dev/hdc3 4.8G 651M 3.9G 15% /home<br>/dev/hdc1 99M 11M 83M 12% /boot &lt;==看起来最小的就是它。<br>tmpfS 363M 0 363M 0% /dev/shm</p><h1 id="2-先测试一下如果要备份此文件系统需多少容量"><a href="#2-先测试一下如果要备份此文件系统需多少容量" class="headerlink" title="2. 先测试一下如果要备份此文件系统需多少容量"></a>2. 先测试一下如果要备份此文件系统需多少容量</h1><p>[root@www ~]# dump -S/dev/hdc1<br>5630976 &lt;==注意一下，这个单位是 byte，所以差不多是 5.6MB。</p><h1 id="3-将完整备份的文件名记录成为-root-boot-dump，同时更新记录文件："><a href="#3-将完整备份的文件名记录成为-root-boot-dump，同时更新记录文件：" class="headerlink" title="3. 将完整备份的文件名记录成为 /root/boot.dump，同时更新记录文件："></a>3. 将完整备份的文件名记录成为 /root/boot.dump，同时更新记录文件：</h1><p>[root@www ~]# dump -0u -f /root/boot.dump/boot<br>DUMP: Date of thiSlevel0dump: Tue Dec 2 02:53:45 2008&lt;==记录等级与备份时间<br>DUMP: Dumping /dev/hdc1（/boot）to /root/boot.dump &lt;==dump的源与目标<br>DUMP: Label: /boot &lt;==文件系统的 label<br>DUMP: Writing 10 Kilobyte records<br>DUMP: mapping（PasSI）[regular files] &lt;==开始进行文件对应<br>DUMP: mapping（PasSII）[directories]<br>DUMP: estimated 5499 blocks. &lt;==评估整体block数量<br>DUMP: Volume1started with block1at: Tue Dec 2 02:53:46 2008<br>DUMP: dumping（PasSIII）[directories] &lt;==开始 dump工作<br>DUMP: dumping（PasSIV）[regular files]<br>DUMP:Closing /root/boot.dump &lt;==结束写入备份文件<br>DUMP: Volume1completed at: Tue Dec 2 02:53:47 2008<br>DUMP: Volume15550 blockS（5.42MB） &lt;==最终备份数据容量<br>DUMP: Volume1took 0:00:01<br>DUMP: Volume1transfer rate: 5550 kB/s<br>DUMP: 5550 blockS（5.42MB）on1volume（s）<br>DUMP: finished in1seconds, throughput 5550 kBytes/sec<br>DUMP: Date of thiSlevel0dump: Tue Dec 2 02:53:45 2008<br>DUMP: Date thiSdumpCompleted: Tue Dec 2 02:53:47 2008<br>DUMP: Average transfer rate: 5550 kB/s<br>DUMP: DUMPISDONE</p><h1 id="在命令的执行方面，dump后面接-boot-或-dev-hdc1都可以的。"><a href="#在命令的执行方面，dump后面接-boot-或-dev-hdc1都可以的。" class="headerlink" title="在命令的执行方面，dump后面接 /boot 或 /dev/hdc1都可以的。"></a>在命令的执行方面，dump后面接 /boot 或 /dev/hdc1都可以的。</h1><h1 id="而执行-dump的过程中会出现如上的一些信息，你可以自行仔细查看。"><a href="#而执行-dump的过程中会出现如上的一些信息，你可以自行仔细查看。" class="headerlink" title="而执行 dump的过程中会出现如上的一些信息，你可以自行仔细查看。"></a>而执行 dump的过程中会出现如上的一些信息，你可以自行仔细查看。</h1><p>[root@www ~]# ll /root/boot.dump/etc/dumpdates<br>-rw-rw-r–1root disk 43 Dec 2 02:53 /etc/dumpdates<br>-rw-r–r–1root root 5683200 Dec 2 02:53 /root/boot.dump</p><h1 id="由于加上-u-的选项，因此-etc-dumpdates文件的内容会被更新。注意，"><a href="#由于加上-u-的选项，因此-etc-dumpdates文件的内容会被更新。注意，" class="headerlink" title="由于加上 -u 的选项，因此 /etc/dumpdates文件的内容会被更新。注意，"></a>由于加上 -u 的选项，因此 /etc/dumpdates文件的内容会被更新。注意，</h1><h1 id="这个文件仅有在-dump完整的文件系统时才有支持自动更新的功能。"><a href="#这个文件仅有在-dump完整的文件系统时才有支持自动更新的功能。" class="headerlink" title="这个文件仅有在 dump完整的文件系统时才有支持自动更新的功能。"></a>这个文件仅有在 dump完整的文件系统时才有支持自动更新的功能。</h1><h1 id="4-查看一下系统自动新建的记录文件："><a href="#4-查看一下系统自动新建的记录文件：" class="headerlink" title="4. 查看一下系统自动新建的记录文件："></a>4. 查看一下系统自动新建的记录文件：</h1><p>[root@www ~]#cat /etc/dumpdates<br>/dev/hdc1 0 Tue Dec 2 02:53:47 2008 +0800<br>[文件系统] [等级] [ Ctime 的时间 ]</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">这样就很简单的新建了/root/boot.dump 文件。该文件将整个 /boot 文件系统都备份下来，并且将备份时间写入 /etc/dumpdates 文件中，准备让下次备份时可以做一个参考依据。</span><br><span class="line"></span><br><span class="line">- 新建 level 1 备份</span><br></pre></td></tr></table></figure><h1 id="1-看一下有没有任何文件系统被-dump过的数据"><a href="#1-看一下有没有任何文件系统被-dump过的数据" class="headerlink" title="1. 看一下有没有任何文件系统被 dump过的数据"></a>1. 看一下有没有任何文件系统被 dump过的数据</h1><p>[root@www ~]# dump -W<br>Last dump（s）done（Dump’&gt;’ file systems）:</p><blockquote><p>/dev/hdc2 （ /）Last dump: never<br>/dev/hdc3 （ /home）Last dump: never<br>/dev/hdc1 （ /boot）Last dump: Level 0, Date Tue Dec 2 02:53:47 2008</p><h1 id="如上面的结果，该结果会找出-etc-fstab-里面第五字段设置有需要-dump的"><a href="#如上面的结果，该结果会找出-etc-fstab-里面第五字段设置有需要-dump的" class="headerlink" title="如上面的结果，该结果会找出 /etc/fstab 里面第五字段设置有需要 dump的"></a>如上面的结果，该结果会找出 /etc/fstab 里面第五字段设置有需要 dump的</h1><h1 id="分区，然后与-etc-dumpdateS进行比对，可以得到上面的结果。"><a href="#分区，然后与-etc-dumpdateS进行比对，可以得到上面的结果。" class="headerlink" title="分区，然后与 /etc/dumpdateS进行比对，可以得到上面的结果。"></a>分区，然后与 /etc/dumpdateS进行比对，可以得到上面的结果。</h1><h1 id="尤其是第三行，可以显示我们曾经对-dev-hdc1进行过-dump的备份操作。"><a href="#尤其是第三行，可以显示我们曾经对-dev-hdc1进行过-dump的备份操作。" class="headerlink" title="尤其是第三行，可以显示我们曾经对 /dev/hdc1进行过 dump的备份操作。"></a>尤其是第三行，可以显示我们曾经对 /dev/hdc1进行过 dump的备份操作。</h1><h1 id="2-先恶搞一下，新建一个大约-10-MB-的文件在-boot-内："><a href="#2-先恶搞一下，新建一个大约-10-MB-的文件在-boot-内：" class="headerlink" title="2. 先恶搞一下，新建一个大约 10 MB 的文件在 /boot 内："></a>2. 先恶搞一下，新建一个大约 10 MB 的文件在 /boot 内：</h1><p>[root@www ~]#dd if=/dev/zero of=/boot/testing.img bs=1MCount=10<br>10+0 recordSin<br>10+0 recordSout<br>10485760 byteS（10 MB）Copied, 0.166128 seconds, 63.1MB/s</p><h1 id="3-开始新建差异备份文件，此时我们使用-level-1吧："><a href="#3-开始新建差异备份文件，此时我们使用-level-1吧：" class="headerlink" title="3. 开始新建差异备份文件，此时我们使用 level 1吧："></a>3. 开始新建差异备份文件，此时我们使用 level 1吧：</h1><p>[root@www ~]# dump -1u -f /root/boot.dump.1/boot<br>….（中间省略）….<br>[root@www ~]# ll /root/boot*<br>-rw-r–r–1root root 5683200 Dec 2 02:53 /root/boot.dump<br>-rw-r–r–1root root 10547200 Dec 2 02:56 /root/boot.dump.1</p><h1 id="看看文件大小，岂不是就是刚才我们所新建的那个大文件的大小吗？"><a href="#看看文件大小，岂不是就是刚才我们所新建的那个大文件的大小吗？" class="headerlink" title="看看文件大小，岂不是就是刚才我们所新建的那个大文件的大小吗？"></a>看看文件大小，岂不是就是刚才我们所新建的那个大文件的大小吗？</h1><h1 id="4-最后再看一下是否有记录-level-1备份的时间点呢？"><a href="#4-最后再看一下是否有记录-level-1备份的时间点呢？" class="headerlink" title="4. 最后再看一下是否有记录 level 1备份的时间点呢？"></a>4. 最后再看一下是否有记录 level 1备份的时间点呢？</h1><p>[root@www ~]# dump -W<br>Last dump（s）done（Dump’&gt;’ file systems）:<br>/dev/hdc2 （ /）Last dump: never<br>/dev/hdc3 （ /home）Last dump: never<br>/dev/hdc1 （ /boot）Last dump: Level 1, Date Tue Dec 2 02:56:33 2008<br>….（中间省略）….<br>通过这个简单的方式，我们就能够仅备份差异文件的部分了。下面再来看看针对单一目录的dump用途。<br>用dump备份非文件系统，即单一目录的方法<br>现在让我们来处理一下/etc的dump备份。因为/etc并非单一文件系统，它只是个目录而已。所以依据限制的说明，-u evel 1~9 都是不适用的。我们只能够使用 level 0 的完整备份将/etcdump 下来，因此就变得很简单了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- dump 备份单一目录</span><br></pre></td></tr></table></figure></p></blockquote><p>#让我们将 /etc 整个目录通过 dump进行备份，且含压缩功能<br>[root@www ~]# dump -0j -f /root/etc.dump.bz2 /etc<br>DUMP: Date of thiSlevel0dump: Tue Dec 2 12:08:22 2008<br>DUMP: Dumping /dev/hdc2（/（dir etc））to /root/etc.dump.bz2<br>DUMP: Label: /1<br>DUMP: Writing 10 Kilobyte records<br>DUMP:Compressing output atCompression level 2（bzlib）<br>DUMP: mapping（PasSI）[regular files]<br>DUMP: mapping（PasSII）[directories]<br>DUMP: estimated 115343 blocks.<br>DUMP: Volume1started with block1at: Tue Dec 2 12:08:23 2008<br>DUMP: dumping（PasSIII）[directories]<br>DUMP: dumping（PasSIV）[regular files]<br>DUMP:Closing /root/etc.dump.bz2<br>DUMP: Volume1completed at: Tue Dec 2 12:09:49 2008<br>DUMP: Volume1took 0:01:26<br>DUMP: Volume1transfer rate: 218 kB/s<br>DUMP: Volume1124680kB uncompressed, 18752kBCompressed, 6.649…</p><h1 id="上面特殊字体的部分显示：原本有-124680KB-的容量，被压缩成为-18752KB，"><a href="#上面特殊字体的部分显示：原本有-124680KB-的容量，被压缩成为-18752KB，" class="headerlink" title="上面特殊字体的部分显示：原本有 124680KB 的容量，被压缩成为 18752KB，"></a>上面特殊字体的部分显示：原本有 124680KB 的容量，被压缩成为 18752KB，</h1><h1 id="整个压缩比为-6-649-1，还可以。"><a href="#整个压缩比为-6-649-1，还可以。" class="headerlink" title="整个压缩比为 6.649:1，还可以。"></a>整个压缩比为 6.649:1，还可以。</h1><p>一般来说dump不会使用包含压缩的功能，不过如果你想要将备份的空间降低的话，那个-j的参数是可以使用的。加上-j之后你的dump结果会使用较少的硬盘空间。如上述的情况来看，文件大小由原本的128MB左右下滑到18MB左右，当然可以节省备份空间。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;h3 id=&quot;4.2&quot;&gt;4.3 restore&lt;/h3&gt;</span><br><span class="line"></span><br><span class="line">备份文件就是在急用时可以恢复系统的重要数据。所以有备份当然要学习如何恢复。dump 的恢复使用的就是 restore 这个命令。它的参数相当多，可以自行 man restore,下面仅是一个简单的介绍。</span><br></pre></td></tr></table></figure></p><p>[root@www ~]# restore -t [-f dumpfile] [-h] &lt;==用来查看 dump文件<br>[root@www ~]# restore -C [-f dumpfile] [-D挂载点] &lt;==比较dump与实际文件<br>[root@www ~]# restore -i [-f dumpfile] &lt;==进入互动模式<br>[root@www ~]# restore -r [-f dumpfile] &lt;==还原整个文件系统<br>参数：<br>相关的各种模式，各种模式无法混用。例如不可以写 -tC 。<br>-t ：此模式用在查看 dump起来的备份文件中含有什么重要数据。类似tar-t 功能。<br>-C ：此模式可以将 dump内的数据拿出来跟实际的文件系统做比较，<br>最终会列出“在 dump文件内有记录的，且目前文件系统不一样”的文件。<br>-i ：进入互动模式，可以仅还原部分文件，用在 dump目录时的还原。<br>-r ：将整个文件系统还原的一种模式，用在还原针对文件系统的 dump备份。<br>其他较常用到的参数功能：<br>-h ：查看完整备份数据中的 inode 与文件系统 label 等信息。<br>-f ：后面就接你要处理的那个 dump文件。<br>-D ：与 -C 进行搭配，可以查出后面接的挂载点与 dump内有不同的文件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 使用 restore -t 查阅 dump 内容</span><br></pre></td></tr></table></figure></p><p>[root@www ~]# restore -t -f /root/boot.dump<br>Dump date: Tue Dec 2 02:53:45 2008 &lt;==说明备份的日期<br>Dumped from: the epoch<br>Level0dumpof /boot on www.vbird.tsai:/dev/hdc1 &lt;==说明 level 状态<br>Label: /boot &lt;==说明该文件系统的表头。<br>2 .<br>11 ./lost+found<br>2009 ./grub<br>2011 ./grub/grub.conf<br>….下面省略….<br>[root@www ~]# restore -t -f /root/etc.dump<br>Dumptape isCompressed. &lt;==加注说明数据有压缩<br>Dump date: Tue Dec 2 12:08:22 2008<br>Dumped from: the epoch<br>Level0dumpof /（dir etc）on ubuntu:/dev/hdc2 &lt;==是目录。<br>Label: /1<br>2 .<br>1912545 ./etc<br>1912549 ./etc/rpm<br>1912550 ./etc/rpm/platform<br>….下面省略….<br>这个查阅的数据其实显示出的是文件名与原文件的inode状态，所以我们可以说，dump会参考inode的记录。通过这个查询我们也能知道dump的内容为何<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 比较差异并且还原整个文件系统</span><br><span class="line"></span><br><span class="line">dump 可以进行累计备份，是因为它具有可以查询文件系统与备份文件之间的差异，并且将分析到的差异数据进行备份的缘故。</span><br></pre></td></tr></table></figure></p><h1 id="1-先尝试更改文件系统的内容："><a href="#1-先尝试更改文件系统的内容：" class="headerlink" title="1. 先尝试更改文件系统的内容："></a>1. 先尝试更改文件系统的内容：</h1><p>[root@www ~]#cd /boot<br>[root@www boot]# mvConfig-2.6.18-128.el5Config-2.6.18-128.el5-back</p><h1 id="2-看看查询文件系统与备份文件之间的差异。"><a href="#2-看看查询文件系统与备份文件之间的差异。" class="headerlink" title="2. 看看查询文件系统与备份文件之间的差异。"></a>2. 看看查询文件系统与备份文件之间的差异。</h1><p>[root@www boot]# restore -C -f /root/boot.dump<br>Dump date: Tue Dec 2 02:53:45 2008<br>Dumped from: the epoch<br>Level0dumpof /boot on ubuntu:/dev/hdc1<br>Label: /boot<br>filesys= /boot<br>restore: unable to stat ./config-2.6.18-128.el5: No such file or directory Some fileSwere modified!<br>1compare errors</p><h1 id="看到上面的特殊字体了吧。那就是有差异的部分。总共有一个文件被更改。"><a href="#看到上面的特殊字体了吧。那就是有差异的部分。总共有一个文件被更改。" class="headerlink" title="看到上面的特殊字体了吧。那就是有差异的部分。总共有一个文件被更改。"></a>看到上面的特殊字体了吧。那就是有差异的部分。总共有一个文件被更改。</h1><p>```</p><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><p>整理笔记参考了 <a href="http://linux.vbird.org/linux_basic/0210filepermission.php#filepermission_perm" target="_blank" rel="noopener">《鸟哥的Linux私房菜》</a> 一书。这本书我是买的<a href="http://sale.jd.com/act/W5hugLDc1R.html" target="_blank" rel="noopener">京东阅读</a>的正版电子书籍。<br><br>如果不想买书看的话可以直接戳<a href="http://linux.vbird.org/" target="_blank" rel="noopener">这里进入鸟哥Linux私房菜的线上博客 : http://linux.vbird.org/</a>。请大家支持正版！！<br><br>至于笔记中的命令我是都敲过一遍的并进行了理解，并不是单纯的复制粘贴呦！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; class=&quot;headerlink&quot; title=&quot;目录&quot;&gt;&lt;/a&gt;目录&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#0&quot;&gt;前言&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#1&quot;&gt;1.压缩文件的用途与技术&lt;/a&gt;&lt;/li&gt;

      
    
    </summary>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux的文件权限与目录配置</title>
    <link href="http://yoursite.com/2017/12/11/Linux%E7%9A%84%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90%E4%B8%8E%E7%9B%AE%E5%BD%95%E9%85%8D%E7%BD%AE/"/>
    <id>http://yoursite.com/2017/12/11/Linux的文件权限与目录配置/</id>
    <published>2017-12-11T10:58:47.000Z</published>
    <updated>2017-12-11T11:37:30.963Z</updated>
    
    <content type="html"><![CDATA[<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li><a href="#1">1. Linux文件权限</a><ul><li><a href="#1.1">1.1 用户与用户组</a></li><li><a href="#1.2">1.2 Linux文件权限概念</a></li></ul></li><li><a href="#2">2. Linux目录配置</a><ul><li><a href="#2.1">2.1 Linux目录配置</a></li></ul></li></ul><h2 id="1">1. Linux文件权限</h2><blockquote><p>Linux最优秀的地方之一，就在于它的<strong>多用户、多任务环境</strong>。而为了让各个用户具有较保密的文件数据，因此文件的权限管理就变得很重要了。Linux一般将文件可存取访问的身份分为 3 个类别，分别是<strong>owner、group、others</strong>，且 3 种身份各有<strong>read、write、execute</strong>等权限。</p></blockquote><h3 id="1.1">1.1 用户与用户组</h3><ul><li>文件所有者（用户）</li></ul><blockquote><p>　由于 Linux 是多用户多、多任务的系统，因此可能常常会有很多人同时在这套主机来进行工作的情况发生，为了考虑每个人的隐私权以及每个热洗好的工作环境，因此 “文件所有者” 的概念就显得<strong>相当重要</strong>。<br><br>　例如当你将你的Email情书转存成文件之后，放在你自己的主文件夹中，你总不希望被其他人看见自己的情书吧？这个时候你就把该文件<strong>设置成只有文件所有者才能查看与修改这个文件的内容</strong>，那么即使其他人知道你有这个相当“有趣”的文件，不过由于<strong>你有设置适当的权限，所以其他人自然也就无法知道该文件的内容</strong>。</p></blockquote><ul><li>用户组</li></ul><blockquote><p>　其实用户组最有用的功能之一，就是当你在团队开发资源的时候。不同团体之间是有竞争性质的，但却要交纳同一份报告。<strong>每组的组员之间必须要能够互相修改对方的数据，但是其他组的组员则不能看到本组自己的文件内容</strong>，此时该如何是好？<br><br>　在Linux下面这样的限制是很简单的，可以<strong>进行简单的文件权限设置，就能限制非自己团队（也即是用户组）的其他人不能够阅览内容，而且也可以让自己的团队成员可以修改你所创建的文件</strong>。同时，如果你自己还有私人隐密的文件，仍然可以设置成让自己的团队成员也看不到我的文件数据。</p></blockquote><p><strong>不过 root 用户（超级用户）可以到达任何他想去的地方哦！</strong></p><ul><li>Linux 用户身份与用户组记录的文件</li></ul><blockquote><p>Linux 系统中，默认所有系统账号与一般身份用户和 root 相关信息都记录在 <strong>/etc/passwd</strong> 这个文件内可以使用 <code>cat</code>命令查看该文件中是否有指定用户。所有用户组名都记录在 <strong>/etc/group</strong> 文件内，同样可以使用 <code>cat</code>查看。个人密码记录在  <strong>/etc/shadow</strong> 文件下（默认只用 root 才可以打开这个文件）。</p></blockquote><h3 id="1.2">1.2 Linux文件权限概念</h3><ul><li>Linux 文件属性</li></ul><p><strong>以 root 身份登录</strong> Linux 执行 <code>ls -al</code>(list命令，显示文件档案相关属性， 常用命令 <code>-l</code>)</p><blockquote><p>[root@www ~]# ls -al<br><br>total 156<br><br>drwxr-x—　4　root　root　4096　Sep　8 14:06 .<br><br>drwxr-xr-x　23　root　root　4096　Sep　8 14:21 ..<br><br>-rw——-　1　root　root　1474　Sep　4 18:27 anaconda-ks.cfg<br><br>-rw——-　1　root　root　199　Sep　8 17:14 .bash_history<br><br>-rw-r–r–　1　root　root　　24　Jan　6　2007 .bash_logout<br><br>-rw-r–r–　1　root　root　191　Jan　6　2007 .bash_profil<br>-rw-r–r–　1　root　root　176　Jan　6　2007 .bashrc<br><br>-rw-r–r–　1　root　root　100　Jan　6　2007 .cshrc<br><br>drwx——　3　root　root　4096　Sep　5 10:37 .gconf　&lt;=范例说明处<br><br>drwx——　2　root　root　4096　Sep　5 14:09 .gconfd`<br><br>-rw-r–r–　1　root　root　42304　Sep　4 18:26 install.log &lt;=范例说明处<br><br>-rw-r–r–　1　root　root　5661　Sep　4 18:25 install.log.syslog<br><br> [1] 　　　[2]　　[３]　[４]　[５]　[　６　　　]　　[７]<br><br>[１权限 ] 　 [２连接]　[３所有者]　　[４用户组]　[５文件容量]　　　[６修改日期]　[７文件名]</p></blockquote><ul><li>第一列权限与文件类型</li></ul><p>仔细看的话，会发现这里共有十个字符</p><blockquote><p>第一个字符代表这个文件是“目录、文件或链接文件等”。<br><br>若是[d]则是目录，例如上面文件名为“.gconf”的第11行。<br><br>若是[-]则是文件，例如上面文件名为“install.log”第5行。<br><br>若是[l]则表示为连接文件（linkfile）。<br><br>若是[b]则表示设备文件里面的可供存储的接口设备。<br><br>若是[c]则表示设备文件里面的串行端口设备，例如键盘、鼠标（一次性读取设备）。<br><br>接下来的字符中，以3个为一组，且<strong>均为“rwx”的3个参数的组合</strong>。<strong>其中[r]代表可读（read）， [w]代表可写（write），[x]代表可执行（execute）。要注意的是，这3个权限的位置不会改变</strong>，<strong>如果没有权限，就会出现减号[-]而已</strong>。</p></blockquote><ul><li>其他列解释</li></ul><blockquote><p>根据每列的名字可以看出个大概，此处省略，大家可以<a href="http://linux.vbird.org/linux_basic/0210filepermission.php#filepermission_perm" target="_blank" rel="noopener">戳这里《看看鸟哥的Linux私房菜》</a>是怎么说的。</p></blockquote><ul><li>改变文件属性与权限</li></ul><blockquote><p><strong>chgrp：改变文件所属用户组</strong>。<br><br>chgrp改变一个文件的用户组真是很简单的，直接以chgrp来改变即可，这个命令就是change group的简称。不过，请记得，要被改变的组名必须要在/etc/group文件内存在才行，否则就会显示错误。<br><br>[root@www ~]# chgrp [-R] dirname/filename …<br><br>选项与参数：<br><br>-R : 进行递归（recursive）的持续更改，也即连同子目录下的所有文件、目录都更新成为这个用户组之意。常常用在更改某一目录内所有的文件情况。<br><br>范例：<br><br>[root@www ~]# chgrp users install.log<br><br>[root@www ~]# ls -l<br><br>-rw-r–r– 1 root users 68495 Jun 25 08:53 install.log</p><p><strong>chown：改变文件所有者</strong>。<br><br>[root@www ~]# chown [-R] 账号名称 文件或目录<br><br>[root@www ~]# chown [-R] 账号名称:组名 文件或目参数：<br>-R : 进行递归（recursive）的持续更改，即连同子目录下的所有文件都更改<br><br>范例：将install.log的所有者改为bin这个账号：<br><br>[root@www ~]# chown bin install.log<br><br>[root@www ~]# ls -l<br><br>-rw-r–r– 1 bin users 68495 Jun 25 08:53 install.log<br><br>范例：将install.log的所有者与用户组改回为root：<br><br>[root@www ~]# chown root:root install.log<br><br>[root@www ~]# ls -l<br><br>-rw-r–r– 1 root root 68495 Jun 25 08:53 install.log</p><p><strong>chmod：改变文件的权改变所属用户组</strong>：<br>文件权限的改变使用的是chmod这个命令，但是权限的设置方法有两种，分别可以使用<strong>数字</strong>或者是<strong>符号</strong>来进行权限的更改。<br><br><em>数字类型改变文件权限</em> :<br><br>Linux文件的基本权限就有9个，分别是owner、group、others三种身份各有自己的read、write、execute权限，先复习一下刚刚上面提到的数据：文件的权限字符为“-rwxrwxrwx”，这 9 个权限是三个三个一组的。其中，我们可以使用数字来代表各个权限，各权限的分数对照表如下：<br><br>r:4<br><br>w:2<br><br>x:1<br><br>每种身份（owner、group、others）各自的三个权限（r、w、x）分数是需要累加的，例如当权限为 [-rwxrwx—]，分数则是：<br><br>owner = rwx = 4+2+1 = 7<br><br>group = rwx = 4+2+1 = 7<br><br>others= — = 0+0+0 = 0<br><br>所以等一下我们设置权限的更改时，该文件的权限数字就是770，更改权限的命令chmod的语法是这样的：<br><br>[root@www ~]# chmod [-R] xyz 文件或目录<br><br>参数：<br><br>xyz : 就是刚刚提到的数字类型的权限属性，为 rwx 属性数值的相加。<br><br>-R : 进行递归（recursive）的持续更改，即连同子目录下的所有文件都会更改<br><br>举例来说，如果要将.bashrc这个文件所有的权限都设置启用，那么就执行<br><br>[root@www ~]# ls -al .bashrc<br><br><strong>-rw-r–r–</strong> 1 root root 395 Jul 4 11:45 .bashrc<br><br>[root@www ~]# chmod 777 .bashrc<br><br>[root@www ~]# ls -al .bashrc<br><br><strong>-rwxrwxrwx</strong> 1 root root 395 Jul 4 11:45 .bashrc<br><br><em>符号类型改变文件权限</em> :<br><br>user（u）：具有可读、可写、可执行的权限；<br><br>group与others（g/o）：具有可读与执行的权限。<br><br>所以就是：<br><br>[root@www ~]# chmod u=rwx,go=rx .bashrc<br><br><strong>注意：那个 u=rwx,go=rx 是连在一起的，中间并没有任何空格</strong>。<br><br>[root@www ~]# ls -al .bashrc<br><br>-rwxr-xr-x 1 root root 395 Jul 4 11:45 .bashrc<br><br><strong>那么假如是“-rwxr-xr”这样的权限呢？可以使用“ chmod u=rwx,g=rx,o=r filename”来设置</strong>。<br>如果我不知道原先的文件属性，而我只想要增加.bashrc这个文件的<strong>每个人均可写入的权限</strong>，那么我就可以使用：<br><br>[root@www ~]# ls -al .bashrc<br>[root@www ~]# chmod <strong>a+w</strong> .bashrc<br><br>[root@www ~]# ls -al .bashrc<br><br>-rwxrwxrwx 1 root root 395 Jul 4 11:45 .bashrc<br><br>而如果是要将权限去掉而不更改其他属性呢？例如要去掉全部人的可执行权限，则：<br><br>[root@www ~]# chmod a-x .bashrc<br><br>[root@www ~]# ls -al .bashrc<br><br>-rw-rw-rw- 1 root root 395 Jul 4 11:45 .bashrc</p></blockquote><ul><li>权限对 文件 的重要性</li></ul><blockquote><p>　<strong>文件是实际含有数据的地方</strong>，包括一般文本文件、数据库内容文件、二进制可执行文件（binary program）等。因此权限对于文件来说，它的意义如下。<br><br>　　　r（read）：可读取此文件的实际内容，如读取文本文件的文字内容等。<br><br>　　　w（write）：可以编辑、新增或者是修改该文件的内容（<strong>但不含删除该文件</strong>）。<br><br>　　　x（eXecute）：该文件具有可以被系统执行的权限。<br><br>　可执行（x）权限，这里必须要小心啦！<strong>因为在 Windows 下面一个文件是否具有执行的能力是通过“扩展名”来判断的，例如.exe，.bat，.com等，但是在Linux下面，我们的文件是否能被执行则是由是否具有“x”这个权限来决定，而跟文件名是没有绝对的关系</strong>。<br><br>　至于最后一个w权限呢？当你对一个文件具有w权限时，你可以具有写入、编辑、新增修改文件的内容的权限，<strong>但并不具备删除该文件本身的权限</strong>。<strong>对于文件的 r、w、x 来说，主要都是针对“文件的内容”而言，与文件名的存在与否没有关系的。因为文件记录的是实际的数据</strong>。</p></blockquote><ul><li>权限对目录的重要性</li></ul><blockquote><p>　文件是存放实际数据的所在，目录主要的内容是记录文件名列表，文件名与目录有强烈的关联。所以如果是针对目录时，那个r、w、x对目录是什么意义呢？<br><br>　　r（read contents in directory）<br>表示具有<strong>读取目录结构列表的权限</strong>，所以当你具有读取（r）一个目录的权限时，表示你可以查询该目录下的文件名数据，<strong>所以你就可以利用ls这个命令将该目录的内容列表显示出来</strong>。<br><br>　　w（modify contents of directory）<br>这个可写入的权限对目录来说是很强大的。因为它表示你具有更改该目录结构列表的权限，也就是下面这些权限：<br><br>　　　　新建新的文件与目录；<br><br>　　　　删除已经存在的文件与目录（<strong>不论该文件的权限为何</strong>）将已存在的文件或<br>目录进行重命名；<br><br>　　　　转移该目录内的文件、目录位置。<br>总之，目录的w权限就与该目录下面的文件名变动有关就对了。<br><br>　　x（access directory）<br>目录的执行权限有啥用途啊？目录只是记录文件名而已，总不能拿来执行吧？没错，目录不可以被执行，<strong>目录的 x 代表的是用户能否进入该目录成为工作目录的用途</strong>，所谓的工作目录（work directory）就是你目前所在的目录。举例来说，当你登录 Linux时，你所在的主文件夹就是你当下的工作目录。而变换目录的命令是<strong>“cd”</strong> (change directory）</p></blockquote><h2 id="2">2. Linux目录配置</h2><blockquote><p>　Linux 发行版本和开发团队或公司实在太多了。如何保证你所接触到的 Linux 目录配置方法和之前学习的 Linux 系统的目录配置一样，这就出现了后来的 Filesystem Hierarchy Standard (FHS)标准的出炉。<br><br>　根据 <a href="http://www.pathname.com/fhs/" target="_blank" rel="noopener">FHS: http://www.pathname.com/fhs/</a>　的官方文件指出，其主要目的是希望让用户可以了解到已安装软件通常放置于那个目录下，所以其希望独立的软件开发商、操作系统制作者以及想要维护系统的用户，都能够遵循FHS的标准。也就是说，FHS的重点在于规范每个特定的目录下应该要放置什么样子的数据而已。这样做好处非常多，因为Linux操作系统就能够在既有的面貌下（目录架构不变）发展出开发者想要的独特风格<br><br>　事实上，FHS是根据过去的经验一直在持续改版的，FHS依据文件系统使用的频繁与否与是否允许用户随意改动，而将目录定义成为四种交互作用的形态</p></blockquote><p><img src="http://p0bl99g4r.bkt.clouddn.com/dir_type.jpg" alt=""></p><blockquote><p>可分享的：可以分享给其他系统挂载使用的目录，所以包括执行文件与用户的邮件等数据，是能够分享给网络上其他主机挂载用的目录。<br><br>不可分享的：自己机器上面运行的设备文件或者是与程序有关的socket文件等，由于仅与自身机器有关，所以当然就不适合分享给其他主机了。<br><br>不变的：有些数据是不会经常变动的，跟随着distribution而不变动。例如函数库、文件说明文件、系统管理员所管理的主机服务配置文件等。<br><br>可变动的：经常改变的数据，例如登录文件、新闻组等。</p></blockquote><h3 id="2.1">2.1 Linux目录配置</h3><ul><li>FHS 目录树架构</li></ul><blockquote><p>FHS 针对目录树架构金鼎移除三层目录下面应该放置什么数据，分别是<br><br>/（root,根目录）：与开机系统有关；<br><br>/usr（UNIX software resource）：与软件安装/执行有关；<br><br>/var（variable）：与系统运作过程有关。</p></blockquote><ul><li>根目录( / ) 的意义与内容</li></ul><blockquote><p>　根目录是整个系统最重要的一个目录，<strong>因为不但所有的目录都是由根目录衍生出来的，同时根目录也与开机、还原、系统修复等操作有关</strong>。由于系统开机时需要特定的开机软件、内核文件、开机所需程序、函数库等文件数据，若系统出现错误时，<strong>根目录也必须要包含有能够修复文件系统的程序才行</strong>。因为根目录是这么重要，所以在FHS的要求方面，其希望根目录不要放在非常大的分区内，因为越大的分区录所在分区就可能会有较多发生错误的机会。<br><br>　因此FHS标准建议：<strong>根目录（/）所在分区应该越小越好</strong>，<strong>且应用程序所安装的软件最好不要与根目录放在同一个分区内，保持根目录越小越好</strong>。如此不但性能较好，根目录所在的文件系统也较不容易发生问题</p></blockquote><p><em>有鉴于上述的说明，因此 FHS 定义出根目录（/）下面应该要有下面这些子目录的存在才好</em><br></p><p><img src="http://p0bl99g4r.bkt.clouddn.com/dir_01.jpg" alt=""></p><p><img src="http://p0bl99g4r.bkt.clouddn.com/dir_02.jpg" alt=""></p><p><em>FHS 针对根目录所定义的标准金上面图片中举例数据，不过 Linux 下面还有许多目录也需要了解，下面是几个在 Linux 当中也是非常重要的目录</em></p><p><img src="http://p0bl99g4r.bkt.clouddn.com/dir_03.jpg" alt=""></p><ul><li>不可与根目录分开的目录</li></ul><blockquote><p>　因为根目录与开机有关，开机过程中仅有根目录会被挂载，其他分区则是在开机完成之后才会持续进行挂载的行为。就是因为如此，因此根目录下与<strong>开机过程有关的目录就不能够与根目录放到不同的分区去</strong>。有下面<br>　/bin：重要执行文件<br><br>　/etc:　配置文件<br><br>　/dev：所需要的设备文件<br><br>　/lib：执行文件所需的函数库与内核所需的模块<br><br>　/sbin：重要的系统执行文件<br><br><strong>这五个目录千万不可与根目录分开放在不同的分区</strong>。</p></blockquote><ul><li>/usr 的意义与内容</li></ul><blockquote><p>　依据FHS的基本定义，/usr里面放置的数据属于可分享的与不可变动的（shareable，static），如果你知道如何通过网络进行分区的挂载（例如在服务器篇会谈到的NFS服务器），那么/usr确实可以分享给局域网内的其他主机来使用。<br> <br>　其实 usr 是 UNIX Software Resource 的缩写，也就是<strong>“UNIX 操作系统软件资源”所放置的目录</strong>，而不是用户的数据。这点要注意。FHS<strong>建议所有软件开发者应该将他们的数据合理地分别放置到这个目录下的子目录，而不要自行新建该软件自己独里的目录</strong>。<br>　因为是所有系统默认的软件（distribution 发布者提供的软件）都会放置到/usr 下面，因此这个目录有点类似 Windows 系统的“C:\Windows\”和“C:\Program files\”这两个目录的综合体，系统刚安装完毕时，这个目录会占用最多的硬盘容量。一般来说，/usr的子目录建议有下图所示的这些</p></blockquote><p><img src="http://p0bl99g4r.bkt.clouddn.com/usr_dir.jpg" alt=""><br></p><ul><li>/var 的意义与内容</li></ul><blockquote><p>如果/usr是安装时会占用较大硬盘容量的目录，那么<strong>/var就是在系统运行后才会渐渐占用硬盘容量的目录</strong>。 <strong>因为/var目录主要针对常态性变动的文件，包括缓存（cache）、登录文件（log file）以及某些软件运行所产生的文件，包括程序文件（lock file，run file）</strong>，或者例如 MySQL数据库的文件等。</p></blockquote><p> <img src="https://github.com/DomBro96/MyNotes/blob/master/img/LinuxNoteImg/var_dir.jpg" alt=""><br></p><ul><li>目录树</li></ul><blockquote><p>　<strong>所有的文件与目录都是由根目录开始的</strong>。那是所有目录与文件的源头。然后再一个一个分支下来，<strong>有点像是树枝状。因此我们也称这种目录配置方式为“目录树（directorytree）”</strong>。<br>这个目录树有什么特性呢？它主要的特性有：<br><br>　　·目录树的起始点为根目录（/，root）；<br><br>　　·每一个目录不只能使用本地端的文件系统，也可以使用网络上的文件系统。举例来说，可以利用Network File System（NFS）服务器挂载某特定目录等。<br><br>　　·每一个文件在此目录树中的文件名（包含完整路径）都是独一无二的。</p></blockquote><p>　<img src="http://p0bl99g4r.bkt.clouddn.com/filetree.jpg" alt=""></p><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><p>整理笔记参考了 <a href="http://linux.vbird.org/linux_basic/0210filepermission.php#filepermission_perm" target="_blank" rel="noopener">《鸟哥的Linux私房菜》</a> 一书。这本书我是买的<a href="http://sale.jd.com/act/W5hugLDc1R.html" target="_blank" rel="noopener">京东阅读</a>的正版电子书籍。<br><br>如果不想买书看的话可以直接戳<a href="http://linux.vbird.org/" target="_blank" rel="noopener">这里进入鸟哥Linux私房菜的线上博客 : http://linux.vbird.org/</a>。请大家支持正版！！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; class=&quot;headerlink&quot; title=&quot;目录&quot;&gt;&lt;/a&gt;目录&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#1&quot;&gt;1. Linux文件权限&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#1.1&quot;&gt;1.1 用户与用户组&lt;
      
    
    </summary>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
</feed>
