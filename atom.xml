<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Welcome</title>
  
  <subtitle>Dom&#39;know</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2017-12-13T10:28:30.225Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>dombro</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>高级bash</title>
    <link href="http://yoursite.com/2017/12/12/%E9%AB%98%E7%BA%A7bash/"/>
    <id>http://yoursite.com/2017/12/12/高级bash/</id>
    <published>2017-12-12T01:12:24.000Z</published>
    <updated>2017-12-13T10:28:30.225Z</updated>
    
    <content type="html"><![CDATA[<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li><a href="#1">1. 数据流重定向</a><ul><li><a href="#1.1">1.1 what</a><ul><li><a href="#1.1.1">1.1.1 标准输出与错误输出</a></li><li><a href="#1.1.2">1.1.2 数据流重定向功能</a></li><li><a href="#1.1.3">1.1.3 标准输入</a></li></ul></li><li><a href="#1.2">1.2 why</a> </li></ul></li><li><a href="#2">2. 命令执行的判断依据 ;、&amp;&amp;、||</a><ul><li><a href="#2.1">2.1 ;</a></li><li><a href="#2.2">2.2 &amp;&amp;、||</a></li></ul></li><li><a href="#3">3. 管道命令</a><ul><li><a href="#3.1">3.1 what</a></li><li><a href="#3.2">3.2 一些管道命令</a><ul><li><a href="#3.2.1">3.2.1 选取命令：cut、grep</a></li><li><a href="#3.2.2">3.2.2 排序命令: sort、wc、uniq</a></li><li><a href="#3.2.3">3.2.3 双向重定向：tee</a></li><li><a href="#3.2.5">3.2.4 字符转换命令: tr、col、join、paste、expand</a></li></ul></li></ul></li></ul><h2 id="1">1. 数据流重定向</h2><p>重定向，英文 redirct。这个词程序员经常能遇到，大概意思就是给一个东西重新定位。而数据流重定向，大概就是将数据传导到其他地方去。</p><h3 id="1.1">1.1 what</h3><p>想知道啥叫数据流重定向，就要先了解一下命令执行结果。默认情况下，我们执行一个命令无论正确与否，命令执行结果(如果有的话)信息都会被打印到屏幕上。</p><h4>1.1.1 标准输出 &amp; 标准错误输出</h4><p>上面说到，默认情况下一个命令的执行结果都会被输出到屏幕上。<strong>输出的结果无非就是两种情况：命令回传的正确信息和命令回传的错误信息。这两种情况就分别对应 标准输出(standard output,简称stdout) 和 标准错误输出(standard error output,简称stderr)</strong>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dombro@ubuntu:~$ cat catfile &lt;== 使用 cat 将文件内容显示</span><br><span class="line">hello                        &lt;== 文件内容被打印出来，stdout</span><br><span class="line">just test for stin</span><br><span class="line">dombro@ubuntu:~$ cat cat11</span><br><span class="line">cat: cat11: No such file or directory  &lt;== 没有这个文件 stderr</span><br></pre></td></tr></table></figure><p>也就是说当你命令执行成功时输出的信息就是 stdout ，反之命令执行失败输出的信息就是 stderr 。<strong>不管正确与错误的数据都输出到屏幕上时很混乱的，如何将这两者分开就是数据流重定向的功能</strong>。</p><h4 id="1.1.2">1.1.2 数据流重定向功能</h4><p>数据流重定向可以将 stdout 和 stderr 分别传送到其他文件和设备中而不只是将其输出到屏幕上。而传送所需要的特殊字符如下</p><blockquote><p>1.标准输入(stdin) : 代码为 0，使用 &lt; 或 &lt;&lt; <br><br>2.标准输出(stdout) : 代码为 1，使用 &gt; 或 &gt;&gt; <br><br>3.标准错误输出(stderr) : 代码为 2，使用 2&gt; 或 2&gt;&gt;</p></blockquote><p>光说不练假把式，通过几个范例练习一下</p><ul><li>范例一：将系统根目录下(/) 各个文件信息记录到 ~/rootfile 中</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">dombro@ubuntu:~$ ll / &gt; ./rootfile &lt;== 神奇的是这是屏幕什么都不会输出</span><br><span class="line">dombro@ubuntu:~$ cat ./rootfile   &lt;== 使用 cat 查看一下，果然信息都写入了rootfile 中</span><br><span class="line">total 112</span><br><span class="line">drwxr-xr-x  25 root root  4096 Nov  5 09:47 ./</span><br><span class="line">drwxr-xr-x  25 root root  4096 Nov  5 09:47 ../</span><br><span class="line">...下面省略</span><br></pre></td></tr></table></figure><p>范例一中 ~/rootfile 的创建方式是：</p><blockquote><p>1.该文件若不存在系统自动将它创建<br><br>2.若文件已经存在，系统会先将这个文件清空，在将数据写入<br><br>3.综合上两点，若以 &gt; 输出到一个已存在的文件中，那这个文件就会被覆盖掉</p></blockquote><p><strong>如果想以累加的方式重定向，不删除旧数据，咋办？将 &gt; 改成 &gt;&gt; 就好了</strong>。上面说的标准输出代码为1,所以在 &gt; 和 &gt;&gt; 前面加上 数字1 ，1&gt;&gt;、1&gt;起到的效果是一样的。</p><p><strong>标准错误输出(stderr)的重定向和 stdout 使用方法是一样的，只不过标准错误输出的重定向字符为 2&gt; 和 2&gt;&gt;</strong>。</p><ul><li>范例二：利用一般用户账号使用 find 命令查找/home 下面是否有 .bashrc的文件存在</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">dombro@ubuntu:~$ find /home -name .bashrc</span><br><span class="line">/home/dongbo/.bashrc &lt;== stdout </span><br><span class="line">find: ‘/home/dongbo/.cache’: Permission denied &lt;== stderr 这里是错误输出，很明显 dombro 这个用户没有 /home/dongbo 这个目录的读取权限</span><br><span class="line">/home/user2/.bashrc  &lt;== stdout </span><br><span class="line">/home/user1/.bashrc  &lt;== stdout </span><br><span class="line">/home/dombro/.bashrc &lt;== stdout</span><br></pre></td></tr></table></figure><p>这个时候你可以使用 stdout 重定向 <code>find /home -name .bashrc &gt; list</code> 正确的输出数据会被写入到 list 这个文件里，但错误的提示还是会在屏幕上。</p><ul><li>范例三：承接范例二，将 stdout 和 stderr 分别存到不同的文件中</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dombro@ubuntu:~$ find /home -name .bashrc &gt; list_right 2&gt; list_error &lt;== 屏幕不会显示任何信息， </span><br><span class="line">dombro@ubuntu:~$ ls -al list_right list_error </span><br><span class="line">-rw-rw-r-- 1 dombro dombro 51 Dec 12 10:42 list_error &lt;== stderr 的错误信息写入该文件</span><br><span class="line">-rw-rw-r-- 1 dombro dombro 82 Dec 12 10:42 list_right &lt;== stdout 的正确信息写入该文件</span><br></pre></td></tr></table></figure><ul><li>范例四：承接范例三，将错误数据丢弃，屏幕显示正确数据</li></ul><p>如果我不想使用文件保存 stderr 返回的错误信息，也不想让其在屏幕上显示 我们可以<strong>借助 /dev/null 这个设备 ，你可以把它想象成一个垃圾桶或者黑洞，他可以吃掉任何导向这个设备的信息</strong>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dombro@ubuntu:~$ find /home -name .bashrc 2&gt; /dev/null </span><br><span class="line">/home/dongbo/.bashrc &lt;== 仅会显示 stdout </span><br><span class="line">/home/user2/.bashrc</span><br><span class="line">/home/user1/.bashrc</span><br><span class="line">/home/dombro/.bashrc</span><br></pre></td></tr></table></figure><p>使用这种写法是因为你提前知道会出现哪些 stderr 的错误输出。</p><ul><li>范例五：将命令的返回数据全部写入名为list_show的文件中</li></ul><p>我猜你肯定会这么写</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">dombro@ubuntu:~$ find /home -name .bashrc &gt; list_show 2&gt; list_show</span><br><span class="line">dombro@ubuntu:~$ cat list_show </span><br><span class="line">find: ‘/home/dongbo/home/user2/.bashrc</span><br><span class="line">/home/user1/.bashrc   &lt;== 有没有注意到正确和错误的顺序怪怪的</span><br><span class="line">/home/dombro/.bashrc</span><br><span class="line">...已经显示全部了...</span><br></pre></td></tr></table></figure><p><strong>这是一种错误的写法!</strong>虽然 list_show 这个文件会创建以及被写入，但是 stdout 和 stderr 可能会交替写入，数据可能会丢失。</p><p>正确的两种写法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dombro@ubuntu:~$ find /home -name .bashrc &gt; list_show 2&gt;&amp;1 &lt;== 推荐写法，因为予以更加清晰</span><br><span class="line">dombro@ubuntu:~$ find /home -name .bashrc  &amp;&gt; list_show</span><br></pre></td></tr></table></figure><h4 id="1.1.3">1.1.3 标准输入</h4><p>说了标准输出与标准错误输出应该看一下 标准输入stdin 了。stdin 重定向字符为 &lt; 或 &lt;&lt; ，这两个字符可以将原本需要由键盘输入的数据改由文件内容来代替。</p><ul><li>范例六：利用 cat　命令创建一个文件的简单流程</li></ul><p>what ? cat 创建文件？当然可以</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">dombro@ubuntu:~$ cat &gt; catfile</span><br><span class="line">testing </span><br><span class="line">cat file test</span><br><span class="line">&lt;== 这里按下 [ctrl] + d离开</span><br><span class="line"></span><br><span class="line">dombro@ubuntu:~$ cat catfile</span><br><span class="line">testing </span><br><span class="line">cat file test</span><br></pre></td></tr></table></figure><p>加入 &gt; 在 cat后，所以那个catfile会被主动创建，内容就是键盘上的输入。</p><ul><li>范例七：承接范例六，用 stdin 替代键盘输入已创建新文件简单流程</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dombro@ubuntu:~$ cat &gt; catfile2 &lt; catfile</span><br><span class="line">dombro@ubuntu:~$ ls -al catfile catfile2</span><br><span class="line">-rw-rw-r-- 1 dombro dombro 23 Dec 12 11:13 catfile</span><br><span class="line">-rw-rw-r-- 1 dombro dombro 23 Dec 12 11:20 catfile2</span><br></pre></td></tr></table></figure><p>这两个文件大小一模一样，就像是使用 cp 复制一样。</p><ul><li>范例八: stdin 的 &lt;&lt; </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">dombro@ubuntu:~$ cat &gt; catfile &lt;&lt; &quot;end&quot;</span><br><span class="line">&gt; This is a test</span><br><span class="line">&gt; now stop</span><br><span class="line">&gt; end &lt;== 输入这个关键字，立刻结束不需要输入 [ctrl]+d</span><br><span class="line">dombro@ubuntu:~$ cat catfile</span><br><span class="line">This is a test</span><br><span class="line">now stop</span><br></pre></td></tr></table></figure><p>可以看到 &lt;&lt; 表示结束输入的意思，利用 &lt;&lt; 右侧的控制字符，我们可以终止一次输入，而不必使用 [ctrl]+d 来结束。</p><h3>1.2 why</h3><p>为什么要使用命令重定向呢？来说一说重定向的使用场景</p><blockquote><p>1.屏幕输出的信息很重要，而且我们需要将它存下来<br><br>2.后台执行中的程序，不希望他干扰屏幕上的正常输出结果是<br><br>3.一些系统的执行命令的执行结果，希望它可以存下来<br><br>4.一些执行命令的可能已知错误信息时，可以用 “2&gt;/dev/null”将它丢掉<br><br>5.错误信息与正确信息需要分别输出时</p></blockquote><h2 id="2">2. 命令执行的判断依据 ;、&amp;&amp;、||</h2><p>科技生产力的进步离不开一个字——“懒”。如果我希望一次性执行输入的很多命令。咋办？一种是通过 shell　script 脚本，另一种就是题目中的三种符号 ; &amp;&amp; ||。</p><h3 id="2.1">2.1 ;</h3><p>有时候我们希望可以一次执行多个命令，可以写成这样</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmd;cmd</span><br></pre></td></tr></table></figure><p>上述方法在执行第一个命令后会立即执行第二个命令。常用的是关机操作，通过连续的sync将内存缓存写入磁盘后，在关机。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dombro@ubuntu:~$ sync;sync;shutdown -h now</span><br></pre></td></tr></table></figure><p>但是 ; 两端的命令并不能体现命令的相关性(联系)，即前一个命令的执行结果与后一个命令没啥关系，后一个命令都会执行。如果想达到通过前一个命令执行结果决定后一个命令是否执行，可以通过 &amp;&amp; 或 || 。</p><h3 id="2.2">2.2 &amp;&amp;、||</h3><p>看一下下面的表格</p><table><thead><tr><th>命令执行情况</th><th>说明      </th></tr></thead><tbody><tr><td> cmd1 &amp;&amp; cmd2</td><td>若 cmd1 执行完毕且正确执行($?=0),则开始执行cmd2;若 cmd1 执行完毕且错误执行($?!=0),则cmd2不执行</td></tr><tr><td> cmd1丨丨 cmd2</td><td>若 cmd1 执行完毕且正确执行($?=0)，则cmd2不执行; cmd1 执行完毕且错误执行($?!=0),则开始执行cmd2</td></tr></tbody></table><p>这两个字符挺考验逻辑的，但也挺好理解。</p><ul><li>范例九：用 ls 测试/tmp/testing 是否存在，若存在则显示 “exit”，若不存在则显示 “not exit”</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dombro@ubuntu:~$ ls -al /tmp/testingn 2&gt;/dev/null  &amp;&amp; echo &quot;exit&quot; || echo &quot;not exit&quot;</span><br><span class="line">not exit</span><br></pre></td></tr></table></figure><p>我们知道命令的执行顺序是从左到右，范例九当第一个命令执行执行失败，则导致第二个命令执行失败，第三个命令就会执行成功。这是一个很重要的点，例如下面给出错误示范</p><p>错误示范</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dombro@ubuntu:~$ ls -al /tmp/testingn 2&gt;/dev/null  || echo &quot;not exit&quot; &amp;&amp; echo &quot; exit&quot;  &lt;== 将两个信息都打印出来了</span><br><span class="line">not exit</span><br><span class="line">exit</span><br></pre></td></tr></table></figure><p>当文件不存在时，第二个命令会执行，而第三个命令则根据第二个命令执行成功也会执行。</p><h2 id="3">3. 管道命令</h2><p>你用过 <code>ps -aux|grep xxx</code> 这个命令去查找进程吗？用过的话，恭喜你你已经接触过管道命令了。 </p><h3 id="3.1">3.1 what</h3><p>那么啥是管道命令呢？<strong>简单来说就是前一个命令的输出(stdout)，作为后一个命令的输入(stdin)，命令之间用 | 隔开</strong>。</p><ul><li>举个例子</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dombro@ubuntu:~$ ls -al /etc | less</span><br></pre></td></tr></table></figure><p>如上，由于 /etc 路径下文件太多了，如果直接 ls 屏幕就会被塞满了不知道前面输出了什么，于是利用 less 命令来协助，这样 ls 命令输出的内容就能被less读取,并且利用less功能，可以前后翻动相关信息。很方便~</p><ul><li>了解一下 | </li></ul><p><strong>这个孤零零的命令 <code>|</code> 仅能处理经过前一个命令传来的正确信息,也就是 standard output 的信息，对于standard error并没有直接处理能力</strong></p><p><img src="http://p0bl99g4r.bkt.clouddn.com/Lin_pipe.jpg" alt=""></p><p><strong>在每个管道后接的第一个数据一定要是一个命令！而且这个命令一定要能够接受 standard input 数据才行，这样的命令才是管道命令</strong>。如 less、more、head、tail 等都是可以接受 stdin 的管道命令，而 ls、cp、mv等就不是管道命令了，因为他们并不会接收来自stdin的数据。</p><h3 id="3.2">3.2 一些管道命令</h3><h4 id="3.2.1">选取命令： cut,grep</h4> <p>选取命令就是将一段数据经过分析后，取出我们所需要的，或者经由分析关键字，取得我们所想要的那一行。不过，一般来说，选取的信息通常是针对 “行” 来分析，并不是整片信息分析。</p><ul><li>cut </li></ul><p>cut 切 的意思，没有错，这个命令可以将一段信息的某一段切出来，处理信息是以行为单位的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">语法：</span><br><span class="line">cut(选项)(参数)</span><br><span class="line"></span><br><span class="line">选项:</span><br><span class="line"></span><br><span class="line">-c：仅显示行中指定范围的字符 &lt;== 用于排列整齐的信息</span><br><span class="line">-d：指定字段的分隔符，与 -f 一起使用 &lt;== 用于分割字符</span><br><span class="line">-f：一句 -d 的分割字符将一段信息切割成位数段，用 -f 取出第几段的意思</span><br></pre></td></tr></table></figure><p>范例一：将 PATH 变量取出，找出第五个路径</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dombro@ubuntu:~$ echo $PATH</span><br><span class="line">/usr/java/jdk1.8.0_144/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin</span><br><span class="line"></span><br><span class="line">dombro@ubuntu:~$ echo $PATH |cut -d&apos;:&apos; -f 5</span><br><span class="line">/usr/bin</span><br></pre></td></tr></table></figure><p>如果想列出第3到第5段 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dombro@ubuntu:~$ echo $PATH |cut -d&apos;:&apos; -f 3,5</span><br><span class="line">/usr/local/bin:/usr/bin</span><br></pre></td></tr></table></figure><p>范例二：将 exoprt 输出的信息取得第12字符以后的所有字符串</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">dombro@ubuntu:~$ export</span><br><span class="line">declare -x CLASSPATH=&quot;.:/usr/java/jdk1.8.0_144/lib:/usr/java/jdk1.8.0_144/jre/lib&quot;</span><br><span class="line">declare -x CLUTTER_IM_MODULE=&quot;xim&quot;</span><br><span class="line">declare -x COMPIZ_CONFIG_PROFILE=&quot;ubuntu&quot;</span><br><span class="line">...省略...</span><br><span class="line"></span><br><span class="line">dombro@ubuntu:~$ export | cut -c 12-</span><br><span class="line">CLASSPATH=&quot;.:/usr/java/jdk1.8.0_144/lib:/usr/java/jdk1.8.0_144/jre/lib&quot;</span><br><span class="line">CLUTTER_IM_MODULE=&quot;xim&quot;</span><br><span class="line">COMPIZ_CONFIG_PROFILE=&quot;ubuntu&quot;</span><br></pre></td></tr></table></figure><p>如果想得到 第12-20 的字符，使用 cut -c 12-20 即可。</p><ul><li>grep </li></ul><p>这个命令其实很常见的，grep　实际上就是分析一行信息，若当中有我们需要的信息，就将该行拿出来。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">grep [-acinv] [--color=auto] &apos;搜尋字串&apos; filename</span><br><span class="line">選項與參數：</span><br><span class="line">-a ：將 binary 檔案以 text 檔案的方式搜尋資料</span><br><span class="line">-c ：計算找到 &apos;搜尋字串&apos; 的次數</span><br><span class="line">-i ：忽略大小寫的不同，所以大小寫視為相同</span><br><span class="line">-n ：順便輸出行號</span><br><span class="line">-v ：反向選擇，亦即顯示出沒有 &apos;搜尋字串&apos; 內容的那一行！</span><br><span class="line">--color=auto ：可以將找到的關鍵字部分加上顏色的顯示喔！</span><br></pre></td></tr></table></figure><p>范例三：将 last 中，有出现 root 的那一行取出来</p><p>last 命令可以显示系统用户登录的姓名信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">dombro@ubuntu:~$ last | grep &apos;root&apos;</span><br></pre></td></tr></table></figure><p>范例四：将 last 中，没有出现 root 的行取出来</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dombro@ubuntu:~$ last | grep -v &apos;root&apos;</span><br></pre></td></tr></table></figure><p>3.2.2 排序命令: sort、wc、uniq</p><ul><li>sort </li></ul><p>sort　是一个很有趣的命令，顾名思义，它可以帮助我们排序，还可以根据不同资料形态来排序！</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">sort [-fbMnrtuk] [file or stdin]</span><br><span class="line"></span><br><span class="line">选项：</span><br><span class="line">-f  ：忽略大小写的差异，例如 A 與 a 視为編碼相同；</span><br><span class="line">-b  ：忽略最前面的空白字元部分；</span><br><span class="line">-M  ：以月份的名字來排序，例如 JAN, DEC 等等的排序方法；</span><br><span class="line">-n  ：使用『純數字』進行排序(預設是以文字型態來排序的)；</span><br><span class="line">-r  ：反向排序；</span><br><span class="line">-u  ：就是 uniq ，相同的資料中，僅出現一行代表；</span><br><span class="line">-t  ：分隔符號，預設是用 [tab] 鍵來分隔；</span><br><span class="line">-k  ：以那個區間 (field) 來進行排序的意思</span><br></pre></td></tr></table></figure><p>范例一：对记录个人账号的 /etc/password 中的账号排序</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dombro@ubuntu:~$ cat /etc/passwd | sort </span><br><span class="line">_apt:x:105:65534::/nonexistent:/bin/false</span><br><span class="line">avahi-autoipd:x:110:119:Avahi autoip daemon,,,:/var/lib/avahi-autoipd:/bin/false</span><br><span class="line">backup:x:34:34:backup:/var/backups:/usr/sbin/nologin</span><br><span class="line">bin:x:2:2:bin:/bin:/usr/sbin/nologin</span><br></pre></td></tr></table></figure><p>可以看到，不加选项参数时，是以第一个字符来排序的</p><p>范例二：承接范例一，以第三个含后面字符来排序</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">dombro@ubuntu:~$ cat /etc/passwd | sort -t&apos;:&apos; -k 3</span><br><span class="line">root:x:0:0:root:/root:/bin/bash</span><br><span class="line">dombro:x:1000:1000:ubuntu,,,:/home/dombro:/bin/bash</span><br><span class="line">systemd-timesync:x:100:102:systemd Time Synchronization,,,:/run/systemd:/bin/false</span><br><span class="line">dongbo:x:1001:1002:,,,:/home/dongbo:/bin/bash</span><br><span class="line">user1:x:1002:1003::/home/user1:</span><br><span class="line">user2:x:1003:1004::/home/user2:</span><br></pre></td></tr></table></figure><p>注意第三个 <code>:</code> 后面是数字开始，所以当然会从 0 开始排序。如果单纯想要第三个栏位来处理则是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /etc/passwd | sort -t&apos;:&apos; -k 3,3</span><br></pre></td></tr></table></figure><p>如果想以数字顺序排序则是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /etc/passwd | sort -t&apos;:&apos; -k 3 -n &lt;== 加上 -n 选项即可</span><br></pre></td></tr></table></figure><ul><li>uniq </li></ul><p>如果使用 sort 排序完成，想要重复的资料仅列出一个就使用 uniq 这个命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">uniq [-ic]</span><br><span class="line">選項與參數：</span><br><span class="line">-i  ：忽略大小寫字元的不同；</span><br><span class="line">-c  ：進行計數</span><br></pre></td></tr></table></figure><p>范例一：使用 last　将账号列出，进去出账号栏，进行排序后仅取出一位</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">last | cut -d &apos; &apos; -f1 | sort | uniq</span><br></pre></td></tr></table></figure><p>范例二：承接范例一，列出每个用户登录的次数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">last | cut -d &apos; &apos; -f1 | sort | uniq -c &lt;== 使用 -c 选项列出行数即可</span><br></pre></td></tr></table></figure><ul><li>wc </li></ul><p>wc 命令可以帮助我们知道一个文件中有多少字，多少行，多少字符。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">wc [-lwm]</span><br><span class="line">選項與參數：</span><br><span class="line">-l  ：仅列出行；</span><br><span class="line">-w  ：仅列出多少字(英文單字)；</span><br><span class="line">-m  ：多少字符；</span><br></pre></td></tr></table></figure><p>范例一：列出 /etc/passwd 有多少字符</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dombro@ubuntu:~$ cat /etc/passwd | wc</span><br><span class="line">     43   &lt;== 行   72 &lt;== 字数   2353 &lt;== 字符数</span><br></pre></td></tr></table></figure><p>范例二：如何以一行命令串取得这个月份登录系统的总人次</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dombro@ubuntu:~$ last | grep [a-zA-Z] | grep -v &apos;wtmp&apos;|wc -l</span><br></pre></td></tr></table></figure><p>首先你要知道 last 会输出空白行与wtmp字样在最后两行，这些不包含用户登录信息。于是：grep [a-zA-Z] 取出非空行，grep -v ‘wtmp’ 去掉 wtmp 那两行，在 wc -l 计算行数。</p><h4 id="3.2.3">3.2.3 双向重定向：tee</h4><p>双向重定向？天哪这又是啥？上面<a href="#1.1.1">重定向的部分</a> 说到 &gt; 会将数据流整个传送给文件或设备，因此除非我们去读取这个文件或设备，否则就无法继续利用这个数据流。<strong>往往有时需要在屏幕显示输出的数据，但还要保存数据流处理的过程，那该怎么办？就可以用到我们的双重重定向命令 tee</strong>。</p><ul><li>tee</li></ul><p>tee 会同时将数据流传送给屏幕和文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tee [-a] file</span><br><span class="line"></span><br><span class="line">选项：-a</span><br><span class="line">已累加的方式将数据加入file中</span><br></pre></td></tr></table></figure><ul><li>范例一 : 使用双重重定向例子</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">dombro@ubuntu:~$ ls -al | tee ls_file|grep newfile </span><br><span class="line">-rwxr-xr-x  1 dombro dombro    27 Aug 29 20:49 newfile</span><br><span class="line">dombro@ubuntu:~$ cat ls_file  &lt;== 查看一下</span><br><span class="line">total 184</span><br><span class="line">drwxr-xr-x 19 dombro dombro  4096 Dec 12 11:13 .</span><br><span class="line">drwxr-xr-x  6 root   root    4096 Nov 13 14:04 ..</span><br><span class="line">-rw-rwxr--  1 dombro dombro     0 Aug 27 10:38 at_example.txt</span><br><span class="line">-rw-------  1 dombro dombro 10455 Dec 12 14:03 .bash_history</span><br><span class="line">-rw-r--r--  1 dombro dombro   220 Aug 13 17:08 .bash_logout</span><br><span class="line">-rw-r--r--  1 dombro dombro  3771 Aug 13 17:08 .bashrc</span><br></pre></td></tr></table></figure><p>如果想已累加的方式将数据流存入文件 <code>tee -a file</code> 即可。<br><strong>tee 可以让 stdout 转存一份到文件内并将同样的数据继续送到屏幕去处理</strong>。这样除了可以让我们同时分析一份数据并记录下来之外，还可以作为处理一份数据的中间暂存盘记录。</p><h4 id="3.2.4">3.2.4 字符转换命令: tr、col、join、paste、expand</h4><p>下面介绍几个与字符转换相关的管道命令。</p><ul><li>tr </li></ul><p>tr 用来删除一段信息当中的文字，或者是进行文字信息的转换。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">tr [-ds] SET1</span><br><span class="line"></span><br><span class="line">选项：</span><br><span class="line"></span><br><span class="line">-d : 删除信息中 SET1 这个字符串</span><br><span class="line">-s : 替换重复的字符</span><br></pre></td></tr></table></figure><p>范例一：将 ls 出的文件信息，全部变成大写</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">dombro@ubuntu:~$ ls -al | tr [a-z] [A-Z]</span><br><span class="line">TOTAL 188</span><br><span class="line">DRWXR-XR-X 19 DOMBRO DOMBRO  4096 DEC 13 13:40 .</span><br><span class="line">DRWXR-XR-X  6 ROOT   ROOT    4096 NOV 13 14:04 ..</span><br><span class="line">-RW-RWXR--  1 DOMBRO DOMBRO     0 AUG 27 10:38 AT_EXAMPLE.TXT</span><br><span class="line">-RW-------  1 DOMBRO DOMBRO 10455 DEC 12 14:03 .BASH_HISTORY</span><br><span class="line">...下面省略...</span><br></pre></td></tr></table></figure><p>范例二：将 ls 出的文件信息中的空格去掉</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">dombro@ubuntu:~$ ls -al | tr -d &apos; &apos;</span><br><span class="line">total188</span><br><span class="line">drwxr-xr-x19dombrodombro4096Dec1313:40.</span><br><span class="line">drwxr-xr-x6rootroot4096Nov1314:04..</span><br><span class="line">-rw-rwxr--1dombrodombro0Aug2710:38at_example.txt</span><br><span class="line">-rw-------1dombrodombro10455Dec1214:03.bash_history</span><br><span class="line">...下面省略...</span><br></pre></td></tr></table></figure><p>范例三：将 /etc/passwd 转存成 dos 断行到 /root/passwd 中，再将 ^M 符号删除<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@www ～]# cp /etc/passwd /root/passwd &amp;&amp; UNIX2dos /root/passwd</span><br><span class="line">[root@www ～]# file /etc/passwd /root/passwd</span><br><span class="line">/etc/passwd: ASCII text</span><br><span class="line">/root/passwd: ASCII text, with CRLF line terminators &lt;==就是 DOS 断行</span><br><span class="line">[root@www ～]# cat /root/passwd | tr -d &apos;\r&apos; &gt; /root/passwd.linux</span><br><span class="line"># 那个 \r 指的是 DOS 的断行字符，关于更多的字符，请参考 man tr</span><br><span class="line">[root@www ～]# ll /etc/passwd /root/passwd*</span><br><span class="line">-rw-r--r-- 1 root root 1986 Feb 6 17:55 /etc/passwd</span><br><span class="line">-rw-r--r-- 1 root root 2030 Feb 7 15:55 /root/passwd</span><br><span class="line">-rw-r--r-- 1 root root 1986 Feb 7 15:57 /root/passwd.linux</span><br><span class="line"># 处理过后，发现文件大小与原本的 /etc/passwd 就一致了</span><br></pre></td></tr></table></figure></p><ul><li>col </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">col [-xb]</span><br><span class="line"></span><br><span class="line">参数：</span><br><span class="line">-x : 将 tab 键转换成对等的空格键</span><br><span class="line">-b : 在文字内有反斜杠(/) ，仅保留反斜杠最后接的那个字符</span><br></pre></td></tr></table></figure><p>范例一：利用 cat -A 显示出所有特殊按键，最后以 col 将 [tab] 转成空白</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@www ～]# cat -A /etc/man.config &lt;==此时会看到很多 ^I 的符号，那就是 tab</span><br><span class="line">[root@www ～]# cat /etc/man.config | col -x | cat -A | more</span><br><span class="line">#如此一来，[tab] 按键会被替换成为空格键，输出就美观多了。</span><br></pre></td></tr></table></figure><p>范例二：将 col 的 man page 转存成为 /root/col.man 的纯文本文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@www ～]# man col &gt; /root/col.man</span><br><span class="line">[root@www ～]# vi /root/col.man</span><br><span class="line">COL（1） BSD General Commands Manual COL（1）</span><br><span class="line">N^HNA^HAM^HME^HE</span><br><span class="line">c^Hco^Hol^Hl - filter reverse line feeds from input</span><br><span class="line">S^HSY^HYN^HNO^HOP^HPS^HSI^HIS^HS</span><br><span class="line">c^Hco^Hol^Hl [-^H-b^Hbf^Hfp^Hpx^Hx] [-^H-l^Hl _^Hn_^Hu_^Hm]</span><br><span class="line"># 你没看错。由于 man page 内有些特殊按钮会用来作为类似特殊按键与颜色显示，</span><br><span class="line"># 所以这个文件内就会出现如上所示的一堆怪异字符（有 ^ 的）</span><br><span class="line">[root@www ～]# man col | col -b &gt; /root/col.man</span><br></pre></td></tr></table></figure><ul><li>join </li></ul><p>join 看字面上的意义（加入/参加）就可以知道，它是在处理两个文件之间的数据，而且，主要是将两个文件当中有相同数据的那一行加在一起。我们利用下面的简单例子来说明：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@www ～]# join [-ti12] file1 file2</span><br><span class="line">参数：</span><br><span class="line">-t ：join 默认以空格符分隔数据，并且对比“第一个字段”的数据，</span><br><span class="line">如果两个文件相同，则将两条数据连成一行，且第一个字段放在第一个；</span><br><span class="line">-i ：忽略大小写的差异；</span><br><span class="line">-1 ：这个是数字的 1 ，代表第一个文件要用哪个字段来分析的意思；</span><br><span class="line">-2 ：代表第二个文件要用哪个字段来分析的意思。</span><br></pre></td></tr></table></figure><ul><li>paste </li></ul><p>这个paste就要比join简单多了。相对于join必须要对比两个文件的数据相关性，paste就直接将两行贴在一起，且中间以[tab]键隔开而已。简单的使用方法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@www ～]# paste [-d] file1 file2</span><br><span class="line">参数：</span><br><span class="line">-d ：后面可以接分隔字符，默认是以 [tab] 来分隔的。</span><br><span class="line">- ：如果 file 部分写成 - ，表示来自 standard input 的数据的意思。</span><br></pre></td></tr></table></figure><ul><li>expand</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">就是将[tab]按键转成空格键，可以这样做：</span><br><span class="line">[root@www ～]# expand [-t] file</span><br><span class="line">参数：</span><br><span class="line">-t ：后面可以接数字。一般来说，一个[tab]按键可以用 8 个空格键替换。</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; class=&quot;headerlink&quot; title=&quot;目录&quot;&gt;&lt;/a&gt;目录&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#1&quot;&gt;1. 数据流重定向&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#1.1&quot;&gt;1.1 what&lt;/a&gt;&lt;u
      
    
    </summary>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>浅谈token</title>
    <link href="http://yoursite.com/2017/12/11/%E6%B5%85%E8%B0%88token/"/>
    <id>http://yoursite.com/2017/12/11/浅谈token/</id>
    <published>2017-12-11T11:35:21.000Z</published>
    <updated>2017-12-11T11:35:51.444Z</updated>
    
    <content type="html"><![CDATA[<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li><a href="#1">1.不保存状态的 HTTP 协议</a><ul><li><a href="#1.1">1.1 cookie &amp; session</a></li></ul></li><li><a href="#2">2.Token</a><ul><li><a href="#2.1">2.1 Token哪里好</a></li><li><a href="#2.2">2.2 Token是个啥</a></li><li><a href="#2.3">2.3 JWT的Java实现</a></li></ul></li></ul><h2 id="1">1. 不保存状态的 HTTP 协议</h2><p>目前我们接触到的所有 Web 项目，基本上都是基于 HTTP 协议的，至于啥叫 HTTP协议？简单来说就是从客户端请求访问文本或图像这一类资源(<strong>使用 URI定位</strong>)，服务器端可以提供该资源的响应(<strong>不主动提供响应</strong>)。</p><ul><li>不保存状态的 HTTP 协议</li></ul><p><img src="https://i.imgur.com/iWmfdEO.jpg" alt=""></p><h3 id="1.1">1.1cookie &amp; session</h3> <p>使用 HTTP 协议，每当有新的请求发送时，就会有对应的新响应产生。  无状态导致的业务处理变得棘手情况增多。比如登录购物网站，即使他跳转到该站的其他页面后，也需要能继续保持登陆状态。 因此网站需要保存用户状态，为了实现期望保持状态功能，引入了 Cookie 技术。</p><ul><li>cookie 流程</li></ul><p>cookie 就是在客户端保持状态信息的方案。Cookie 是浏览器访问Web服务器的某个资源时，由Web服务器在Http响应头中附带传给浏览器的小文本文件。这些文本文件，可以保存在浏览器缓存或硬盘中。</p><p>1.浏览器向某个URL发起HTTP请求（可以是任何请求，比如GET一个页面、POST一个登录表单等）</p><p>2.对应的服务器收到该HTTP请求，并计算应当返回给浏览器的HTTP响应。（HTTP响应包括请求头和请求体两部分）</p><p>3.在响应头加入Set-Cookie字段，它的值是要设置的Cookie。</p><p>4.浏览器收到来自服务器的HTTP响应。</p><p>5.浏览器在响应头中发现Set-Cookie字段，就会将该字段的值保存在内存或者硬盘中。（Set-Cookie字段的值可以是很多项Cookie，每一项都可以指定过期时间Expires。 默认的过期时间是用户关闭浏览器时。）</p><p>6.浏览器下次给该服务器发送HTTP请求时， 会将服务器设置的Cookie附加在HTTP请求的头字段Cookie中。（浏览器可以存储多个域名下的Cookie，但只发送当前请求的域名曾经指定的Cookie， 这个域名也可以在Set-Cookie字段中指定）。）</p><p>7.服务器收到这个HTTP请求，发现请求头中有Cookie字段， 便知道之前就和这个用户打过交道了.</p><p>8.过期的Cookie会被浏览器删除。</p><p>（此处举个例子）</p><p><strong>思考题：在后端执行以下代码时，HTTP协议到底做了什么？</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Cookie cookie = new Cookie(&quot;username&quot;,&quot;王大锤&quot;);</span><br><span class="line">response.addCookie(cookie);</span><br></pre></td></tr></table></figure></p><ul><li>cookie 的安全隐患</li></ul><p>Cookie提供了一种手段使得HTTP请求可以附加当前状态， 现今的网站也是靠Cookie来标识用户的登录状态的：</p><p>1.用户提交用户名和密码的表单，这通常是一个POST HTTP请求。</p><p>2.服务器验证用户名与密码，如果合法则返回200（OK）并设置Set-Cookie为authed=true。</p><p>3.浏览器存储该Cookie。</p><p>4.浏览器发送请求时，设置Cookie字段为authed=true。</p><p>5.服务器收到第二次请求，从Cookie字段得知该用户已经登录。 按照已登录用户的权限来处理此次请求。</p><p>问题是什么？？风险是什么？？</p><p>我们知道可以发送HTTP请求的不只是浏览器，很多HTTP客户端软件（包括curl、Node.js）都可以发送任意的HTTP请求，可以设置任何头字段。 <strong>假如我们直接设置Cookie字段为authed=true并发送该HTTP请求， 服务器岂不是被欺骗了？这种攻击非常容易，Cookie是可以被篡改的</strong>！</p><p><em>当然，cookie 是有防篡改机制的，不过我不太了解，但还是有风险！！因为 cookie 是明文传输的，因此 cookie 中最好不要放敏感数据</em></p><ul><li>session 的原理</li><li></li></ul><p><strong>第一次听到 session 就是 cookie 的时候我真的一脸懵逼。WTF 说话一点都不严谨。我们可以说 session 机制是通过 cookie 机制在 HTTP服务器实现保持状态的机制！Session 是存储在服务器端的，避免了在客户端Cookie中存储敏感数据。 Session 可以存储在HTTP服务器的内存中</strong>，也可以存在内存数据库（如redis）中， 对于重量级的应用甚至可以存储在数据库中。<br>session 大家就很熟了可以将用户信息，或其他敏感信息放到 session 对象里面，并且 sesson 可以跨页面（跨页面获取 ？此处有问题？）<br>为什么可以跨页面获取，当然是通过 cookie 啦！ HTTP 每生成（新建）一个session ，都会对应生成一个 sessionId ，这个 sessionId 是该session对象的唯一对应，sessionId 实际上就是一个 cookie ，  将该Cookie传给客户端，在下次请求时就会自动带上sessionId(Cookie)。为了防止混淆，在浏览器中此Cookie默认为JSESSIONID。</p><p>思考题：后端执行这段代码 HTTP 协议到底做了什么？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">User user = new User(1，&quot;王大锤&quot;,&quot;男&quot;);</span><br><span class="line">HttpSession session = request.getSession();</span><br><span class="line">session.setAttribute(&quot;user&quot;,user);</span><br><span class="line">session.getAttribute(&quot;user&quot;);</span><br></pre></td></tr></table></figure><ul><li>session 的实现机制</li></ul><p>1.用户提交包含用户名和密码的表单，发送HTTP请求。</p><p>2.服务器验证用户发来的用户名密码。</p><p>3.如果正确则把当前用户名（通常是用户对象）存储到redis中，并生成它在redis中的ID。</p><p>这个ID称为Session ID，通过Session ID可以从Redis中取出对应的用户对象， 敏感数据（比如authed=true）都存储在这个用户对象中。</p><p>4.设置Cookie为sessionId=xxxxxx|checksum并发送HTTP响应， 仍然为每一项Cookie都设置签名。</p><p>5.用户收到HTTP响应后，便看不到任何敏感数据了。在此后的请求中发送该Cookie给服务器。</p><p>6.服务器收到此后的HTTP请求后，发现Cookie中有SessionID，进行放篡改验证。</p><p>7.如果通过了验证，根据该ID从Redis中取出对应的用户对象， 查看该对象的状态并继续执行业务逻辑。</p><p>实现上述过程，在Web应用中可以直接获得当前用户。 相当于在HTTP协议之上，通过Cookie实现了持久的会话。这个会话便称为Session。</p><h2 id="2">2. Token</h2><p>很好，开胃菜结束了，<strong>迎来了今天的主菜 Token 。</strong> 大家掌声欢迎一下 ！</p><h3 id="2.1">2.1 Token 哪里好</h3><p>1.支持跨域访问: Cookie是不允许垮域访问的，这一点对Token机制是不存在的，前提是传输的用户认证信息通过HTTP头传输。（垮域访问：两个域名之间不能跨过域名来发送请求或者请求数据）</p><p>2.<strong>无状态(也称：服务端可扩展行):Token机制在服务端不需要存储session信息，因为Token 自身包含了所有登录用户的信息，只需要在客户端的cookie或本地介质存储状态信息</strong>.</p><p>3.<strong>更适用CDN: 可以通过内容分发网络请求你服务端的所有资料（如：javascript，HTML,图片等），而你的服务端只要提供API即可</strong>.</p><p>4.<strong>去耦: 不需要绑定到一个特定的身份验证方案。Token可以在任何地方生成，只要在你的API被调用的时候，你可以进行Token生成调用即可</strong>.</p><p>5.<strong>更适用于移动应用: 当你的客户端是一个原生平台（iOS, Android，Windows 8等）时，Cookie是不被支持的（你需要通过Cookie容器进行处理），这时采用Token认证机制就会简单得多</strong>。</p><p>6.<strong>CSRF:因为不再依赖于Cookie，所以你就不需要考虑对CSRF（跨站请求伪造）的防范</strong>。</p><p>7.<strong>性能: 一次网络往返时间（通过数据库查询session信息）总比做一次HMACSHA256计算 的Token验证和解析要费时得多</strong>.</p><p>8.<strong>不需要为登录页面做特殊处理: 如果你使用Protractor 做功能测试的时候，不再需要为登录页面做特殊处理</strong>.</p><p>9.基于标准化:你的API可以采用标准化的 JSON Web Token (JWT). 这个标准已经存在多个后端库（.NET, Ruby, Java,Python, PHP）和多家公司的支持（如：Firebase,Google, Microsoft）.</p><h3 id="2.2">2.2 Token 是个啥</h3><p>Token 是 一种保持状态的的机制。不过并不像我们在 web 中学过的 Cookie 和 Session 那样是已经写好的类或对应的对象。Token 是一种用指定算法生成的 “ 串 ”。</p><ul><li>Token 原理</li></ul><p>1.将荷载payload，以及Header信息进行Base64加密，形成密文payload密文，header密文。<br>2.将形成的密文用句号链接起来，用服务端秘钥进行HS256加密，生成签名.<br>3.将前面的两个密文后面用句号链接签名形成最终的token返回到服务端<br>无图言屌</p><p><img src="https://i.imgur.com/O12gxcB.jpg" alt=""></p><p>因此 <strong>Token 可以简化为 base64url_encode(Header) + ‘.’ + base64url_encode(Claims) + ‘.’ + base64url_encode(Signature)</strong><br><strong>实际上生成这个 Token 生成一个 加密字符串(包含用户信息的加密字符串)的过程</strong></p><ul><li>Token 用法</li></ul><p>1.用户请求时携带此token（分为三部分，header密文，payload密文，签名）到服务端，服务端解析第一部分（header密文），用Base64解密，可以知道用了什么算法进行签名，此处解析发现是HS256。<br>2.服务端使用原来的秘钥与密文(header密文+”.”+payload密文)同样进行HS256运算，然后用生成的签名与token携带的签名进行对比，若一致说明token合法，不一致说明原文被修改。<br>3.判断是否过期，客户端通过用Base64解密第二部分（payload密文），可以知道荷载中授权时间，以及有效期。通过这个与当前时间对比发现token是否过期。</p><p><img src="https://i.imgur.com/0SklpWT.png" alt=""></p><h3 id="2.3">2.3 JWT 的 Java实现</h3><p>JWT 是一种基于 Token 的认证方案，生成 Token 的方式有很多种（反正给前台） 。JWT 算法可以理解为是专门为生成 Token 而存在的，它可以通过方法设置 Header , 载荷信息，设置Token过期时间等等功能。</p><ul><li>依赖</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">       &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt;</span><br><span class="line">       &lt;artifactId&gt;jjwt&lt;/artifactId&gt;</span><br><span class="line">       &lt;version&gt;0.7.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>当然，Token 并不代表着万事大吉，大吉大利，只是相对于 cookie 来说是一种更好的选择，毕竟没有完美的 web 策略嘛</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; class=&quot;headerlink&quot; title=&quot;目录&quot;&gt;&lt;/a&gt;目录&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#1&quot;&gt;1.不保存状态的 HTTP 协议&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#1.1&quot;&gt;1.1 coo
      
    
    </summary>
    
    
      <category term="JavaWeb" scheme="http://yoursite.com/tags/JavaWeb/"/>
    
  </entry>
  
  <entry>
    <title>Java工厂设计模式</title>
    <link href="http://yoursite.com/2017/12/11/Java%E5%B7%A5%E5%8E%82%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2017/12/11/Java工厂设计模式/</id>
    <published>2017-12-11T11:26:41.000Z</published>
    <updated>2017-12-11T11:32:56.978Z</updated>
    
    <content type="html"><![CDATA[<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li><a href="#0">0.阅读指南</a></li><li><a href="#1">1. 前言</a></li><li><a href="#2">2. What</a><ul><li><a href="#2.1">2.1 简单工厂模式</a></li><li><a href="#2.2">2.2 工厂方法模式</a></li><li><a href="#2.3">2.3 抽象工厂模式</a></li></ul></li><li><a href="#3">3. How</a><ul><li><a href="#3.1">3.1 引子</a></li><li><a href="#3.2">3.2 Why</a></li></ul></li><li><a href="#4">4. When</a></li><li><a href="#5">5.总结</a></li><li><a href="#6">6.参考</a></li></ul><h2 id="0">0.阅读指南</h2><p>初次接触工厂模式的同学，如果不想看枯燥的概念，可以先从<a href="#3.1">3.1引子</a>看起，回过头来在看一下概念性较多的<a href="#2">What</a>部分。</p><h2 id="1">1.前言</h2><p>当老师讲设计模式这门课整天嘴上挂着面向对象、OOP等专业术语，觉得离自己太遥远。总以为技术上的low逼怎么可能理解或者用到 GoF 的《设计模式》这本书…然鹅事实并非如此。上课迷迷糊糊听到老师讲到工厂模式，听到了Factory 这个单词，我马上被吸引了，Spring、MyBatis里面都有Factory…莫非有啥关系吗?好好看过书与上网查阅资料后，才发现设计模式离我如此之近！！！</p><h2 id="2">2.What</h2><p>在 GoF 四位大佬写的《设计模式》（被面向对象编程人员当做圣经的一本书）<strong>创建型模式</strong>这一章中，提到了五种创建型模式，这其中包括<strong>抽象工厂模式(ABSTRACT FACTORY)</strong>、<strong>工厂方法模式(FACTORY METHOD)</strong>。<br>创建型模式，顾名思义创造对象实例化过程的模式，也就是帮你造对象的模式，主要的<strong>功能就是帮助我们把对象的实例化部分抽取了出来，优化了系统的架构，并且增强了系统的扩展性</strong>。虽然四大佬在书里只提到两种创建型工厂模式，其实还有一种Java语言常用的<strong>简单工厂模式</strong>。今天就来撸一撸这三种工厂模式！</p><h3 id="2.1">2.1 简单工厂模式</h3><p>简单工厂模式的工厂类一般是使用静态方法，通过接收的参数的不同来返回不同的对象实例。不修改代码的话，是无法扩展的</p><p><img src="http://p0bl99g4r.bkt.clouddn.com/SimpleFactory.PNG" alt=""></p><h3 id="2.2">2.2 工厂方法模式</h3><p>工厂方法是针对每一种产品提供一个工厂类。通过不同的工厂实例来创建不同的产品实例。在同一等级结构中，支持增加任意产品。</p><p><img src="http://p0bl99g4r.bkt.clouddn.com/FactoryMethod.PNG" alt=""></p><h3 id="2.3">2.3 抽象工厂模式</h3><p>抽象工厂是应对产品族概念的。应对产品族概念而生，增加新的产品线很容易，但是无法增加新的产品。</p><p><img src="http://p0bl99g4r.bkt.clouddn.com/AbstractFactory.PNG" alt=""></p><h2 id="3">3. How</h2><p>事实上这三种工厂模式并没有严格的好坏之分，会因为使用场景的不同而有最适合的模式。</p><h3 id="3.1">3.1 引子</h3><p>在面向对象的世界中，最高阶的功法与核心就是模拟真实世界，把真实世界中的事物抽象成类，整个程序靠各个类的实例互相通信、互相协作完成系统功能，这非常符合真实世界的运行状况，也是面向对象思想的精髓。<br>本着这种精髓来举个例子，有这样一个人，就叫他大黄吧，他想要<strong>驾驶一辆汽车兜兜风</strong>，他可能会这样：</p><ul><li>剧本一 大黄自己造汽车</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">产品</span><br><span class="line">//汽车类</span><br><span class="line">class Car&#123;</span><br><span class="line"></span><br><span class="line">  public void move()&#123;</span><br><span class="line">     System.out.println(&quot;我只是一辆普通的小汽车，我开动了&quot;)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">使用者：</span><br><span class="line"></span><br><span class="line">//大黄先生类（调用类）</span><br><span class="line">public class DaHuang&#123;</span><br><span class="line"></span><br><span class="line">   public void drive()&#123;</span><br><span class="line">   //自己造汽车，累的一批</span><br><span class="line">   Car car = new Car();</span><br><span class="line">   //启动车</span><br><span class="line">   car.move();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有没有很累呀，大黄先生只想安静的开车兜风，但却要自己亲自造一个车(new Car) 。太不suang了，后来大黄先生发现家附近有一个汽车工厂，不仅可以造汽车，还可以选择宝马和奔驰这两种品牌，这可乐坏了大黄先生，于是：</p><ul><li>剧本二 工厂为大黄造汽车（<a href="#2.1">简单工厂模式，戳我看概念</a>）</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">                           产品</span><br><span class="line">//汽车接口</span><br><span class="line">interface Car&#123;</span><br><span class="line"></span><br><span class="line">  public void move();</span><br><span class="line">   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//宝马汽车类</span><br><span class="line">class Bwm implements Car&#123;</span><br><span class="line"></span><br><span class="line"> public void move()&#123;</span><br><span class="line">     System.out.println(&quot;我可是宝马老铁，我开动了，速度可快了呢！&quot;)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//奔驰汽车类</span><br><span class="line">class Benz implements Car&#123;</span><br><span class="line"></span><br><span class="line"> public void move()&#123;</span><br><span class="line">     System.out.println(&quot;我是奔驰呀，我开动了，我的稳定性很好&quot;)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">工厂：</span><br><span class="line"></span><br><span class="line">class CarFactory&#123;</span><br><span class="line"></span><br><span class="line">  public static Car createCar(String carBrand)&#123;</span><br><span class="line">    switch(carBrand)&#123;</span><br><span class="line">      case &quot;Bwm&quot;:</span><br><span class="line">       return new Bwm();</span><br><span class="line">   break;</span><br><span class="line">      case &quot;Benz&quot;:</span><br><span class="line">       return new Benz();</span><br><span class="line">   break;         </span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">使用者：</span><br><span class="line"></span><br><span class="line">//大黄先生类（调用类）</span><br><span class="line">public class DaHuang()&#123;</span><br><span class="line">   //依赖汽车接口</span><br><span class="line">   private Car car;</span><br><span class="line"></span><br><span class="line">   public void drive()&#123;</span><br><span class="line">   //找工厂要指定型号的汽车 </span><br><span class="line">   car = CarFactory.createCar(&quot;Bwm&quot;);</span><br><span class="line">   //启动车</span><br><span class="line">   car.move();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大黄先生开着从工厂造出来的宝马，心里想那以后开奔驰的时候还要特意跑来工厂跟厂长说我只想要奔驰，靠，我只想开车呀！可不可以在省力一点！就在这个时候厂长打来电话，告诉大黄先生，我们厂改革啦，造奔驰和造宝马的分成两个不同的厂子啦，以后给指定的厂子打电话就可以<strong>送货上门</strong>！真的吗？大黄先生高兴坏了：</p><ul><li>剧本三 大黄给奔驰汽车厂打电话，送货上门(<a href="#2.2">工厂方法模式，戳我看概念</a>)</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line">产品</span><br><span class="line">//汽车接口</span><br><span class="line">interface Car&#123;</span><br><span class="line"></span><br><span class="line">  public void move();</span><br><span class="line">   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//宝马汽车类</span><br><span class="line">class Bwm implements Car&#123;</span><br><span class="line"></span><br><span class="line"> public void move()&#123;</span><br><span class="line">     System.out.println(&quot;我可是宝马老铁，我开动了，速度可快了呢！&quot;)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//奔驰汽车类</span><br><span class="line">class Benz implements Car&#123;</span><br><span class="line"></span><br><span class="line"> public void move()&#123;</span><br><span class="line">     System.out.println(&quot;我是奔驰呀，我开动了，我的稳定性很好&quot;)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">工厂：</span><br><span class="line"></span><br><span class="line">//工厂改革了，不在这个厂区生产了，只进行图纸研发，即变成接口，只规定一些规范，</span><br><span class="line">interface CarFactory&#123;</span><br><span class="line">   </span><br><span class="line">  public Car createCar();</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//宝马汽车厂</span><br><span class="line">class BwmFactory implements CarFactory&#123;</span><br><span class="line">    </span><br><span class="line">private BwmFactory()&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //单例模式,即只提供送货上门</span><br><span class="line">    public static BwmFactory getInstance()&#123;</span><br><span class="line">        return BwmFactory();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //只生产宝马</span><br><span class="line">public Car createCar()&#123;</span><br><span class="line">    return new Bwm();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//奔驰汽车厂</span><br><span class="line">class BenzFactory implements CarFactory&#123;</span><br><span class="line">    </span><br><span class="line">    private BenzFactory()&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    //单例模式,即只提供送货上门</span><br><span class="line">    public static BenzFactory getInstence()&#123;</span><br><span class="line"></span><br><span class="line">       return new BenzFactory();</span><br><span class="line">&#125;</span><br><span class="line">     </span><br><span class="line">    //只生产宝马</span><br><span class="line">public Car createCar()&#123;</span><br><span class="line">    return new Benz();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">使用者:</span><br><span class="line"></span><br><span class="line">//大黄先生类（调用类）</span><br><span class="line">public class DaHuang()&#123;</span><br><span class="line">   //依赖汽车接口</span><br><span class="line">   private Car car;</span><br><span class="line">   public void drive()&#123;</span><br><span class="line">   //直接给生产奔驰的厂区打电话，叫他们把奔驰送过来</span><br><span class="line">   car = BenzFactory.getInstence().createCar();</span><br><span class="line">   //启动车</span><br><span class="line">   car.move();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这下大黄舒服满意了吧？他开着厂家送过来的奔驰，突然发现自己的车没有安装行车记录仪，大黄当然自己可以造一款行车记录仪（new Tachograph），但是大黄只想开车，于是大黄开车找到了行车记录仪厂家，当然可以帮大黄安装，但大黄只想开车呀，各位乡亲父老，他只想开车有错吗？这时候，汽车厂厂长又打来了电话，告诉大黄先生说，我们厂的业务扩充到行车记录仪的领域啦，以后给下面分厂打电话就可以把<strong>装有指定品牌的行车记录仪的奔驰或宝马</strong> 送货上门啦！大黄先生默默拨通了电话:</p><ul><li>剧本四 装有行车记录仪的奔驰汽车送到大黄家(<a href="#2.3">抽象工厂模式，戳我看概念</a>)</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line">产品</span><br><span class="line">//汽车接口</span><br><span class="line">interface Car&#123;</span><br><span class="line"></span><br><span class="line">  public void move();</span><br><span class="line">   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//宝马汽车类</span><br><span class="line">class Bwm implements Car&#123;</span><br><span class="line"></span><br><span class="line"> public void move()&#123;</span><br><span class="line">     System.out.println(&quot;我可是宝马老铁，我开动了，速度可快了呢！&quot;)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//奔驰汽车类</span><br><span class="line">class Benz implements Car&#123;</span><br><span class="line"></span><br><span class="line"> public void move()&#123;</span><br><span class="line">     System.out.println(&quot;我是奔驰呀，我开动了，我的稳定性很好&quot;)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//行车记录仪接口</span><br><span class="line">interface Tachograph()&#123;</span><br><span class="line">public void record();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//A品牌行车记录仪</span><br><span class="line">class TachographA() implements Tachograph&#123;</span><br><span class="line">public void record()&#123;</span><br><span class="line"> System.out.println(&quot;我是A品牌行车记录仪，我开始记录了&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//B品牌行车记录仪</span><br><span class="line">class TachographB() implements Tachograph&#123;</span><br><span class="line">public void record()&#123;</span><br><span class="line"> System.out.println(&quot;我是B品牌行车记录仪，我开始记录了&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》</span><br><span class="line">     工厂</span><br><span class="line"></span><br><span class="line">//工厂升级了，不止生产汽车，还生产行车记录仪</span><br><span class="line">interface CarAndTachographFactory&#123;</span><br><span class="line">   </span><br><span class="line">  public Car createCar();</span><br><span class="line"></span><br><span class="line">  public Tachograph creatTachograph();</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//既生产宝马又生产A品牌行车记录仪的工厂</span><br><span class="line">class BwmAndTachographAFactory()&#123;</span><br><span class="line">  </span><br><span class="line">  private BwmAndTachographAFactory()&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    //单例模式,即只提供送货上门</span><br><span class="line">    public static BwmAndTachographAFactory getInstence()&#123;</span><br><span class="line"></span><br><span class="line">       return new BwmAndTachographAFactory();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  public Car createCar()&#123;</span><br><span class="line">return new Bwm();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public Tachograph creatTachograph()&#123;</span><br><span class="line">    return new  TachographA();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//既生产奔驰又生产B类行车记录仪的工厂</span><br><span class="line">class BenzAndTachographBFactory()&#123;</span><br><span class="line"></span><br><span class="line">   private BenzAndTachographBFactory()&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    //单例模式,即只提供送货上门</span><br><span class="line">    public static BenzAndTachographBFactory getInstence()&#123;</span><br><span class="line"></span><br><span class="line">       return new BenzAndTachographBFactory();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  public Car createCar()&#123;</span><br><span class="line">return new Benz();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public Tachograph creatTachograph()&#123;</span><br><span class="line">    return new  TachographB();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》</span><br><span class="line"> 使用者</span><br><span class="line"></span><br><span class="line">//大黄先生类（调用类）</span><br><span class="line">public class DaHuang()&#123;</span><br><span class="line">   //依赖汽车接口</span><br><span class="line">   private Car car;</span><br><span class="line">   //依赖行车记录仪接口 </span><br><span class="line">   private Tachograph tachograph;</span><br><span class="line"></span><br><span class="line">   public void drive()&#123;</span><br><span class="line">   //给生产奔驰和A品牌行车记录仪的厂家打电话，叫他们把奔驰车送来</span><br><span class="line">   car = BenzAndTachographBFactory.getInstence().createCar();</span><br><span class="line">   //把A品牌行车记录仪也送过来</span><br><span class="line">   tachograph = BenzAndTachographBFactory.getInstence().creatTachograph();</span><br><span class="line">   //启动车</span><br><span class="line">   car.move();</span><br><span class="line">   //记录</span><br><span class="line">   tachograph.record();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样一来，大黄就不用再把注意力放在如何得到汽车和行车记录仪，只需要给生产指定产品组合的工厂 打call ，等待工厂为他造好就可以了。 </p><h3 id="3.2">3.2 Why</h3><p>看了上面的引子和概念，没错想必你还是一脸的懵逼。这里特意准备了几个问题，供你参考。</p><ul><li>看了这么多，所以为什么我们不要自己去 new 对象，反而要写这么多啰嗦的代码？</li></ul><blockquote><p>(1).就像引子中的多次强调的，当一个调用者的关注点仅仅是调用产品中的方法，而不想亲自创建这个具体产品的对象时，通过工厂模式可以让调用模块更加规范专注于结构上的编码。<br>(2). 实际上当我们在程序中，使用了 new 关键字，就会在内存中开辟一块地址空间，这个看似简单的过程，要经过很多的判断，例如要生成哪个子对象实例，是否需要计算或取得对象的初始设置，或在生成你需要的对象之前必须先生成一些辅助功能的对象等等判断，这不就好像一个造汽车的过程吗？<br>(3). 合作开发时的考虑，有的时候需要多人协作来完成一些项目，不同人员那肯定是写不同层次的代码如，底层，应用层，调用层，当编写调用层的人想要去获取应用层是实例，那就尴尬了，应用层根本不是他写的呀，擅自实例化肯定有危险，所以写应用层的人要为他提供工厂，让调用层实例。</p></blockquote><ul><li>直接去弄一个Factory把需要实例化的具体产品实例化不就好了吗？</li></ul><blockquote><p>这真的是一个好问题，也困扰了我很久。但实际上确实有问题中的这种工厂类（反射机制）。以下是我自己的见解，我认为所说的三种工厂设计模式是<strong>通过多态去实例化一类的产品</strong>，想一下如果你每实例化一个产品（注意是一个），都在万能类中去反射获得一个实例，你需要传入这个产品的具体类名，那这和你去 new 一个对象有什么区别? 因为这个具体的产品（类名）还是在调用的时候被暴露了！ </p></blockquote><ul><li>怎么有那么多的接口(抽象类)？工厂接口，产品接口…?</li></ul><blockquote><p>为什么会有这么多的接口，实际上一提到接口就一定会想到多态。如引子里面所描述的产品宝马汽车和奔驰汽车都是汽车这一类产品（产品接口），而工厂接口则进行了一个规定，即我的实现类或子类，必须去生产汽车这类产品，加入以后汽车产品新增了奥迪汽车，那只需要在实现一个奥迪汽车工厂用来生产奥迪就好了。保证了我们程序的可扩展性。</p></blockquote><ul><li>为什么调用者只依赖于抽象的产品接口？</li></ul><blockquote><p>实际上这是面向接口百年城的内容，这个问题和上一个问题可以一起回答，上一个问题是为什么有产品接口和工厂接口，我可以用一个词来回答你！多态！多态！还他md是多态！想一下要是不依赖于产品接口，那你的调用者要依赖一个甚至是多个具体的产品，并且一旦这个具体的产品有所改动，那整个调用者都会跟着改动。在一定程度上解耦合，依赖接口还不依赖具体实现，在替换实现类的时候，可以将影响减到最小。</p></blockquote><h2 id="4">4. When</h2><p>说了这么多，这三种工厂模式什么时候使用呢？在 MVC 设计模式下，service 与 DAO 不正好是调用者和产品的关系吗？ service 层并不在乎 DAO 如何创建，却需要 DAO 中的方法。 而设计 DAO 的方式多种多样，举几个小例子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//一个DAO接口，需要子类实现增删改查操作</span><br><span class="line">interface DAO&#123;</span><br><span class="line"></span><br><span class="line">boolean updata(arg...);</span><br><span class="line">boolean insert(arg...);</span><br><span class="line">boolean list&lt;Object&gt; get(arg...);</span><br><span class="line">boolean Object&lt;Object&gt; getList(arg...);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>简单工厂</li></ul><p>我们知道，简单工厂模式一般只有一个具体工厂类，所以当具体产品较少时，适合使用简单工厂。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">//只有两个具体实现</span><br><span class="line">class StudentDAOImp implements DAO&#123;</span><br><span class="line">      略....</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class BookDAOImp implemets DAO&#123;</span><br><span class="line">  略....</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//工厂接口</span><br><span class="line">interface IDAOFactory()&#123;</span><br><span class="line">     static DAO getDAO(String target);</span><br><span class="line">&#125;</span><br><span class="line">//简单接口</span><br><span class="line"></span><br><span class="line">class DAOFactory()&#123;</span><br><span class="line"> staticpublic DAO getDAO(String target)&#123;</span><br><span class="line">switch(target)&#123;</span><br><span class="line">         case &quot;stu&quot; :</span><br><span class="line"> return new StudentDAOImp();</span><br><span class="line">break;</span><br><span class="line"> case &quot;book&quot; :</span><br><span class="line">return new BookDAOImp();</span><br><span class="line">break;</span><br><span class="line">     &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>工厂方法 </li></ul><p>实际简单工厂是上工厂方法的特例，所以当你认为你的某类DAO产品有点多，并且很有可能还会新增这类DAO的具体实现，那就使用工厂方法模式，为该类DAO的每个具体实现派生具体工厂类。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class StudentDAOFactory()&#123;</span><br><span class="line"> staticpublic DAO getDAO(String target)&#123;</span><br><span class="line"> </span><br><span class="line">     return new StudentDAOImp();</span><br><span class="line"> </span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class BookDAOFactory()&#123;</span><br><span class="line"> staticpublic DAO getDAO(String target)&#123;</span><br><span class="line"> </span><br><span class="line">     return new  BookDAOImp();</span><br><span class="line"> </span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>抽象工厂</li></ul><p>实际上，有些时候我们的可能DAO并没有那么简单，发现并不是单纯的增删改查就万事大吉，针对不同的表有不同的操作，比如 StudentDAO 和 BookDAO 并抽取不出太多相同的操作。那这个时候 StudentDAO 和 BookDAO 就属于两种产品类，但却属于同一产品族。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//如下，这是两个不同的产品</span><br><span class="line">interface StudentDAO&#123;</span><br><span class="line">    List&lt;Student&gt; getStudents(args...);</span><br><span class="line">List&lt;Student&gt; findById(int id);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface BookDAO&#123;</span><br><span class="line">    int getBookId(args...);</span><br><span class="line">boolean deleteBook(int args); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>针对不同的DAO产品，那具体DAO产品的实现肯定不同</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">//使用JDBC实现的StudentDAO</span><br><span class="line">class StudentDAOByJdbc implements StudentDAO&#123;</span><br><span class="line"></span><br><span class="line">   略...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//使用MyBatis框架实现的StudentDAO</span><br><span class="line">class StudentDAOByMyBatis implements StudentDAO&#123;</span><br><span class="line"></span><br><span class="line">   略...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//使用JDBC实现的BookDAO</span><br><span class="line">class BookDAOByMyBatis implements BookDAO&#123;</span><br><span class="line"></span><br><span class="line">   略...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//使用MyBatis框架实现的BookDAO</span><br><span class="line">class BookDAOByMyBatis implements BookDAO&#123;</span><br><span class="line"></span><br><span class="line">   略...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重点在于抽象工厂</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">interface IDAOFactory &#123;</span><br><span class="line"></span><br><span class="line">   StudentDAO getStudentDAO();</span><br><span class="line">   BookDAO getBookDAO(); </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class JdbcDAOFactory implements IDAOFactory&#123;</span><br><span class="line">    StudentDAO getStudentDAO()&#123;</span><br><span class="line">      return new StudentDAOByJdbc();</span><br><span class="line">&#125;</span><br><span class="line">    BookDAO getBookDAO()&#123;</span><br><span class="line">  return new BookDAOByJdbc();</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class MyBatisDAOFactory implements IDAOFactory&#123;</span><br><span class="line">    StudentDAO getStudentDAO()&#123;</span><br><span class="line">      return new StudentDAOByMyBatis();</span><br><span class="line">&#125;</span><br><span class="line">    BookDAO getBookDAO()&#123;</span><br><span class="line">  return new BookDAOByMyBatis();</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>事实上，当然不会有人写直接在程序中两套DAO接口，但是当我们遇到更好的DAO解决办法（比如有Jdbc升级到MyBatis），如果再去修改原有的DAO实现，是一件很恐怖的事情，所以可以将将新写好的一套具体DAO的实现封装在实现了抽象工厂的具体工厂中，在调用层代用这个工厂中的DAO实例就OK了！！</p><h2 id="5">5. 总结</h2><ul><li>总结</li></ul><blockquote><p>1.工厂模式中，重要的是工厂类，而不是产品类。产品类可以是多种形式，多层继承或者是单个类都是可以的。但要明确的，工厂模式的接口只会返回一种类型的实例，这是在设计产品类的时候需要注意的，最好是有父类或者共同实现的接口。</p><p>2.使用工厂模式，返回的实例一定是工厂创建的，而不是从其他对象中获取的。</p><p>3.工厂模式返回的实例可以不是新创建的，返回由工厂创建好的实例也是可以的。</p><p>4.简单工厂 ： 用来生产同一等级结构中的任意产品。（对于增加新的产品，无能为力）</p><p>5.工厂方法 ：用来生产同一等级结构中的固定产品。（支持增加任意产品）</p><p>6.抽象工厂 ：用来生产不同产品族的全部产品。（对于增加新的产品，无能为力；支持增加产品族）  </p><p>7.以上三种工厂 方法在等级结构和产品族这两个方向上的支持程度不同。所以要根据情况考虑应该使用哪种方法。  </p><p>8.简单工厂优点：客户端可以免除直接创建产品对象的责任，而仅仅是“消费”产品。简单工厂模式通过这种做法实现了对责任的分割。</p><p>9.工厂方法有点：允许系统在不修改具体工厂角色的情况下引进新产品。</p><p>10.抽象工厂优点：向客户端提供一个接口，使得客户端在不必指定产品具体类型的情况下，创建多个产品族中的产品对象 </p></blockquote><h2 id="6">6. 参考</h2><p>图书：<br>GoF《设计模式》</p><p>博客：<br><a href="http://zyjustin9.iteye.com/blog/2094960" target="_blank" rel="noopener">http://zyjustin9.iteye.com/blog/2094960</a></p><p><a href="http://blog.csdn.net/hguisu/article/details/7505909" target="_blank" rel="noopener">http://blog.csdn.net/hguisu/article/details/7505909</a></p><p><a href="http://blog.csdn.net/u014600626/article/details/52131016" target="_blank" rel="noopener">http://blog.csdn.net/u014600626/article/details/52131016</a></p><p><a href="http://blog.csdn.net/u013604031/article/details/50595107" target="_blank" rel="noopener">http://blog.csdn.net/u013604031/article/details/50595107</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; class=&quot;headerlink&quot; title=&quot;目录&quot;&gt;&lt;/a&gt;目录&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#0&quot;&gt;0.阅读指南&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#1&quot;&gt;1. 前言&lt;/a&gt;&lt;/li&gt;
&lt;li
      
    
    </summary>
    
    
      <category term="设计模式" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Java优雅的处理异常</title>
    <link href="http://yoursite.com/2017/12/11/Java%E4%BC%98%E9%9B%85%E7%9A%84%E5%A4%84%E7%90%86%E5%BC%82%E5%B8%B8/"/>
    <id>http://yoursite.com/2017/12/11/Java优雅的处理异常/</id>
    <published>2017-12-11T11:23:31.000Z</published>
    <updated>2017-12-11T11:25:27.846Z</updated>
    
    <content type="html"><![CDATA[<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li><a href="#0">0. 写在前面</a></li><li><a href="#1">1. 掀起Java异常的裙子来</a><ul><li><a href="#1.1">1.1 个人对异常机制的理解</a></li><li><a href="#1.2">1.2 Java异常扫盲行动</a></li><li><a href="#1.3">1.3 Java处理异常手段</a></li><li><a href="#1.3.1">1.3.1 Java抛出异常 throw、throws</a></li><li><a href="#1.3.2">1.3.2 Java捕获异常</a></li></ul></li><li><a href="#2">2. 优雅的处理异常</a></li><li><a href="#3">3. 结语</a></li></ul><h2 id="0">0. 写在前面</h2><p>终于要说<strong>Java异常</strong>了，按照国际惯例，在前言里面BB几句，找找感觉。开始自学Java时前面大概还顺风顺水，但是到了异常这里，原地爆炸，实在不理解Java的这个机制是干啥用的。后来了解到 C++ 等高级语言也有类似的机制(事实证明，Java异常机制仿照了C++)，<strong>很长一段时间都是看见异常就很机械性的往外抛，或try catch（这里指受检异常），不明就里</strong>。慢慢发现，不止我自己是这样迷迷糊糊碰到异常就交给编译器（alt+enter 或者其他的快捷键），<strong>仿佛好多人都在刻意逃避异常—————这个不正常的家伙</strong>。</p><h2 id="1">1. 掀起Java异常的裙子来</h2><p>虽然 Java 里面有异常处理机制，并且把它当成了一个对象，但是要明确的是，<strong>绝对不应该用正常的眼光态度看待异常</strong>！好像公司正在开会，你虽然也是这个公司的员工，但却一丝不挂的来参加会议，说明肯定是你有问题！绝对一点说，异常就是某种意义上的错误，就是问题<strong>它可能会导致程序失败</strong>！ </p><h3 id="1.1">1.1 个人对异常机制的理解</h3><p>可以想象一下，当你的程序需要读取一个文件时，编译器会疯狂提示你去处理一个<code>IOEXception</code>(或者是<code>FileNotFoundException</code>这里只是举一个例子)，有没有想过为什么？编译器帮我们做的太多，以至于我们没有时间去好好思考Java设计人员的良苦用心。当我们程序运行期间，如果意外停止了，那一定是因为有错误（废话）。比如开始的那个问题，根本还没有传一个文件咋就让我处理异常?假设程序在运行期间真的出现了<code>IOException</code> 这时候你还会去看控制台打印出来的错误报告？绝对不可能，这是在一个程序运行期间，已将交给用户操作了;不处理？程序就此中断，你失去了一位用户。所以很庆幸Java提供了异常这个东西，我们可以提前去处理可能出现的异常，有可能是给用户一个提示信息，有可能是把错误信息放到日志里面，保证了程序没有因为一个错误而毫无征兆的终止（这句话太严谨了，给自己打call）！<strong>总之异常就是程序在运行期间不期而至的各种状况，而Java这种硬性要求似的处理异常机制对程序的健壮性是有好处的</strong>。</p><h3 id="1.2">1.2 Java异常扫盲大行动</h3><p>帮大家和自己顺便复习一下Java异常</p><ul><li>Java 异常的体系</li></ul><p>![]<a href="http://p0bl99g4r.bkt.clouddn.com/exception.PNG" target="_blank" rel="noopener">http://p0bl99g4r.bkt.clouddn.com/exception.PNG</a>)</p><p>如图 <code>Throwable</code> 是所有错误和异常的父类，一切皆可抛，说的就是他老人家。他的两个子类，<code>Error</code>和<code>Exception</code>。说一句，当你的程序出现了 <code>Error</code> 说明你中奖了，<code>Error</code> 指的是合理应用程序不应该去捕获的严重问题，问题很大，比如虚拟机崩溃之类的，出现<code>Error</code>这类问题没交给 JVM 吧，没有比他更专业的了。我们以下说的都是 <code>Exception</code> 中的内容。</p><ul><li>Exception </li></ul><p>它指出了合理的应用程序想要捕获的条件。Exception又分为两类：一种是CheckedException(受检异常)，一种是UncheckedException(非受检异常)。这两种Exception的区别主要是CheckedException需要用try…catch…显示的捕获UncheckedException不需要捕获。<strong>通常UncheckedException又叫做RuntimeException</strong>。</p><blockquote><p>于可恢复的条件使用被检查的异常（CheckedException），对于程序错误（言外之意不可恢复，大错已经酿成）使用运行时异常（RuntimeException）。—— 《effective java》</p></blockquote><p>我们常见的RuntimeExcepiton有IllegalArgumentException、IllegalStateException、NullPointerException、IndexOutOfBoundsException等等。对于那些CheckedException就不胜枚举了，我们在编写程序过程中try…catch…捕捉的异常都是CheckedException。io包中的IOException及其子类，这些都是CheckedException。</p><ul><li>非受查异常(UncheckedException)</li></ul><p>有一句话说的特别好，所有的 <code>RuntimeException</code> 都是程序员的问题。的确，当出现空指针、数组越界这些不需要被处理的问题，一定是我们的逻辑部分有问题。这类异常 Java编译器 并不会检查它，程序中可能出现这类异常，即使没有用try-catch语句捕获它，也没有用throws子句声明抛出它，也会编译通过。事实上我并不喜欢 <code>RuntimeException</code> 这种说法，因为所有的异常不都是发生运行时吗？</p><ul><li>受查异常(CheckedException)</li></ul><p>序语法角度讲是必须进行处理的异常，如果不处理，程序就不能编译通过。如IOException、SQLException等以及用户自定义的Exception异常，<strong>一般情况下不自定义检查异常</strong>。</p><h3 id="1.3">1.3 Java处理异常手段</h3><p>起初这里真的不想说太多，毕竟主题是优雅的处理异常，闲的无聊打开了《Java核心技术》看了一圈，默默的添加上了这一小节，学无止境…这里说的 Java处理异常的手段，大体上来讲就两种，抛出 和 捕获。　</p><h3 id="1.3.1">1.3.1 Java抛出异常 throw、throws</h3><p>英语好的同学可能一眼就能瞧出上面的两个英文啥意思，抛！这两种抛的方式都是消极处理异常的方式，注意这里的消极并不是一个贬义词。</p><ul><li>throw</li></ul><p>说实话，学习Java不到两年，这个 throw 用到的次数真的是用一个手都能数的过来。因为 throw 一般会用于程序出现某种逻辑时程序员主动抛出某种特定类型的异常。这就很尴尬了，我的编程习惯往往是通过逻辑判断去避免异常，怪不得我没怎么用到这个大兄弟。当然，Java设计者给咱们提供了，他就一定是有用的！</p><ul><li>throw 的用法:在方法体中通过逻辑判断，主动抛出特定类型的<strong>异常对象</strong>！注意异常对象这四个字！</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) throws NumberFormatException&#123;  </span><br><span class="line">        String s = &quot;abc&quot;;  </span><br><span class="line">        if(s.equals(&quot;abc&quot;)) &#123; </span><br><span class="line">//抛出一个异常对象 </span><br><span class="line">            throw new NumberFormatException();  </span><br><span class="line">        &#125; else &#123;  </span><br><span class="line">            System.out.println(s);  </span><br><span class="line">        &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的这段代码，是我随便在网上copy的。目的就是举个例子，你可以看到抛出一个异常非常的简单，首先找到一个合适的异常类，然后创建这个异常类的对象(new)，最后抛出。需要说明的是，<strong>一旦这个异常抛出了，当前的这个方法也就终止了，即这个方法没有执行完</strong>。这是一句非常重要的结论！因为，在以后学习 <strong>事务</strong> 这个很重要的知识点时，一个很重要的环节就是用到了 throw ，来决定这个方法是否执行成功。所以，throw 并不是用不到哟~</p><ul><li>throws </li></ul><p>说完了 throw，再来聊一聊 throws 。这个 throws 很常用，不同于 throw 出现在方法体，throws 出现在方法声明。意思也很简单，就是把<strong>方法中可能出现的受查异常，通过 throws 抛出，交给上一级处理</strong> 。具体例子就不贴了，说一下 throws 的规范使用姿势。</p><blockquote><p>1) 我们不必将所有可能出现的异常都抛出，如非受查异常，因为这些异常要么根本不可控要么都可以在我们的逻辑判断下避免。<br>2) 当你调用一个受查异常的方法，如 FileInputStream 的构造器，可以抛出异常。<br>3) 程序运行中发现错误，方法体中利用 throw 抛出了某种异常，使用 throws 在方法声明处将其抛出交给上层处理。如上面throw用法的代码。<br>4) 子类如果覆盖了父类中的方法，子类方法中声明的受查异常不能比父类方法声明的更通用。如父类抛了一个IOException，子类不能抛出 IOException 的父类 Exception 。<br>5) 如果父类方法没有抛出受查异常，那么子类方法也不可以抛出受查异常。</p></blockquote><h3 id="1.3.2">1.3.2 Java捕获异常</h3><p>首先来看一句情话</p><blockquote><p>世界上最真情的相依，是你在try我在catch。无论你发什么脾气，我都默默承受，静静处理。 大多数新手对java异常的感觉就是：try…catch…。没错，这是用的最多的，也是最实用的。</p></blockquote><p>try…catch… 遇到的可能比 throws 还要多，不想科普太多，简单的说一下个人理解。 </p><ul><li>catch 你真的会用吗</li></ul><p>很长一段时间，我照着视频生硬的在 catch 下面使用 Thrwoable.printStackTrace() 将异常信息打印到控制台。天真的认为，这是多么优秀简洁的代码呀！想想那时天真的自己真的是图样图森破，catch 就是对 try 块中的异常做出的处理，在调试阶段，我们当然可以通过控制台查看异常信息，看看到底是哪里出了问题。可是如果项目发布了，交给用户使用，这是程序捕获异常，你会让他去控制台看看到底出了啥问题？ 乃一物~~ <strong>所以我们可以在 catch 块中做的很多，因为一旦到了 catch 块中，try 里面的代码就不会被执行了！</strong> 举一个 JavaWeb 的例子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">//以下是伪代码，场景也可不太严谨，仅仅举个例子</span><br><span class="line"></span><br><span class="line">try&#123;</span><br><span class="line"></span><br><span class="line">//获取前台用户上传的文件 userFile</span><br><span class="line">balabalabala...</span><br><span class="line"></span><br><span class="line">// readExcel方法可以读取 Excel 格式文件，如果不是 Excel 格式抛出 IOException  </span><br><span class="line">readExcel(userFile);</span><br><span class="line"></span><br><span class="line">&#125;catch(IOException e)&#123;</span><br><span class="line"> </span><br><span class="line">//用户传来的不是 Excel 格式文件，捕获该异常,给用户提示</span><br><span class="line"></span><br><span class="line">request.setattrabute(&quot;msg&quot;,&quot;请检查您上传文件格式&quot;);</span><br><span class="line"></span><br><span class="line">//当然，我们还要删除用户上传的文件</span><br><span class="line">userFile.delete();</span><br><span class="line"></span><br><span class="line">//转发到用户刚才的页面</span><br><span class="line">request.getRequestDispatcher(&quot;xxxx.html&quot;).forward(request,response);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>try-catch-finally</li></ul><p>try-catch-finally ，无论有没有捕获到异常，finally块中的代码都会被执行。很好理解的概念，可是很多教程都把这个问题讲的很复杂 。在 finally 中我们需要注意一点 <strong>不要在 finally 中将方法 return !</strong>因为这是一个非常危险的操作，他会覆盖原有的返回值。</p><p>一个很常见的操作就是在 finally 中关闭资源，举个常见写法的例子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">InputStream in = ...;</span><br><span class="line"></span><br><span class="line">try&#123;</span><br><span class="line">balabalabala...</span><br><span class="line">&#125;catch(IOException e)&#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">//在 finally 中关闭资源</span><br><span class="line">&#125;finally&#123;</span><br><span class="line"></span><br><span class="line">try&#123;</span><br><span class="line">in.close;</span><br><span class="line">&#125;catch(IOException e)&#123;</span><br><span class="line">     e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>try-with-resourse</li></ul><p>上面的代码确实会在 finally 中会关闭输入流，但是有没有觉得很奇怪和臃肿，在关闭 输入流 时还要对 IOException 进行捕获。这简直太不优雅了！强大的Java 开发者在 <strong> Java SE 7 的版本中 引入了 try-with-resourse </strong>。上面的带码可以简化成这个样子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">File file = new File(&quot;D:\\1.txt&quot;);</span><br><span class="line">File file1 = new File(&quot;D:\\2.txt&quot;);</span><br><span class="line">try(InputStream inputStream = new FileInputStream(file)</span><br><span class="line">OutputStream outputStream = new FileOutputStream(file1))&#123;</span><br><span class="line">balabalabala</span><br><span class="line">&#125; catch (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你或许会说，这并没有关闭资源啊。别急，<strong>事实上当一个资源 实现了 AutoCloseable接口 或者 Closeable 接口，并实现了 close() 方法，在 try 块退出时，就会自动调用该资源的 close()，无论正常退出或者存在异常</strong>。 当然，这个方法或许不是一本万利，接口中的 close 方法也会抛出异常，就是说 close 抛出的异常会被压制，并被自动捕获，添加到下面的 catch 块中的异常中。但是如果你想要你的代码更加高级，优雅这种方式绝对是一个加分项。</p><h2 id="2">2. 优雅的处理异常</h2><p>优雅的处理异常，多么优雅的主题。事实上异常机制的处理有太多争论了，就像开头说的我们都在有意无意的去逃避异常。这一节，我总结了书上的理论，和编程中的一点体验去说一下关于异常的处理。</p><ul><li>1.异常处理不能代替逻辑判断</li></ul><p>看个例子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//逻辑判断</span><br><span class="line">String param = ....;</span><br><span class="line">if(param != null)</span><br><span class="line">System.out.print(param);</span><br><span class="line"></span><br><span class="line">//错误示范</span><br><span class="line">try&#123;</span><br><span class="line"></span><br><span class="line">String param = ....;</span><br><span class="line">System.out.print(param);</span><br><span class="line"></span><br><span class="line">&#125;catch(Exception e)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或许你会说，直接用 try…catch 去捕获这个空指针异常省的自己去判断，大错特错！《Java核心技术Ｉ》里面写的清楚明白，相比于简单的测试，异常处理会消耗大量的时间。<strong>我们只在异常的情况下使用异常！</strong></p><ul><li>2.不要过分细化异常</li></ul><p>不要将每一条语句分别装在一个独立的 try 语句块中。使用多个 catch 去捕获一个 try 块中的异常。例子就不举了。</p><ul><li>3.利用异常的层次结构</li></ul><p>跟我读三遍，Java异常是对象X3！异常和其他 Java对象一样，也有自己的方法，自己的爸爸和儿子，所以在捕获异常时不要用一个 Exception 或者 Throwable 一夫当关万夫莫开。选择使用哪种正确类型异常对程序的可读性很有必要。</p><ul><li>4.不要放任异常</li></ul><p>如果你捕获异常，那请你在 catch 块中做点什么吧！</p><ul><li>5.不要羞于异常的传递</li></ul><p>我记得在我刚开始编程时，我认为那些看到异常就往外抛的行为真的是不负责任，你有错误都不改正！实际上，当然还是我天真！我记得我说过，所谓的架构师就是把问题甩给别人…我们在底层（这里指被调用层）编写出来带异常的的方法，往往不知道该如何正确处理，过早的处理调用者就无法把错误消息传给更高级，所以，异常该抛就抛吧！</p><ul><li>6.不要不捕获异常（注意是个双重否定）</li></ul><p>第5点说让我们放下顾虑，勇敢的抛出异常，那是不是一直抛到最上层的调用者，然后最上层也把它抛出去？当然不是！要找到最恰当的时机去捕获，去做一些处理。</p><ul><li>7.捕获异常的时机</li></ul><p>什么时机才是捕获异常的大好时机？要看你的具体需求，如果你想在出现异常时给用户一些提示信息，那就要在最上层或者次上层捕获。如果你在测试阶段，想做一个判断，在异常出现时打印一句话，那就直接在异常出现的地方捕获。</p><ul><li>8.出现异常时对用户要友好</li></ul><p>当程序出现异常，在测试阶段会导致程序不能正常运行。已发布的项目，要是也按照这个套路来，程序终止了，留在用户在那里一脸懵逼，这就是程序员的噩梦，说明你没有考虑到异常出现时要怎样给用户一个交代！</p><ul><li>9.配合日志</li></ul><p>如果项目（JavaWeb）发布到了tomcat上面，那tomcat上的log日志会记录这个程序的运行状态，出现异常可以日志上面的记录的信息去查看哪里出了问题。如果项目没有发布在 tomcat ，可以使用一些日志框架如 log4j ，将每次出现异常的情况打印在上面。</p><ul><li>补充：对于非受查异常使用逻辑判断去代替异常的捕获</li></ul><p>在网上经常看到一些讲解异常的博客，出现用 try…catch 去捕获非受查异常这种奇葩例子（比如不会空指针，数组越界），看的我很难受！<strong>不要让程序的性能为你的逻辑错误而买单！</strong>获取参数时先判断是否为空，遍历数组时考虑一下数组下标！</p><h2 id="3">3. 结语</h2><p>浅谈了 Java 异常机制，还有好多没总结到，比如自定义异常类，异常对象的方法，异常链（确实不想了解）等等，就瞎写到这里吧。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; class=&quot;headerlink&quot; title=&quot;目录&quot;&gt;&lt;/a&gt;目录&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#0&quot;&gt;0. 写在前面&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#1&quot;&gt;1. 掀起Java异常的裙子来&lt;/
      
    
    </summary>
    
    
      <category term="JavaSE" scheme="http://yoursite.com/tags/JavaSE/"/>
    
  </entry>
  
  <entry>
    <title>初识bash</title>
    <link href="http://yoursite.com/2017/12/11/%E5%88%9D%E8%AF%86bash/"/>
    <id>http://yoursite.com/2017/12/11/初识bash/</id>
    <published>2017-12-11T11:19:19.000Z</published>
    <updated>2017-12-13T10:50:27.779Z</updated>
    
    <content type="html"><![CDATA[<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li><a href="#1">1. shell</a><ul><li><a href="#1.1">1.1 what</a></li><li><a href="#1.2">1.2 why</a></li><li><a href="#1.3">1.3 Linux中的shell</a></li></ul></li><li><a href="#2">2. bash</a><ul><li><a href="#2.1">2.1 bash的功能</a></li><li><a href="#2.2">2.2 bash的内置命令</a></li></ul></li><li><a href="#3">3. 变量</a><ul><li><a href="#3.1">3.1 what &amp; why</a></li><li><a href="#3.2">3.2 how</a></li><li><a href="#3.3">3.3 环境变量的功能</a></li><li><a href="#3.4">3.4 变量的有效范围</a></li><li><a href="#3.5">3.5 变量的键盘读取</a></li><li><a href="#3.6">3.6 变量内容的删除、替代、替换</a></li></ul></li><li><a href="#4">4. 命令别名与历史命令</a><ul><li><a href="#4.1">4.1 命令别名alias</a></li><li><a href="#4.2">4.2 历史命令history</a></li></ul></li><li><a href="#5">5. Bash Shell 的环境操作</a><ul><li><a href="#5.1">5.1 bash 的环境配置文件</a><ul><li><a href="#5.1.1">5.1.1 login shell 读取文件介绍</a></li><li><a href="#5.1.2">5.1.2 non-login shell 读取文件介绍</a></li></ul></li><li><a href="#5.2">5.2 bash 操作与通配符</a></li><li><a href="#5.2.1">5.2.1 bash默认组合键</a></li><li><a href="#5.2.2">5.2.2 通配符与特殊符号</a></li></ul></li><li><a href="#6">6. 总结</a></li></ul><h2 id="id">1. shell</h2><p>Shell 是个什么东西？接触了 Linux 后总能听到有人 Shell来Shell去，英文里面 shell 是蛋壳的意思，当你了解了 Linux下shell 的含义，你会觉得很贴切。</p><h3 id="1.1">1.1 what</h3><ul><li>系统软件与硬件的关系</li></ul><p>众所周知，没有软件的计算机只会滋滋放电，<strong>操作系统就是一组软件，计算机的硬件想要工作，需要操作系统对硬件进行管理</strong>。操作系统<strong>通过内核(kernel)对硬件进行管理</strong>。</p><ul><li>应用软件如何工作</li></ul><p>当你打开你的音乐软件听歌时，计算机的音响会发出声音，那是不是普通的应用软件也可以对硬件进行操作呢？<strong>当然不是! 如果任意软件都可以对硬件直接进行操作，那你的计算机早就炸了！</strong> 我们平时用的应用软件则是在操作系统上运行的，比如你经常听到某某软件的Windows版本，Linux版本。上面说到唯一可以与硬件通信的是系统的内核(kernel)，<strong>所以应用软件工作时，首先会和系统的内核进行沟通(把用户传来的指令发给内核)，在由内核对计算机硬件进行控制</strong>。</p><p><em>其实在这里我就已经把 shell 的含义说出来了，shell 就是让用户用来操作应用程序的方式，比如命令行、图形桌面等等，通过 shell 去对你的应用软件进行操作，软件与内核沟通，内核对硬件进行控制，如果把硬件比作蛋黄，那么最外层的shell不就正是蛋壳吗?</em></p><ul><li>shell 的种类</li></ul><p>shell是用来操作应用程序的，所以广义上来说只要是可以操作应用程序的接口(方法)，都可以叫他 shell（<strong>命令行，图形界面都是广义上的 shell</strong>）。<strong>狭义上的 shell 指的就是命令行上操作程序的接口 ，比如bash</strong>。</p><p><em>如果不做注释，下面所有出现的 shell 指的都是狭义上的。</em></p><h3 id="1.2">1.2 why</h3><p>有没有想过为打开 Linux(不限发行版本) 的各种教材，几乎全部都是让我们在 shell 下进行操作，为什么呢？因为重要被！有下面几点原因</p><ul><li>1.一致性</li></ul><p>习惯了 Winodws系统的人很难去让他摆弄命令行，下意识会使用Linux的图形界面，但是 Linux 与 Windows 很大的不同是 Linux 发行版本众多，不是每个发行版本的图形界面都一个德性（样子）的，比如我的ubuntu就比 centOS 界面美观，所以不同的发行版本界面风格和界面操作是不一样的，但是<strong>每个Linux的发行版本使用的 shell 几乎都是一样的，当你把shell玩转了,轻轻松松切换各种发行版本</strong>！</p><ul><li>2.速度快</li></ul><p>市面上流行的服务器几乎都是Linux系统，当你远程控制服务器时，考虑到网络网络延迟、连接稳定等原因，你一会选择速度更快更稳定的shell来操作你的远程主机，而不是图形界面。</p><ul><li>3.shell是Linxu的精髓</li></ul><p>使用 shell，你会对 Linux 的原理更加透彻，让你对自己Linux主机有充分的主动权！<strong>shell 才是 Linux 的精髓之所在</strong>！</p><h3 id="1.3">1.3 Linux中的shell们</h3><p>注意到小标题有一个“们”，shell 的旗下的小弟有很多，这里就不一一列举了(向写出这些shell的革命前辈献上膝盖)。<strong>你可以通过 /etc/shells 查看你的Linux中支持多少种shell</strong>。我的虚拟机中支持四种：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">dombro@ubuntu:~$ cat /etc/shells</span><br><span class="line"># /etc/shells: valid login shells</span><br><span class="line">/bin/sh</span><br><span class="line">/bin/dash</span><br><span class="line">/bin/bash</span><br><span class="line">/bin/rbash</span><br></pre></td></tr></table></figure><p>Linux 中每个用户使用的shell不一定相同，可以通过 /etc/passwd 文件查看每个用户登陆后使用的shell,看最一个数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dombro:x:1000:1000:ubuntu,,,:/home/dombro:/bin/bash</span><br><span class="line">dongbo:x:1001:1002:,,,:/home/dongbo:/bin/bash</span><br></pre></td></tr></table></figure><p><strong>Linxu下面默认的 shell 是 /bin/bash</strong>！</p><h2 id="2">2. bash</h2><p>/bin/bash 是Linxu默认的shell，有必要去了解一下,我暂时还真的没接触过别的…</p><h3 id="3">2.1 bash的功能</h3><p>说是功能，不如说是优点。bash 主要有下面这几种优点</p><ul><li>1.命令记忆功能(history)</li></ul><p>估计所有玩过Linux的人都会说这是一个相当棒的功能，在命令行中按上下键就可以找到前后输入的命令。有没有觉得很神奇？事实上，你上一次登录状态下的所有命令都会被记在用户主文件夹下的.bash_history中，像这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">dombro@ubuntu:~$ cat .bash_history</span><br><span class="line">cd /home/</span><br><span class="line">cd /usr</span><br><span class="line">history</span><br><span class="line">alias</span><br><span class="line">tee --help</span><br><span class="line">who</span><br><span class="line">who | tee who.out</span><br><span class="line">cat who.out</span><br><span class="line">bind -p</span><br><span class="line">vim who.out</span><br><span class="line">vim --help</span><br><span class="line">vi --help</span><br><span class="line">vim --help</span><br></pre></td></tr></table></figure><p>而本次的登录时的命令会被保存在内存中，退出时，这些在内存中的历史命令被写入~.bash_history文件中。但是这样一来也有一个坏处，如果你的主机被攻击了，黑客可以很轻松的获得你曾经执行过的敏感命令（密码输入），所以将记录命令的数目减少点~<a href="#4.2">具体的历史命令在4.2小节查看</a></p><ul><li>2.命令与文件补齐(tab)</li></ul><p>别跟我说你没用过这个功能，在实际输入命令或者文件名时一定要多多使用[tab]，来让bash自动的帮你补齐，省时省力！举个例子：把所有c开头的命令显示出来</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">dombro@ubuntu:~$ c[tab][tab]</span><br><span class="line">Display all 122 possibilities? (y or n)</span><br><span class="line">c++                        column</span><br><span class="line">c2ph                       combinediff</span><br><span class="line">c89                        comm</span><br><span class="line">c89-gcc                    command</span><br><span class="line">c99                        command_not_found_handle</span><br><span class="line">c99-gcc                    compare</span><br><span class="line">cal                        compare-im6</span><br><span class="line">calendar                   compgen</span><br><span class="line">calibrate_ppa              compiz</span><br><span class="line">caller                     compiz-decorator</span><br><span class="line">canberra-gtk-play          complete</span><br><span class="line">下面省略</span><br></pre></td></tr></table></figure><ul><li>3.命令别名的设置(alias)</li></ul><p>试一下直接输入<code>ll</code>命令，会不会显示出文件夹下文件的信息？实际上 Linxu 下面并没有 <code>ll</code> 这个命令啦，<code>ll</code>只是一个命令的别名，如果你嫌命令太长不好记，可以把命令设置别名像这样</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alias command=&apos;alias_command&apos;</span><br></pre></td></tr></table></figure><p>如果你想知道你设置了哪些别名直接在命令行下<code>alias</code>就好</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">dombro@ubuntu:~$ alias</span><br><span class="line">alias alert=&apos;notify-send --urgency=low -i &quot;$([ $? = 0 ] &amp;&amp; echo terminal || echo error)&quot; &quot;$(history|tail -n1|sed -e &apos;\&apos;&apos;s/^\s*[0-9]\+\s*//;s/[;&amp;|]\s*alert$//&apos;\&apos;&apos;)&quot;&apos;</span><br><span class="line">alias egrep=&apos;egrep --color=auto&apos;</span><br><span class="line">alias fgrep=&apos;fgrep --color=auto&apos;</span><br><span class="line">alias grep=&apos;grep --color=auto&apos;</span><br><span class="line">alias l=&apos;ls -CF&apos;</span><br><span class="line">alias la=&apos;ls -A&apos;</span><br><span class="line">alias ll=&apos;ls -alF&apos;</span><br><span class="line">alias ls=&apos;ls --color=auto&apos;</span><br></pre></td></tr></table></figure><p><a href="#4.2">具体的命令别名在4.1小节查看</a></p><ul><li>4.程序脚本(shell script)</li></ul><p>有没有经常听说脚本文件这个词？Linxu下的shell脚本程序可以做更多的事！</p><ul><li>5.通配符(wildcard)</li></ul><p>你一定是用过 *、%等通配符！这也是bash为我们提供的！</p><h3 id="2.2">2.2 bash的内置命令</h3><p>上面说，我们在 shell 下面通过命令操作应用程序，那是不是所有命令都是来自于应用程序？absolutely not！为了方便 shell 操作(感觉可以提高性能)，bash 为我们内置了许多命令比如 cd、umask..</p><ul><li>使用 type 命令</li></ul><p>使用 type 命令可以告诉我们这个命令是不是 一个bash内置命令 ！用法：<code>type [-tpa] command</code>。例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">dombro@ubuntu:~$ type ll</span><br><span class="line">ll is aliased to `ls -alF&apos;</span><br><span class="line">#当你看到 alias字眼 意味着这个命令是一个别名</span><br><span class="line">dombro@ubuntu:~$ type java</span><br><span class="line">java is /usr/java/jdk1.8.0_144/bin/java</span><br><span class="line">#当你看到 一串绝对路径 证明这个命令是一个外部命令</span><br><span class="line">dombro@ubuntu:~$ type cd</span><br><span class="line">cd is a shell builtin</span><br><span class="line">#当你看到 builtin 证明这个命令是一个内置命令</span><br><span class="line"></span><br><span class="line">#使用 -t 选项 ： 会直接返回一个单词告诉你这个命令的意义</span><br><span class="line">dombro@ubuntu:~$ type -t cd</span><br><span class="line">builtin</span><br><span class="line">dombro@ubuntu:~$ type -t java</span><br><span class="line">file</span><br><span class="line">dombro@ubuntu:~$ type -t ll</span><br><span class="line">alias</span><br><span class="line"></span><br><span class="line">#使用 -p 选项 ： 只有 command 为外部命令时才会显示完整文件名</span><br><span class="line">dombro@ubuntu:~$ type -p ls</span><br><span class="line">#什么都没显示，说明 ls 是一个内置命令</span><br><span class="line">dombro@ubuntu:~$ type -p java</span><br><span class="line">/usr/java/jdk1.8.0_144/bin/java</span><br><span class="line"></span><br><span class="line">#使用 -a 选项 : 由 PATH 变量定义的路径中，将所有 command 的命令都列出来，包含 alias别名</span><br><span class="line">dombro@ubuntu:~$ type -a ls</span><br><span class="line">ls is aliased to `ls --color=auto&apos;</span><br><span class="line">ls is /bin/ls</span><br><span class="line">#PATH中的ls</span><br></pre></td></tr></table></figure><p>type除了可以判断我们知道的命令是不是内置命令，还有一个作用，type只会寻找可以被执行的文件，即 type 在于找出可执行文件。</p><h2 id="3">3. 变量</h2><p><em>变量是 bash 中非常重要的东西</em>！</p><h3 di="3.1">3.1 what&amp;why</h3><p>Linux 下的变量和程序语言所说的变量在定义上几乎差不多，都是用一个固定串去表示一个不固定的内容。就是用一个简单的字眼代替一个容易变动的数字！</p><ul><li>方便操作的变量</li></ul><p>我们都知道 Linux 是多用户的，多任务的环境，每个人登陆后都会获取一个shell 。上面提到了，每个人的 shell 可能是不同的，有可能 用户1的shell 是bash，用户2的shell就是csh，系统如何去判断呢？是每次用户登录都会读取 /etc/passwd？ 我想不是这样的，每个用户使用的 shell 类型(文件)记录在一个叫 <code>SHELL</code> 的变量中，比如当我以主用户登录时 <code>SHELL</code> 中的值就是 <code>/bin/bash</code> ，系统则直接读取这个 <code>SHELL</code> 变量就好了。<strong>是不是有点类似程序语言中通过条件判断，为一个变量取不同值呢？</strong></p><p><em>更方便的变量操作还有 MAIL ，邮件操作当你执行 <code>mail</code> 这个命令时，根据用户不同 <code>MAIL</code> 变量的值为对应用户邮件目录，所以你才会准确无误的获取到你的邮件，而不需要知道你邮件的具体地址</em>。</p><ul><li>影响 bash 环境操作的变量</li></ul><p>你肯定听过 <code>PATH变量</code> 这个词。可不可以在任意目录下执行某个命令与 <code>PATH变量</code> 有很大的关系，系统就是通过 PATH 这个变量记录的路径去查找命令的。<br>说的明白点，上面举的<code>SHELL</code>的例子、<code>MAIL</code>的例子，等等<strong>这些用来在用户登录之前（准确来说是进入shell之前）得到该用户的一些数据的变量就叫环境变量</strong>。常见的环境变量有 <code>PATH</code>、<code>SHELL</code>、<code>MAIL</code>、<code>HOME</code>等。</p><ul><li>脚本程序设计(shell script)的变量</li></ul><p>在脚本程序中同样可以使用变量，这个用法和编程时的用法是一样的。</p><h3 id="3.2">3.2 how</h3><ul><li>变量与变量代表的内容</li></ul><p>可以使用 <code>echo $变量名</code> 或 <code>echo ${变量名}</code> 的方式去查看变量的内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dombro@ubuntu:~$ echo $PATH</span><br><span class="line">/usr/java/jdk1.8.0_144/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin</span><br><span class="line">#&#123;变量名&#125;效果是一样的</span><br><span class="line">dombro@ubuntu:~$ echo $&#123;PATH&#125;</span><br><span class="line">/usr/java/jdk1.8.0_144/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin</span><br></pre></td></tr></table></figure><p>使用<code>=</code>来设置变量，举个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dombro@ubuntu:~$ myname=dombro</span><br><span class="line">dombro@ubuntu:~$ echo $myname</span><br><span class="line">dombro</span><br></pre></td></tr></table></figure><p><em>当变量未被设置是默认为空。</em></p><ul><li>变量设置规则</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">1．变量与变量内容以一个等号“=”来连接，如下所示：</span><br><span class="line">“myname=dombro”</span><br><span class="line">2．等号两边不能直接接空格符，如下所示为错误的：</span><br><span class="line">“myname=dombro”或“myname=dombro Tsai”</span><br><span class="line">3．变量名称只能是英文字母与数字，但是开头字符不能是数字，如下为错误的：</span><br><span class="line">“2myname=dombro”</span><br><span class="line">4．变量内容若有空格符可使用双引号“&quot;”或单引号“&apos;”将变量内容结合起来，但是</span><br><span class="line">双引号内的特殊字符如$等，可以保有原本的特性，如下所示：</span><br><span class="line">若“var=&quot;lang is $LANG&quot;”，则“echo $var”可得“lang is en_US”</span><br><span class="line">单引号内的特殊字符则仅为一般字符（纯文本），如下所示：</span><br><span class="line">若“ar=&apos;lang is $LANG&apos;”，则“echo $var”可得“lang is $LANG”</span><br><span class="line">5．可用转义字符“\”将特殊符号（如[Enter]、$、\、空格符、！等）变成一般字符。</span><br><span class="line">6．在一串命令中，还需要通过其他的命令提供的信息，可以使用反单引号“`命令`”或“$（命令）”。特别注意，那个是键盘上方的数字键 1 左边那个按键，而不是单引号。例如想要取得内核版本的设置：</span><br><span class="line">“version=$（uname-r）”再“echo $version”可得“2.6.18-128.el5”</span><br><span class="line">7．若该变量为了增加变量内容时，则可用&quot;$变量名称&quot;或$&#123;变量&#125;累加内容，如下所示：</span><br><span class="line">“PATH=&quot;$PATH&quot;:/home/bin”</span><br><span class="line">8．若该变量需要在其他子进程执行，则需要以export来使变量变成环境变量：</span><br><span class="line">“export PATH”</span><br><span class="line">9．通常大写字符为系统默认变量，自行设置变量可以使用小写字符，方便判断（纯粹依照用户兴趣与嗜好）。</span><br><span class="line">10．取消变量的方法为使用“unset变量名称”，例如取消myname的设置：</span><br><span class="line">“unset myname”</span><br></pre></td></tr></table></figure><ul><li>范例：让变量用在下个shell程序</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">dombro@ubuntu:~$ name=dombro</span><br><span class="line">dombro@ubuntu:~$ echo $name</span><br><span class="line">dombro</span><br><span class="line">dombro@ubuntu:~$ bash</span><br><span class="line">#进入到子进程</span><br><span class="line">dombro@ubuntu:~$ echo $name</span><br><span class="line">#并没有出现在原进程中设置的变量值</span><br><span class="line">dombro@ubuntu:~$ exit</span><br><span class="line">#退出该进程</span><br><span class="line">exit</span><br><span class="line">dombro@ubuntu:~$ export name</span><br><span class="line">#使用 export</span><br><span class="line">dombro@ubuntu:~$ bash</span><br><span class="line">dombro@ubuntu:~$ echo $name</span><br><span class="line">#再次进入子进程，查看name变量，出现了变量值</span><br><span class="line">dombro</span><br></pre></td></tr></table></figure><ul><li>范例：双引号与单引号的区别</li></ul><p>双引号与单引号的区别在于，双引号可以保留变量内容，而单引号则是一般字符</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">dombro@ubuntu:~$ myname=&quot;$name is me&quot;</span><br><span class="line">dombro@ubuntu:~$ echo $myname</span><br><span class="line">dombro is me</span><br><span class="line">dombro@ubuntu:~$ myname=&apos;$name is me&apos;</span><br><span class="line">dombro@ubuntu:~$ echo $myname</span><br><span class="line">$name is me</span><br></pre></td></tr></table></figure><ul><li>范例：反单引号 ` 的作用</li></ul><p>在一串命令中，在 ` 内的命令将会被先执行，而其执行出来的结果将作为外部的输入信息。下面例子将进入用户目前内核的模块目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dombro@ubuntu:~$ cd /lib/modules/`uname -r`/kernel</span><br><span class="line">dombro@ubuntu:/lib/modules/4.4.0-98-generic/kernel$</span><br><span class="line"></span><br><span class="line">#其实上面的做了两个操作，首先进行反单引号内的 uname -r 得到内核版本 4.4.0-98-generic ，再将该结果带入cd命令。</span><br></pre></td></tr></table></figure><p>实际上使用括号() 来代替 ` 比较好，因为反单引号太容易看错了。</p><h3 id="3.3">3.3 环境变量的功能</h3><p>上面说环境变量在我们未进入shell程序之前被读取，环境变量可以帮助我们完成很多功能，我们可以通过 <code>env</code> 和 <code>export</code>来查看所有的环境变量。</p><ul><li>使用 env 查看环境变量</li></ul><p>在你的 Linux 的 bash 中输入 env，会把你所有的环境变量都列出来。是在是太多了，就不把我的贴上来了，简单介绍几个常见的环境变量。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">HOME</span><br><span class="line">代表用户的主文件夹。还记得我们可以使用cd～去到自己的主文件夹吗？或者利用cd就可以直接回到用户主文件夹了。那就是使用这个变量，有很多程序都可能会用到这个变量的值。</span><br><span class="line">SHELL</span><br><span class="line">它告知我们目前这个环境使用的shell是哪个程序？Linux默认使用/bin/bash的。</span><br><span class="line">HISTSIZE</span><br><span class="line">这个与“历史命令”有关，即是我们曾经执行过的命令可以被系统记录下来，而记录的“条数”则是由这个值来设置的。</span><br><span class="line">MAIL</span><br><span class="line">当我们使用mail这个命令在收信时系统会去读取的邮件信箱文件（mailbox）。</span><br><span class="line">PATH</span><br><span class="line">就是执行文件查找的路径，目录与目录中间以冒号（:）分隔，由于文件的查找是依序由PATH的变量内的目录来查询，所以目录的顺序也是重要的。</span><br><span class="line">LANG</span><br><span class="line">这个重要。就是语系数据，很多信息都会用到它。举例来说，当我们在启动某些Perl的程序语言文件时，它会主动去分析语系数据文件，如果发现有它无法解析的编码语系，可能会产生错误。一般来说，我们中文编码通常是 zh_CN.gb2312 或者是 zh_CN.UTF-8，这两个编码偏偏不容易被解译出来，所以有的时候，可能需要修改一下语系数据。这部分我们会在下个小节做介绍的。</span><br><span class="line">RANDOM</span><br><span class="line">这是“随机数”的变量。目前大多数的distributions都会有随机数生成器，那就是/dev/random这个文件。我们可以通过这个随机数文件相关的变量（$RANDOM）来随机取得随机数值。在BASH 的环境下，这个 RANDOM 变量的内容介于 0～32767 之间，所以你只要 echo$RANDOM时，系统就会主动随机取出一个介于0～32767的数值。万一我想要使用0～9之间的数值呢？利用declare声明数值类型，然后这样做就可以了：</span><br><span class="line">[root@www ～]# declare -i number=$RANDOM*10/32768 ; echo $number</span><br><span class="line">8 &lt;== 此时会随机取出 0～9 之间的数值。</span><br><span class="line">大致上是有这些环境变量，里面有些比较重要的参数，在下面我们都会另外进行一些说明的。</span><br></pre></td></tr></table></figure><ul><li>使用 set 查看所有变量</li></ul><p>Linux 下面不止有环境变量，上面我们自己还定义了几个变量，那要如何去查看？就可以使用 <code>set</code> 这个命令。<code>set</code> 命令可以查看包括环境变量、还有与 bash 操作接口有关的变量，以及用户自定义的变量。只要使用 set</p><p>列举几个重要的变量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">dombro@ubuntu:~$ set</span><br><span class="line">BASH=/bin/bash</span><br><span class="line">BASH_VERSION=&apos;4.3.48(1)-release&apos;</span><br><span class="line">COLUMNS=80</span><br><span class="line">BASH=/bin/bash &lt;== bash 的主程序放置路径</span><br><span class="line">BASH_VERSINFO=（[0]=&quot;3&quot; [1]=&quot;2&quot; [2]=&quot;25&quot; [3]=&quot;1&quot; [4]=&quot;release&quot;</span><br><span class="line">[5]=&quot;i686-redhat-linux-gnu&quot;） &lt;== bash 的版本。</span><br><span class="line">BASH_VERSION=&apos;3.2.25（1）-release&apos; &lt;== 也是 bash 的版本。</span><br><span class="line">COLORS=/etc/DIR_COLORS.xterm &lt;== 使用的颜色记录文件</span><br><span class="line">COLUMNS=115 &lt;== 在目前的终端机环境下，使用的字段有几个字符长度</span><br><span class="line">HISTFILE=/root/.bash_history &lt;== 历史命令记录的放置文件，隐藏文件</span><br><span class="line">HISTFILESIZE=1000 &lt;== 保存的（与上个变量有关）的文件命令的最大记录条数。</span><br><span class="line">HISTSIZE=1000 &lt;== 目前环境下可记录的历史命令最大条数。</span><br><span class="line">HOSTTYPE=i686 &lt;== 主机安装的软件主要类型。我们用的是 i686 兼容机器软件</span><br><span class="line">IFS=$&apos; \t\n&apos; &lt;== 默认的分隔符</span><br><span class="line">LINES=35 &lt;== 目前的终端机下的最大行数</span><br><span class="line">MACHTYPE=i686-redhat-linux-gnu &lt;== 安装的机器类型</span><br><span class="line">MAILCHECK=60 &lt;== 与邮件有关。每 60 秒去扫描一次信箱有无新信。</span><br><span class="line">OLDPWD=/home &lt;== 上个工作目录。我们可以用 cd - 来使用这个变量。</span><br><span class="line">OSTYPE=linux-gnu &lt;== 操作系统的类型。</span><br><span class="line">PPID=20025 &lt;== 父进程的 PID（会在后续章节才介绍）</span><br><span class="line">PS1=&apos;[\u@\h \W]\$ &apos; &lt;== PS1 就厉害了。这个是命令提示符，也就是我们常见的</span><br><span class="line">[root@www ～]# 或 [dmtsai ～]$ 的设置值。可以改动的。</span><br><span class="line">PS2=&apos;&gt; &apos; &lt;== 如果你使用转义符号（\） 第二行以后的提示符也可以被列出来。</span><br><span class="line">name=VBird &lt;== 刚才设置的自定义变量</span><br><span class="line">$ &lt;== 目前这个 shell 所使用的 PID</span><br><span class="line">? &lt;== 刚才执行完命令的回传码。</span><br><span class="line">一般来说，不论是否为环境变量，只要跟我们目前这个shell的操作接口有关的变量，通常都会被设置为大写字符，也就是说，基本上，在Linux默认的情况中，使用&#123;大写的字母&#125;来设置的变量一般为系统内定需要的变量。那么上面那些变量当中，有哪些是比较重要的？大概有这几个吧！</span><br><span class="line">PS1（提示符的设置）</span><br><span class="line">这是PS1（数字的1，不是英文字母），这个东西就是我们的“命令提示符”。当我们每次按下[Enter]按键去执行某个命令后，最后要再次出现提示符时，就会主动去读取这个变量值了。上面 PS1 内显示的是一些特殊符号，这些特殊符号可以显示不同的信息，每个 distributions的 bash 默认的 PS1 变量内容可能有些区别，你可以用 man bash 查询一下 PS1 的相关说明，以理解下面的一些符号意义。</span><br><span class="line">\d：可显示出“星期月日”的日期格式，如“Mon Feb 2”。</span><br><span class="line">\H：完整的主机名。举例来说，我练习机为“Ubuntun”。</span><br><span class="line">\h：仅取主机名在第一个小数点之前的名字，如主机为“www”，后面的省略。</span><br><span class="line">\t：显示时间，为24小时格式的“HH:MM:SS”。</span><br><span class="line">\T：显示时间，为12小时格式的“HH:MM:SS”。</span><br><span class="line">\A：显示时间，为24小时格式的“HH:MM”。</span><br><span class="line">\@：显示时间，为12小时格式的“am/pm”样式。</span><br><span class="line">\u：目前用户的账号名称，如“root”。</span><br><span class="line">\v：BASH的版本信息，如测试主版本为3.2.25（1），仅取“3.2”显示。</span><br><span class="line">\w：完整的工作目录名称，由根目录写起的目录名称。但主文件夹会以～替代。</span><br><span class="line">\W：利用basename函数取得工作目录名称，所以仅会列出最后一个目录名。</span><br><span class="line">\#：执行的第几个命令。</span><br><span class="line">\$：提示符，如果是root时，提示符为#，否则就是$。</span><br><span class="line">好了让我们来看看 CentOS 默认的 PS1 内容：[\u@\h \W]\$，现在你知道那些反斜杠后的数据意义了吧？要注意，那个反斜杠后的数据为 PS1 的特殊功能，与 bash 的变量设置没关系。不要搞混了。那你现在知道为何你的命令提示符是“[root@www～]#”了吧？好了，那么假设我想要有类似下面的提示符：</span><br><span class="line">[root@www /home/dmtsai 16:50 #12]#</span><br><span class="line">那个#代表第12次执行的命令。那么应该如何设置PS1呢？可以这样：</span><br><span class="line">[root@www ～ ]# cd /home</span><br><span class="line">[root@www home]# PS1=&apos;[\u@\h \w \A #\#]\$ &apos;</span><br><span class="line">[root@www /home 17:02 #85]#</span><br><span class="line"># 看到了吗？提示符...</span><br><span class="line"></span><br><span class="line">“$”本身也是个变量。这个代表的是目前这个Shell的线程代号，即是所谓的PID（Process ID）。更多的进程观念，我们会在第四部分的时候提及。想要知道我们的shell的PID，用“echo $$”即可，出现的数字就是你的PID号码。</span><br><span class="line">?（关于上个执行命令的回传码）</span><br><span class="line">问号也是一个特殊的变量？没错！在bash里面这个变量很重要。这个变量是上一个执行的命令所回传的值，上面这句话的重点是“上一个命令”与“回传值”两个地方。当我们执行某些命令时，这些命令都会回传一个执行后的代码。一般来说，如果成功执行该命令，则会回传一个0值，如果执行过程发生错误，就会回传“错误代码”才对。一般就是以非0的数值来替代。我们以下面的例子来说明：</span><br><span class="line">[root@www ～]# echo $SHELL</span><br><span class="line">/bin/bash &lt;==可顺利显示，没有错误。</span><br><span class="line">[root@www ～]# echo $?</span><br><span class="line">0 &lt;==因为没问题，所以回传码为 0</span><br><span class="line">[root@www ～]# 12name=VBird</span><br><span class="line">-bash: 12name=VBird: command not found &lt;==发生错误了，bash回报有问题</span><br><span class="line">[root@www ～]# echo $?</span><br><span class="line">127 &lt;==因为有问题，回传错误代码（非0）</span><br><span class="line"># 错误代码回传码依据软件而有不同，我们可以利用这个代码来找出错误的原因。</span><br><span class="line">[root@www ～]# echo $?</span><br><span class="line">0</span><br><span class="line">#怎么又变成正确了？这是因为“?”只与“上一个执行命令”有关，</span><br><span class="line"># 所以，我们上一个命令是执行“echo $? ”，当然没有错误，所以是 0 没错。</span><br><span class="line">OSTYPE，HOSTTYPE，MACHTYPE（主机硬件与内核的等级）</span><br></pre></td></tr></table></figure><ul><li>export 自定义变量转成环境变量</li></ul><p>在<a href="#3.2">3.2小节如何使变量用在下一个shell中</a>，其实我们已经使用了 <code>export</code> 这个命令，实际上在该例子中第二次输入的 <code>bash</code> 命令是一个子进程。有必要讲一下 Linux 执行命令的行为，<strong>当你登录 Linux 并取得一个 bash 后，你的 bash 就是一个独立的进程，被称为 PID 的就是。你在 bash 所执行的任何命令都是有这个 bash 衍生出来的，那些被执行的命令就被称为子进程了，最初的 bash 就叫做父进程</strong>。 为什么要了解这个概念？<strong>因为子进程会继承父进程的环境变量，但子进程不会继承父进程的自定义变量</strong>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dombro@ubuntu:~$ export 变量名称  </span><br><span class="line"># 可以把一个自定义变量变为环境变量</span><br></pre></td></tr></table></figure><p>如果 <code>export</code> 后面没有接任何参数，则会把所有的环境变量显示出来</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">declare -x CLASSPATH=&quot;.:/usr/java/jdk1.8.0_144/lib:/usr/java/jdk1.8.0_144/jre/lib&quot;</span><br><span class="line">declare -x CLUTTER_IM_MODULE=&quot;xim&quot;</span><br><span class="line">declare -x COMPIZ_CONFIG_PROFILE=&quot;ubuntu&quot;</span><br><span class="line">declare -x DBUS_SESSION_BUS_ADDRESS=&quot;unix:abstract=/tmp/dbus-c9fpv2E1HK&quot;</span><br><span class="line">....省略了很多</span><br></pre></td></tr></table></figure><h3 id="3.4">3.4 变量的有效范围</h3><p>咳咳，这是一段纯文字的内容。通过上面的环境变量与自定义变量，我们知道变量是有范围的。当程序之间出现父子进程的关系，则变量可否被引用与 export 有关。<strong>被 export 后的变量，我们可以称他为环境变量。环境变量可以被子进程引用，但是其他自定义的变量内容不会被子进程引用</strong>。有没有想过为什么？</p><p>当启动一个 shell ,操作系统会分配一块记忆块给shell使用，此内存内的变量可以被子进程取用。若在父进程利用export功能，可以让自定义变量写到上述的记忆块当中(环境变量)。当启动子进程时，子shell 可以将 父shell 环境变量所在的记忆块导入自己的环境变量块当中。</p><p><em>需要注意的是，这个环境变量与 bash的操作环境 意思不太一样，举例来说，PS1 并不是环境变量，但是这个 PS1 会影响到 bash的接口(命令提示符)</em></p><h3 id="3.5">3.5 变量的键盘读取</h3><p>上面说的变量都是直接定义的，<strong>变量还可以通过用户由键盘输入，还可以为变量声明属性，如数组或数字</strong>。</p><ul><li>read 命令 ： 读取来子键盘的输入</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@www ～]# read [-pt] variable</span><br><span class="line">参数：</span><br><span class="line">-p ：后面可以接提示符。</span><br><span class="line">-t ：后面可以接等待的“秒数。”这个比较有趣，不会一直等待用户。</span><br></pre></td></tr></table></figure><p>范例一 ：使用 read,由键盘输入变量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dombro@ubuntu:~$ read test</span><br><span class="line">hello   &lt;==== 我就是在这里输入的</span><br><span class="line">dombro@ubuntu:~$ echo $test</span><br><span class="line">hello</span><br></pre></td></tr></table></figure><p>范例二 ：给用户一些提示，并提供30秒的时间</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dombro@ubuntu:~$ read -p &quot;Please input your name&quot; -t 15 named</span><br><span class="line">Please input your name dombro</span><br><span class="line">dombro@ubuntu:~$ echo $named</span><br><span class="line">dombro</span><br></pre></td></tr></table></figure><p><em>read 之后不加任何参数，直接加上变量名称，那么下面就会主动出现一个空白行等待你的输入（如范例一）。如果加上-t后面接秒数，例如上面的范例二，那么30秒之内没有任何操作时，该命令就会自动略过了，如果是加上-p，在输入的光标前就会有比较多可以用的提示符给我们参考。在命令的执行里面，这样比较美观</em>。</p><ul><li>declare / typeset</li></ul><p>declare 和 typeset 具有相同的功能——声明变量类型。如果 declare 后面没有加任何参数，bash 会把所有比变量名称与内容调出，就好像set一样。下面是 declare 用法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@www ～]# declare [-aixr] variable</span><br><span class="line">参数：</span><br><span class="line">-a ：将后面名为 variable 的变量定义成为数组（array）类型</span><br><span class="line">-i ：将后面名为 variable 的变量定义成为整数数字（integer）类型</span><br><span class="line">-x ：用法与 export 一样，就是将后面的 variable 变成环境变量</span><br><span class="line">-r ：将变量设置成为 readonly 类型，该变量不可被更改内容，也不能重设</span><br></pre></td></tr></table></figure><p>范例一 ： 使用 -i 选项设置整型变量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dombro@ubuntu:~$ declare -i sum=100+200   </span><br><span class="line">dombro@ubuntu:~$ echo $sum</span><br><span class="line">300</span><br></pre></td></tr></table></figure><p>注意：<strong>所有变量默认的都是字符串类型，这里使用 -i 选项设置sum变量为整型变量，所以在 echo 时才会把 100+200 的整型结果显示出来</strong>。</p><p>范例二 ： 使用 -x 选项将 sum 变为环境变量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dombro@ubuntu:~$ declare -x sum   </span><br><span class="line">dombro@ubuntu:~$ env | grep sum</span><br><span class="line">sum=300</span><br></pre></td></tr></table></figure><p>范例三 ： 使用 -r 选项让 sum 变为只读属性，不可改动</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dombro@ubuntu:~$ declare -r sum</span><br><span class="line">dombro@ubuntu:~$ sum=121</span><br><span class="line">bash: sum: readonly variable</span><br></pre></td></tr></table></figure><p>范例四 ： 让 sum 变成非环境变量的自定义变量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dombro@ubuntu:~$ declare +x sum &lt;=== 将 - 变成 + 可以进行取消操作</span><br><span class="line">dombro@ubuntu:~$ declare -p sum &lt;=== -p 可以单独列出变量的类型</span><br><span class="line">declare -ir sum=&quot;300&quot;</span><br></pre></td></tr></table></figure><p>范例五 ： 使用 -a 选项声明数组</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">dombro@ubuntu:~$ declare -a names</span><br><span class="line">dombro@ubuntu:~$ names[0]=tom</span><br><span class="line">dombro@ubuntu:~$ names[1]=jim</span><br><span class="line">dombro@ubuntu:~$ names[2]=jack</span><br><span class="line">dombro@ubuntu:~$ echo $names[0],$names[1],$names[2]</span><br><span class="line">tom[0],tom[1],tom[2] &lt;=== 注意到并没有使用&#123;&#125;所以结果错误</span><br><span class="line">dombro@ubuntu:~$ echo $&#123;names[0]&#125;,$&#123;names[1]&#125;,$&#123;names[2]&#125;</span><br><span class="line">tom,jim,jack &lt;=== 出现正确结果</span><br></pre></td></tr></table></figure><p><strong>建议直接 ${数组}的方式来读取数组，会准确无误</strong>。</p><h3 id="3.6">3.6 变量内容的删除、替代、替换</h3><ul><li>变量内容的删除</li></ul><p>删除变量你可以使用 <code>unset</code> 命令，但你有想过如果想删除变量的部分内容怎么擦做吗？</p><p>首先你需要知道几个符号所表示的意义</p><blockquote><p># 表示从左往右(从前向后)，删除符合替换文字”最短的” 那一个<br>## 表示从左往右(从前向后)，删除符合替换文字”最长的” 那一个<br>* 表示通配符<br>% 表示从右向左(从后向前)，删除合替换文字”最短的” 那一个<br>%% 表示从右向左(从后向前)，删除合替换文字”最长的” 那一个</p></blockquote><p>范例一 ： 从左向右删除最短匹配串</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">dombro@ubuntu:~$ path=$&#123;PATH&#125;  &lt;=== 首先把 PATH 变量赋给 自定义的path</span><br><span class="line">dombro@ubuntu:~$ echo $path &lt;=== 查看一下</span><br><span class="line">/usr/java/jdk1.8.0_144/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin</span><br><span class="line">dombro@ubuntu:~$ echo $&#123;path#/*bin:&#125;</span><br><span class="line">&lt;=== path 代表要操作的变量</span><br><span class="line">&lt;=== # 代表从左向右删除最短</span><br><span class="line">&lt;=== /*bin: 则代表删除变量中最短的 &apos;/&apos; 到 &apos;bin:&apos; 这个串 </span><br><span class="line">/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin</span><br><span class="line">&lt;=== 发现最短的匹配串是 /usr/java/jdk1.8.0_144/bin: 便将其删除</span><br></pre></td></tr></table></figure><p>范例二 ： 从左向右删除最长匹配串</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">dombro@ubuntu:~$ echo $path</span><br><span class="line">/usr/java/jdk1.8.0_144/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin</span><br><span class="line">dombro@ubuntu:~$ echo $&#123;path##/*bin:&#125;</span><br><span class="line">&lt;=== ## 代表从左向右删除最长</span><br><span class="line">/usr/games:/usr/local/games:/snap/bin</span><br><span class="line">&lt;=== 发现最长的匹配串是 /usr/java/jdk1.8.0_144/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:</span><br></pre></td></tr></table></figure><p>范例三 ： 从右向左删除最短匹配串</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">dombro@ubuntu:~$ echo $path</span><br><span class="line">/usr/java/jdk1.8.0_144/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin</span><br><span class="line">dombro@ubuntu:~$ echo $&#123;path%:*bin&#125;</span><br><span class="line">&lt;=== % 代表从右向左删除最短匹配串</span><br><span class="line">/usr/java/jdk1.8.0_144/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games</span><br><span class="line">&lt;=== 发现最短的匹配串是 :/snap/bin</span><br></pre></td></tr></table></figure><p>范例四 ： 从右向左删除最长匹配串</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dombro@ubuntu:~$ echo $path</span><br><span class="line">/usr/java/jdk1.8.0_144/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin</span><br><span class="line">dombro@ubuntu:~$ echo $&#123;path%%:*bin&#125;</span><br><span class="line">/usr/java/jdk1.8.0_144/bin</span><br><span class="line">&lt;=== 发现最长的匹配串是 :/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin</span><br></pre></td></tr></table></figure><p><em>注意我们通过 <code>echo</code> 命令只是进行查看而已，并没有进行删除，你可以通过`path=${path%%:</em>bin}` 来达到删除变量内容的目的*</p><ul><li>变量内容的替代</li></ul><p>首先你要知道下面两个符号的意义</p><blockquote><p>${变量/旧字符串/新字符串} 若变量内容符合旧字符串，则第一个旧字符串会被新字符串替换。<br>${变量//旧字符串/新字符串} 变量内容符合旧字符串，则全部旧字符串会被新字符串替换。</p></blockquote><p>范例一 ： 替代第一个旧字符串</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dombro@ubuntu:~$ echo $path</span><br><span class="line">/usr/java/jdk1.8.0_144/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin</span><br><span class="line">dombro@ubuntu:~$ echo $&#123;path/bin/BIN&#125;</span><br><span class="line">/usr/java/jdk1.8.0_144/BIN:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin</span><br></pre></td></tr></table></figure><p>范例一 ： 替代全部旧字符串</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dombro@ubuntu:~$ echo $path</span><br><span class="line">/usr/java/jdk1.8.0_144/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin</span><br><span class="line">dombro@ubuntu:~$ echo $&#123;path//bin/BIN&#125;</span><br><span class="line">/usr/java/jdk1.8.0_144/BIN:/usr/local/sBIN:/usr/local/BIN:/usr/sBIN:/usr/BIN:/sBIN:/BIN:/usr/games:/usr/local/games:/snap/BIN</span><br></pre></td></tr></table></figure><ul><li>变量的测试与内容的替换</li></ul><p>范例一 ： 测试变量是否存在，若不存在直接付给该变量一个值 <code>变量=${变量-变量值}</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dombro@ubuntu:~$ echo $username</span><br><span class="line">&lt;=== 为空说明没有这个变量</span><br><span class="line">dombro@ubuntu:~$ username=$&#123;username-dombro&#125;</span><br><span class="line">dombro@ubuntu:~$ echo $username</span><br><span class="line">dombro</span><br></pre></td></tr></table></figure><p><em>范例中的重点在于 - ，他表示当变量不存在时，为该变量赋 -后面字符串 的值</em>。</p><p>范例二 ： 当变量未设置或变量为空字符串时直接付给变量一个值 <code>变量=${变量:-变量值}</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">dombro@ubuntu:~$ username=&quot;&quot;</span><br><span class="line">dombro@ubuntu:~$ echo $username</span><br><span class="line">&lt;=== 为空串</span><br><span class="line">dombro@ubuntu:~$ username=$&#123;username-dombro&#125;</span><br><span class="line">dombro@ubuntu:~$ echo $username</span><br><span class="line">&lt;=== 并不能更改，因为username已被设置为空串</span><br><span class="line">dombro@ubuntu:~$ username=$&#123;username:-dombro&#125;</span><br><span class="line">dombro@ubuntu:~$ echo $username</span><br><span class="line">dombro</span><br></pre></td></tr></table></figure><ul><li>变量综合范例</li></ul><p>这里针对上面提出的替换内容做一个综合范例，帮助理解</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">dombro@ubuntu:~$ str=&quot;oldvar&quot;;var=$&#123;str-newvar&#125;</span><br><span class="line">dombro@ubuntu:~$ echo var=&quot;$var&quot;,str=&quot;$str&quot;</span><br><span class="line">var=oldvar,str=oldvar &lt;=== 由于str变量存在，所以并未被设为newvar</span><br><span class="line">dombro@ubuntu:~$ unset str;var=$&#123;str=newvar&#125;</span><br><span class="line">dombro@ubuntu:~$ echo var=&quot;$var&quot;,str=&quot;$str&quot;</span><br><span class="line">var=newvar,str=newvar &lt;=== 由于str变量不存在，所以可以使用 = 被设为newvar</span><br><span class="line">dombro@ubuntu:~$ str=&quot;oldvar&quot;;var=$&#123;str=newvar&#125;</span><br><span class="line">dombro@ubuntu:~$ echo var=&quot;$var&quot;,str=&quot;$str&quot;</span><br><span class="line">var=oldvar,str=oldvar &lt;== 由于str变量存在，所以使用 = 并不能设为newvar</span><br><span class="line">dombro@ubuntu:~$ unset str;var=$&#123;str?no var&#125;</span><br><span class="line">bash: str: no var &lt;=== 变量 str 不存在，变量如果不存在使用 ? 会显示提示信息</span><br><span class="line">dombro@ubuntu:~$ str=&quot;oldvar&quot;;var=$&#123;str?no var&#125;</span><br><span class="line">dombro@ubuntu:~$ echo var=&quot;$var&quot;,str=&quot;$str&quot;</span><br><span class="line">var=oldvar,str=oldvar &lt;=== 变量存在，则不会显示提示信息</span><br></pre></td></tr></table></figure><h2 id="4">4. 命令别名与历史命令</h2><p><a href="#2.1">2.1小节bash的功能</a> 中介绍了 bash 两个很优秀的功能，命令的别名与历史命令，下面分别介绍一下</p><h3 id="4.1">4.1 命令别名 alias</h3><p>可以说命令别名是一个很有趣的功能，尤其是当你的惯用命令很长的时候。通过例子看一下</p><ul><li>使用别名命令 alias 让命令变得简单</li></ul><p>有时候要输入的命令很长是一件很烦人的事情…这时候就可以使用命令的别名 <code>alias 别名=&#39;命令参数&#39;</code> 这种写法。</p><p>范例一：将命令 <code>ls -a|more</code> 设为 <code>lm</code> 别名</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">dombro@ubuntu:~$ alias lm=&apos;ls -l|more&apos;</span><br><span class="line">dombro@ubuntu:~$ lm</span><br><span class="line">total 72</span><br><span class="line">-rw-rwxr-- 1 dombro dombro    0 Aug 27 10:38 at_example.txt</span><br><span class="line">drwxr-xr-x 3 dombro dombro 4096 Oct 22 14:00 Desktop</span><br><span class="line">drwxr-xr-x 2 dombro dombro 4096 Aug 13 17:18 Documents</span><br><span class="line">drwxr-xr-x 2 dombro dombro 4096 Aug 13 17:18 Downloads</span><br><span class="line">-rw-r--r-- 1 dombro dombro 8980 Aug 13 17:08 examples.desktop</span><br><span class="line">-rw-r--r-- 1 dombro dombro 5490 Nov 13 13:48 manpath.config</span><br><span class="line">-rw-rw-r-- 1 dombro dombro 5504 Nov 13 13:44 man.test.config</span><br><span class="line">drwxr-xr-x 2 dombro dombro 4096 Aug 13 17:18 Music</span><br><span class="line">-rwxr-xr-x 1 dombro dombro   27 Aug 29 20:49 newfile</span><br><span class="line">drwxr-xr-x 2 dombro dombro 4096 Aug 13 17:18 Pictures</span><br><span class="line">drwxr-xr-x 2 dombro dombro 4096 Aug 13 17:18 Public</span><br><span class="line">drwxrwxr-x 3 dombro dombro 4096 Aug 31 15:16 school</span><br><span class="line">drwxrwxr-x 2 dombro dombro 4096 Nov 13 13:22 temp</span><br><span class="line">drwxr-xr-x 2 dombro dombro 4096 Aug 13 17:18 Templates</span><br><span class="line">-rw-rw-r-- 1 dombro dombro    0 Nov 13 13:09 testfile</span><br><span class="line">drwxr-xr-x 2 dombro dombro 4096 Aug 13 17:18 Videos</span><br></pre></td></tr></table></figure><p>可以注意到命令别名与命令执行效果是一样一样的~</p><ul><li>命令别名设置可以替代既有命令</li></ul><p>这句话是不是有点不易理解？为什么要使用别名替代既有命令？比如你在删除(rm)时，需要特别小心，要加上 <code>-i</code> 这个选项</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dombro@ubuntu:~$ rm -i at_example.txt</span><br><span class="line">rm: remove regular empty file &apos;at_example.txt&apos;? n</span><br></pre></td></tr></table></figure><p>每次都加这个 <code>-i</code> 感觉很麻烦，所以我们可以设置 <code>rm -i</code> 的别名为 <code>rm</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dombro@ubuntu:~$ alias rm=&apos;rm -i&apos;</span><br><span class="line">dombro@ubuntu:~$ rm at_example.txt</span><br><span class="line">rm: remove regular empty file &apos;at_example.txt&apos;? n</span><br></pre></td></tr></table></figure><ul><li>查看当前所有命令别名</li></ul><p>直接输入 alias 会直接列出当前所有别名</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">dombro@ubuntu:~$ alias</span><br><span class="line">alias egrep=&apos;egrep --color=auto&apos;</span><br><span class="line">alias fgrep=&apos;fgrep --color=auto&apos;</span><br><span class="line">alias grep=&apos;grep --color=auto&apos;</span><br><span class="line">alias l=&apos;ls -CF&apos;</span><br><span class="line">alias la=&apos;ls -A&apos;</span><br><span class="line">alias ll=&apos;ls -alF&apos;</span><br><span class="line">alias lm=&apos;ls -l|more&apos;</span><br><span class="line">alias ls=&apos;ls --color=auto&apos;</span><br><span class="line">alias rm=&apos;rm -i&apos;</span><br></pre></td></tr></table></figure><ul><li>unalias 移除命令的别名</li></ul><p>没什么说的，使用 <code>unalias 命令别名</code> 就可以把命令别名去掉</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dombro@ubuntu:~$ unalias lm</span><br><span class="line">dombro@ubuntu:~$ lm</span><br><span class="line">lm: command not found</span><br></pre></td></tr></table></figure><h3 id="4.2">4.2 历史命令</h3><p>有关与历史命令不举过多例子，说几个概念吧</p><ul><li>history 命令</li></ul><p>1.直接输入 <code>history</code> 会将目前内存内的所有 history 记忆列出来</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">dombro@ubuntu:~$ history</span><br><span class="line">    1  cd /home/</span><br><span class="line">    2  cd /usr</span><br><span class="line">    3  history</span><br><span class="line">    4  alias</span><br><span class="line">    5  tee --help</span><br><span class="line">    6  who</span><br><span class="line">    7  who | tee who.out</span><br><span class="line">    8  cat who.out</span><br><span class="line">    9  bind -p</span><br><span class="line">   10  vim who.out</span><br><span class="line">   11  vim --help</span><br><span class="line">   12  vi --help</span><br><span class="line">   13  vim --help</span><br><span class="line">...后面省略</span><br></pre></td></tr></table></figure><p>2.<code>history [数字n]</code> 会列出最近 n 条命令行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">dombro@ubuntu:~$ history 20</span><br><span class="line">  660  clear</span><br><span class="line">  661  str=&quot;oldvar&quot;;var=$&#123;str-newvar&#125;</span><br><span class="line">  662  echo var=&quot;$var&quot;,str=&quot;$str&quot;</span><br><span class="line">  663  unset str;var=$&#123;str=newvar&#125;</span><br><span class="line">  664  echo var=&quot;$var&quot;,str=&quot;$str&quot;</span><br><span class="line">  665  str=&quot;oldvar&quot;;var=$&#123;str=newvar&#125;</span><br><span class="line">  666  echo var=&quot;$var&quot;,str=&quot;$str&quot;</span><br><span class="line">  667  unset str;var=$&#123;str?no var&#125;</span><br><span class="line">  668  str=&quot;oldvar&quot;;var=$&#123;str?no var&#125;</span><br><span class="line">  669  echo var=&quot;$var&quot;,str=&quot;$str&quot;</span><br><span class="line">  670  alias lm=&apos;ls -l|more&apos;</span><br><span class="line">  671  lm</span><br><span class="line">  672  rm -i at_example.txt</span><br><span class="line">  673  alias rm=&apos;rm -i&apos;</span><br><span class="line">  674  rm at_example.txt</span><br><span class="line">  675  alias</span><br><span class="line">  676  unalias lm</span><br><span class="line">  677  lm</span><br><span class="line">  678  history</span><br><span class="line">  679  history 20</span><br></pre></td></tr></table></figure><p>3.<code>history -w</code> 这种情况会将内存中的历史记录写入 <code>~/.bash_history</code> 文件中</p><p>4.<code>history -c</code> 将目前shell中所有history内容全部删除</p><p>5.<code>history -a historyfile</code> 将目前新增的history命令新增写入historyfile中，若没有加historyfile,则默认为 <code>~/.bash_history</code></p><p>6.<code>history -r historyfile</code> 将historyfile的内容读到目前这个shell的history记忆中</p><ul><li>不使用 <code>history</code> 执行命令</li></ul><p><strong>地球人都知道可以通过 ↑ ↓ 去查找执行过的历史命令</strong> ，这里介绍几个其他的方法</p><p>1.<code>!number</code> 执行第 number 条命令</p><p>2.<code>!command</code> <strong>有最近的命令向前搜寻命令串开头为<code>command</code>的那个命令</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dombro@ubuntu:~$ !cl</span><br><span class="line"></span><br><span class="line">&lt;=== 执行了 clear 命令，所以清屏了</span><br></pre></td></tr></table></figure><p>3.<strong><code>!!</code> 就是执行上一命令的意思，相当于按 ↑ 在按 [Enter]</strong></p><h2 id="5">5. Bash Shell 的环境操作</h2><p>emmm，下面这一部分有点生硬。我试着写的通俗易懂一点。 首先你需要注意一点，<strong>上面所有提到的自定义变量，命令别名在你注销 bash 后就会失效(也就是下次登录那些变量别名就都没有了)</strong>！</p><h3 id="5.1">5.1 bash 的环境配置操作</h3><p>是不是会很好奇当我们进入 Linux 时，明明什么都没有进行，但是一进入bash就会取得一堆变量？千万不要感到很神奇，其实计算机科学中所有的为我们做的事情，肯定是有一个地方储存。你肯定会想到 Linxu 中所有东西都是以文件形式存在的这句话！<strong>没错，Linux 下面存在一些环境配置文件，让 bash　启动时直接读取这些配置文件，以规划好bash的环境操作</strong>。环境变量的配置文件还可以将用户设置的变量、别名写入其中！</p><ul><li>login shell</li></ul><blockquote><p>在取得 bash 时需要完整的登录流程的，就称为 login shell。</p></blockquote><p>翻译成普通话就是：你在控制台（通过命令行）输入了账号密码登录了Linux，就叫 login shell。</p><ul><li>non-login shell</li></ul><blockquote><p>取得 bash 接口的方法不需要重复登录的举动</p></blockquote><p>翻译成普通话就是：你没有在，命令行输入了账号密码登录了Linux，就叫 non-login shell。例如用 X-windows 使用 <code>ctrl</code>+<code>alt</code>+<code>t</code> 进入 shell时，就是 non-login shell。</p><p>介绍 login-shell 和 non-login shell 的原因是因为，这两种取得 bash 的情况，读取的配置文件数据并不一致。</p><h4 id="5.1.1">5.1.1 login shell 读取文件介绍</h4><p>我们总是要登录系统的，所以先介绍login shell读取的文件。login shell 其实自会读取这两个配置文件：</p><p>1./etc/profile:系统整体设置，你最好不要修改这个文件；</p><p>2.~/.bash_profile 或 ~/.bash_login 或 ~/.profile :属于用户个人设置，你要该自己的数据就写入这里。</p><p><em>前方高能预警，这两个文件的的内容可是hin复杂的，真的好不想写这里…</em></p><ul><li>/etc/profile 内容概述</li></ul><blockquote><p>你可以使用 vim 去读取这个文件，这个文件可以利用用户的标识符(UID)来决定很多重要变量数据，也是每个用户登录取得 bash 时一定会读取的配置文件。所以如果你想要帮所有用户设置整体环境，那就是在这里修改。不过还是不要随便修改这个文件。</p></blockquote><p>下面是这个文件设置的主要变量：</p><p>PATH : 会根据UID决定PATH变量要不要含有sbin的系统命令目录。</p><p>MAIL : 根据账号设置好用户额 mailbox 到/var/spool/mail/账号名。</p><p>USER : 根据用户的账号设置此变量的内容。</p><p>HOSTORYSIZE : 历史命令记录条数。</p><p>HOSTNAME : 根据主机的hostname命令决定此变量内容。</p><p>/etc/profile 可不止会做这些事情而已，还会调取外部设置数据；至于调去哪些，我想这并不是重点的内容。 <strong>你只需要记住，bash 的login shell情况下所读取的整体环境配置文件只有/etc/profile，但是/etc/profile还会调用其他的配置文件，目的是让我们的bash接口变得非常友善</strong>。</p><ul><li>用户个人偏好设置文件</li></ul><p>login shell 所读取的个人偏好配置文件其实主要有三个，介绍了三个文件</p><blockquote><p>~/.bash_profile<br>~/.bash_login<br>~/.profile</p></blockquote><p><strong>实际上bash的 login shell 设置只会按照顺序读取上面三个文件的其中一个。也就是说如果 ~/bash_profile 存在，那么其他两个文件无论存不存在都不会去读取</strong>。我的Ubuntu下面就只有 ~/.profile 文件。</p><p>你可以将用户个人偏好设置看作是 /etc/profile 的一个补充！也就是说当 shell 通过读取 /etc/profile 之后，如果你有一些自己的变量设置，你可以在你的个人偏好设置文件中进行设置。</p><p>实际上在读取完个人偏好设置文件内容后会在调用 ~/.bashrc 设置的内容。</p><ul><li>source 命令：读入环境变量配置文件的命令</li></ul><p>由于 /etc/profile 和个人偏好设置都是在取得 login shell 的时候才会读取的配置文件，所以当你将你的偏好配置写入上述文件后，通常是的注销登录该设置才会生效。 source 命令就可以帮助我们解决这个麻烦事！</p><p><code>source 配置文件名</code> 就可以将你刚刚对环境配置文件的修改生效。这个操作很常见的，比如你要将 java javac 加入到 PATH变量 中去，在修改环境配置文件后，一定要使用 <code>source</code> 命令才会时 java 这个命令生效。</p><h4 id="5.1.2">5.1.2 non-login shell 读取文件介绍</h4><p>当你取得 non-shell 时，该 bash 配置文件仅会读取 ~/.bashrc 而已。<br>而 ~/.bashrc  会调用 /etc/bashrc 这个文件（不同的发行版本调用的文件名会不太一样，但步骤上大同小异）。为什么？因为 /etc/bashrc 这个文件会帮助 bash 定义出下面的数据：</p><p>根据不同的UID设置规定 umask 的值；</p><p>根据不同的UID规定提示符(也就是PS1变量)；</p><p>调用 /etc/profile.d/*sh 的设置</p><ul><li>5.1 小节</li></ul><p>说实话，这个部分真的觉得很鸡肋啊有没有？有很多知识点都没有记写，但是我认为环境配置文件确是获取 bash 之前最重要的一环，根据用户的信息，bash 在读取环境配置文件后才会确定当前用户的环境配置是什么。是不是很炫酷？ 你只要记住</p><p>1./etc/profile 这个环境配置文件是所有用户在login shell登录时都会读取的环境配置文件，他包含了一些基本的设置。</p><p>2./etc/profile 文件还会调用其他一些文件 如 /etc/inputrc、/etc/profile.d/*sh、/etc/sysconfig/i18n等等，调用的目的除了获取一些必要的配置信息还有就是让我们的bash 接口变得友善。</p><p>3.你或许会注意到 个人偏好配置文件 都是在用户主目录下，所以这个里面的配置主要是为了对 /etc/profile 的补充，我们尽量只去修该偏好文件里的内容，不要轻易去修改/etc/profile 的内容。</p><p>4.个人偏好设置文件会再调用 ~/.bashrc 这个文件</p><p>5.non-login shell 只会读取 ~/.bashrc 这个文件，但这个文件会再调用 /etc/bashrc 这个文件。</p><p>6.在对环境配置文件进行更改后，应该使用 source 使其改动写入当前 bash 。</p><p>7.下面图片列出 bash 在两种 shell 读取配置文件的过程，很直接:</p><p><img src="http://p0bl99g4r.bkt.clouddn.com/bash7.jpg" alt=""></p><h2 id="6">6. bash 操作与通配符</h2><p>bash 为我们提供了很多操作组合键和通配符。目的当然是为我们营造一个最舒适的用户环境，所以不会用的话是不是感觉有点亏？</p><h3 id="6.1">6.1 bash默认组合键</h3><p>有没有使用过 [ctrl] + c 这个组合键终止过一个命令？第一次摆弄 Linux 时我以为 Linxu 下面 [ctrl] + c 和 windows 下面一样是复制的意思…结果当然复制不成功，还以为是 Linux 出问题了（T_T）。下面给出 bash 的默认组合键。</p><p><img src="http://p0bl99g4r.bkt.clouddn.com/bash2.jpg" alt="bash组合按键图片"></p><h3 id="6.2">6.2 通配符与特殊符号</h3><ul><li>bash 通配符</li></ul><p>bash 的操作环境中还有一个非常有用的功能，那就是通配(wildcard)。下面列出的几个通配符，相信你是一定用到过的。</p><p><img src="http://p0bl99g4r.bkt.clouddn.com/bash2.jpg" alt="bash通配符图片"></p><p>范例一：使用 * 找出/etc/下面以字母m为开头的文件名</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:/etc# ls -dl m*</span><br></pre></td></tr></table></figure><p>范例二：使用 ? 找出/etc/下面文件名刚好是五个字母的文件名</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dombro@ubuntu:~$ ll -d /etc/?????</span><br></pre></td></tr></table></figure><p>? 代表着一定有一个字母</p><p>范例三 ： 找出 /etc/下面文件名含有数字的文件名</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dombro@ubuntu:~$ ll -d /etc/*[0-9]*</span><br></pre></td></tr></table></figure><p>[] 中括号代表一定会出现其中的一个字符，而[-] 代表包含 - 两端编码顺序内的所有字符</p><p>范例四 : 找出 /et    c/ 下面文件名开头非为小写字母的文件名</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dombro@ubuntu:~$ ll -d /etc/[^A-Z]*</span><br></pre></td></tr></table></figure><p>[^] 代表不包含^后面的字符</p><ul><li>bash 特殊符号</li></ul><p>在 bash 下面有一些符号拥有特殊的意义，所以在给文件起名字的时候尽量避开他们！用图片给出</p><p><img src="http://p0bl99g4r.bkt.clouddn.com/bash2.jpg" alt=""></p><h2 id="6">6. 总结</h2><p>标题列的是 初始bash 所以这篇笔记只是简单对 bash 有了一个了解。对 bash 的特点有一个大致上的了解。后续会提到 bash 的管道命令、重定向等等。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; class=&quot;headerlink&quot; title=&quot;目录&quot;&gt;&lt;/a&gt;目录&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#1&quot;&gt;1. shell&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#1.1&quot;&gt;1.1 what&lt;/a&gt;&lt;/l
      
    
    </summary>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>磁盘与Linux分区</title>
    <link href="http://yoursite.com/2017/12/11/%E7%A3%81%E7%9B%98%E4%B8%8ELinux%E5%88%86%E5%8C%BA/"/>
    <id>http://yoursite.com/2017/12/11/磁盘与Linux分区/</id>
    <published>2017-12-11T11:15:18.000Z</published>
    <updated>2017-12-11T11:18:44.113Z</updated>
    
    <content type="html"><![CDATA[<p>Linux系统安装在哪里？当然是在硬盘上。</p><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li><a href="#1">1. 计算机磁盘（机械）</a><ul><li><a href="#1.1">1.1 硬盘的物理组成</a></li><li><a href="#1.2">1.2 盘片上的数据</a></li><li><a href="#1.3">1.3 传输接口</a></li></ul></li><li><a href="#2">2. 磁盘分区</a><ul><li><a href="#2.1">2.1 磁盘连接的方式与设备文件名的关系</a></li><li><a href="#2.2">2.2 主引导分区与分区表</a></li><li><a href="#2.3">2.3 磁盘分区原因</a></li><li><a href="#2.3">2.4 扩展分区与逻辑分区</a></li></ul></li><li><a href="#3">3. 文件系统与目录树的关系</a><ul><li><a href="#3.1">3.1 目录树结构</a></li><li><a href="#3.2">3.2文件系统与目录树的关系(挂载)</a></li></ul></li></ul><h2 id="1">1. 计算机硬盘（机械）</h2><p>计算机上面的存储设备设备包括硬盘、软盘、MO、CD、DVD、磁带机、U盘等，都是可以用来存储数据的。而其中最常见的就是硬盘了。注意这里说的都是传统的机械硬盘。</p><h3 id="1.1">1.1 硬盘的物理组成</h3><p>大家应该都看过硬盘吧。硬盘依据桌面型与笔记本又分为3.5英寸及2.5英寸的大小。我们以3.5英寸的硬盘来说明。硬盘其实是由许多的盘片、机械手臂、磁头与主轴马达所组成的。它大概是长酱婶的</p><p><img src="http://p0bl99g4r.bkt.clouddn.com/disk.jpg" alt=""></p><p>实际的<strong>数据都是写在具有磁性物质的盘片上</strong>，而读写主要是通过在机械手臂上的读取头（Head）来完成。实际运行时，主轴马达让盘片转动，然后机械手臂可伸展让读取头在盘片上面进行读写的操作。另外由于单一盘片的容量有限，因此有的硬盘内部会有两个以上的盘片。</p><h3 id="1.2">1.2 盘片上的数据</h3><p>整个盘片上面好像有多个同心圆绘制出的饼图，而由圆心以放射状的方式分割出磁盘的最小存储单位，那就是<strong>扇区（Sector），在物理组成分面，每个扇区大小为512bytes，这个值是不会改变的</strong>。而扇区组成一个圆就成为磁道（Track），如果是在多硬盘上面，在所有盘片上面的同一个磁道可以组成一个柱面（Cylinder），柱面也是一般我们分割硬盘时的最小单位了！<br>在计算整个硬盘的存储量时，简单的计算公式就是：header数量x每个header负责的柱面数量 x 每个柱面所含有的扇区数量 x 扇区的容量，单位换算为：header x cylinder/header x secter/cylinder x 512bytes/secter，简单的写法如下：Head x Cylinder x Sector x 512bytes。不过要注意的是，一般硬盘制造商在显示硬盘的容量时，大多是以十进制来编号，因此市售的500GB硬盘，理论上仅会有460GB左右的容量。盘片其实是酱婶的</p><p><img src="http://p0bl99g4r.bkt.clouddn.com/sector.png" alt=""></p><h3 id="1.3">1.3 传输接口</h3><p>目前硬盘与主机系统的连接主要有下面传输接口规格</p><ul><li>IDE接口</li></ul><blockquote><p>IDE接口插槽所使用的排线较宽，每条排线上面可以接两个 IDE 设备，由于可以接两个设备，为了判别两个设备的主/从（Master/Slave）架构，因此这种磁盘驱动器上面需要调整跳针（Jump）成为Master或Slave才行。这种接口的最高传输速度为Ultra 133规格，即每秒理论传输速度可达133MB。</p></blockquote><ul><li>SATS接口</li></ul><blockquote><p>每条SATA连接线仅能接一个SATA设备。SATA接口除了速度较快之外，由于其排线较细小，所以有利于主机壳内部的散热与安装。目前SATA已经发展到了第二代，其速度由SATA-1的每秒150MB提升到SATA-2每秒300MB的传输速度，因此目前主流的个人计算机硬盘已经被SATA替代了。</p></blockquote><ul><li>SCSI接口</li></ul><blockquote><p>另一种常见于工作站等级以上的硬盘传输接口为SCSI接口，这种接口的硬盘在控制器上含有一块处理器，所以除了运转速度快之外，也比较不会耗费CPU资源。在个人计算机上面这种接口的硬盘不常见。</p></blockquote><h2 id="2">2. 磁盘分区</h2><p>Linux系统是安装在计算机组件的磁盘部分。一块磁盘是可以被分区成多个分区（partition），以 Windows 观点来看，你可能会有一块磁盘并且将它分区成为 C:, D:, E:盘。那个 C, D, E就是分区。但是Linux的设备都是以文件的类型存在，那分区的文件名又是什么？如何进行磁盘分区，磁盘分区有哪些限制？是我们这个小节所要探讨的内容。</p><h3 id="2.1">2.1 磁盘连接的方式与设备文件名的关系</h3><p>由上面<a href="#1.3">传输接口</a>可以知道，常见的个人计算机磁盘接口有两种，IDE和SATA（主流）接口。称可连接到IDE接口的设备为IDE设备，<strong>不管是磁盘还是光盘设备</strong>。<br>以IDE接口来说，由于一个IDE扁平电缆可以连接两个IDE设备，通常主机又都会提供两个IDE接口，因此最多可以接到四个IDE设备。也就是说，如果你已经有一个光盘设备了，那么最多就只能再接三块IDE接口的磁盘。这两个IDE接口通常被称为IDE1（primary）及IDE2（secondary），而每条扁平电缆上面的IDE设备可以被区分为Master（主设备）与Slave（从设备）。IDE设备和文件名的关系是酱婶的</p><p><img src="http://p0bl99g4r.bkt.clouddn.com/IDE.jpg" alt=""></p><p>再以SATA接口来说，由于SATA/USB/SCSI等磁盘接口都是使用SCSI模块来驱动的，因此这些接口的磁盘设备文件名都是/dev/sd[a-p]的格式。但是与IDE接口不同的是，SATA/USB接口的磁盘根本就没有一定的顺序，那如何决定它的设备文件名呢？这个时候就得要根据Linux内核检测到磁盘的顺序了</p><ul><li>SATA设备文件名例子</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">如果你的PC上面有两个SATA磁盘以及一个USB磁盘，而主板上面有六个SATA的插槽。这两个SATA磁盘分别安插在主板上的SATA1, SATA5插槽上，请问这三个磁盘在Linux中的设备文件名是什么？</span><br><span class="line">答：由于是使用检测到的顺序来决定设备文件名，并非与实际插槽代号有关，因此设备的文件名如下：</span><br><span class="line">1．SATA1插槽上的文件名：/dev/sda</span><br><span class="line">2．SATA5插槽上的文件名：/dev/sdb</span><br><span class="line">3．USB磁盘（开机完成后才被系统识别）：/dev/sdc</span><br></pre></td></tr></table></figure><p>这就是在Linux系统中不同接口的磁盘设备文件名，即 IDE接口的设备文件名为 /dev/hd[a-d] SATA接口的设备文件名为 /dev/sd[a-p]<br>可是知道了这些当然还不够!现在知道了每个磁盘设备文件名是什么，那磁盘的每个分区又该叫什么？为什么要这么纠结磁盘与设备的文件名捏？因为在<strong>Linux下面一切都是以文件的方式存在的</strong>！</p><h3 id="2.2">2.2 主引导分区与分区表</h3><p>上面提到了<a href="#1.1">磁盘的组成</a>（由盘片、机械臂、磁头、主轴马达组成）和<a href="#1.2">盘片上的数据</a>，盘片上可以分出扇区和柱面两种单位，每个扇区有512byte那么大。在这么多的扇区里面<strong>磁盘的第一个扇区最重要</strong>！！因为<strong>第一块扇区记录了整块磁盘最重要的两个信息————主引导分区和分区表</strong></p><ul><li>主引导分区(Master Boot Record,MBR)</li></ul><blockquote><p>可以安装引导加载程序的地方，有446bytes。MBR是非常重要的。系统在开机时会主动去读取这个区块的内容，这样系统才会知道你的程序放在哪了该如何进行开机。</p></blockquote><ul><li>磁盘分区表</li></ul><blockquote><p>你拿到的整块硬盘就像原木，你必须要在这根木头上切割出你想要的区段，这个区段才能在制作成为你想要的家具。同样地道理，硬盘进行分区才能更好的被利用。<br>磁盘上面的<strong>起始与结束柱面</strong>(也就是柱面的号码)就是分区的最小单位，也就是文件系统的最小单位。其实就是利用柱面的参考柱面的号码进行磁盘的分区的。在分区表所在的64byte容量中，总共分为四组记录区，每组记录了该区段的起始与结束的柱面号码。若是以硬盘为长方形来看如下图</p></blockquote><p><img src="http://p0bl99g4r.bkt.clouddn.com/partition01.jpg" alt=""></p><p>假设上图设备文件名为 /dev/hda 时，那么自四个分区在Linux系统中的设备文件名分别为 P1:/dev/hda1、P2:/dev/hda2、P3:/dev/hda3、P4:/dev/hda4 <strong>重点在于文件名后面的数字，这个数字与该分区所在的位置有关</strong>。由于分区表就只有64byte，最多只能容纳四个分区，这四个分区被称为主（Primary）或扩展(Extened)分区。</p><ul><li>分区本质</li></ul><blockquote><p>1.其实<strong>所谓的分区就是针对那个64bytes的分区表进行设置而已</strong>。<br>2.硬盘默认的分区表仅能写入四组分区信息。这四组分区信息我们称为主(Primary)或扩展(Extended)分区。<br>3.分区的最小单位为柱面<br>4.当系统写入磁盘时，一定会参考磁盘分区表，才能针对某个分区进行数据处理。</p></blockquote><h3 id="2.3">2.3 磁盘分区原因</h3><p>有没有想过这个问题，磁盘为什么要进行分区？处于以下两个方面的考虑</p><ul><li>数据的安全性</li></ul><p>因为每个分区的数据是分开的。所以，当你需要将某个分区的数据重整时，例如你要重新安装Windows时，可以将C盘中其他重要数据移到其他分区，例如将邮件、桌面数据移动到D盘去，那么重装系统并不会影响到D盘。所以善用分区，可以让你的数据更安全。</p><ul><li>系统的性能考虑</li></ul><p>由于分区将数据集中在某个柱面的区段，例如上图 当中第一个分区位于柱面号码 1～100号，如此一来当有数据要读取自该分区时，磁盘只会搜寻前面1～100的柱面范围，由于数据集中了，将有助于数据读取的速度与性能！所以说，分区是很重要的。</p><h3 id="2.4">2.4 扩展分区与逻辑分区</h3><p>有没有想过这个问题，既然分区表只有记录四组数据的空间，那是不是一块硬盘最多可以分出四个分区？我默默的看了一眼放在H盘下面的岛国动作片，显然我的电脑不止四个分区。可以做到不止四个分区的操作是如何达到的呢？答案就是扩展分区</p><ul><li>扩展分区</li></ul><p>扩展分区的想法是，既然第一个扇区所在的分区表只能记录四条数据，那我是否可以利用额外的扇区来记录更多的分区信息？就像下图</p><p><img src="http://p0bl99g4r.bkt.clouddn.com/partition02.jpg" alt=""></p><p>图中P1为主分区，P2则为扩展分区。这个扩展分区的目的是使用额外的扇区来记录分区信息，扩展分区本身并不能拿来格式化，因为他并不是一个可以挂载的文件系统。我们可以通过扩展分区所指向的那个区块继续做分区的记录。</p><ul><li>逻辑分区</li></ul><p>扩展分区指向的区块在进行切割出来的就是逻辑分区。由于逻辑分区是由扩展分区继续分区出来的，所以他可以使用的柱面范围就是扩展分区设定的范围！<br>逻辑分区的数量依操作系统而不同，在Linux系统中，IDE硬盘最多有59个逻辑分区（5号到63号），SATA硬盘则有11个逻辑分区（5号到15号）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">同样，上图分区在Linux系统中的设备文件名分别如下：</span><br><span class="line">P1:/dev/hda1</span><br><span class="line">P2:/dev/hda2</span><br><span class="line">L1:/dev/hda5</span><br><span class="line">L2:/dev/hda6</span><br><span class="line">L3:/dev/hda7</span><br><span class="line">L4:/dev/hda8</span><br><span class="line">L5:/dev/hda9</span><br><span class="line">仔细看看，怎么设备文件名没有/dev/hda3 与/dev/hda4 呢？因为前面四个号码都是保留给Primary或Extended用的。所以逻辑分区的设备名称号码就由5号开始了，这是个很重要的特性，不能忘记。</span><br></pre></td></tr></table></figure></p><ul><li>主分区、扩展分区与逻辑分区的特性的简单定义</li></ul><blockquote><p>主分区和扩展分区最多可以有四个(硬盘限制)<br>扩展分区最多只能有一个(操作系统限制)<br>逻辑分区是由扩展分区持续切割出来的分区<br>能够被格式化后作为数据访问的为主分区和逻辑分区。扩展分区无法格式化</p></blockquote><h2 id="3">3. 文件系统与目录树的关系</h2><p>在Linux中所有文件都是以文件形态来呈现的。</p><h3 id="3.1">3.1 目录树结构</h3><p>Linux内的所有数据都是以文件的形态来呈现的，所以，整个Linux系统最重要的地方就是在于目录树结构。所谓的目录树结构（directory tree）就是以根目录为主，然后向下呈现分支状的目录结构的一种文件结构。所以，整个目录树结构最重要的就是那个根目录（root directory），这个根目录的表示方法为一条斜线“/”，所有的文件都与目录树有关。目录树的呈现方式如图</p><p><img src="http://p0bl99g4r.bkt.clouddn.com/directory.jpg" alt=""></p><p>整个Linux系统使用的是目录树结构，但是我们的文件数据其实是放置在磁盘分区当中的，如何结合目录树的架构与磁盘内的数据，这就涉及到了挂载</p><h3 id="3.2">文件系统与目录树的关系(挂载)</h3><p>挂载就是利用一个目录当成进入点，将磁盘分区的数据放置在该目录下，也就是说，<strong>进入该目录就可以读取该分区的意思</strong>。这个操作就叫挂载。<strong>这个进入点我们称为挂载点</strong> 。由于整个Linux系统最重要的是根目录，因此根目录一定需要挂载到某个分区的。至于其他的目录则可依用户自己的需求来给予挂载到不同的分区。<br>举个栗子</p><p><img src="http://p0bl99g4r.bkt.clouddn.com/mount.jpg" alt=""></p><p>图 中假设我的硬盘分为两区，partition 1 挂载到根目录，至于 partition 2 则是挂载到/home这个目录。这也就是说，当我的数据放置在/home 内的各次目录时，数据是放置到 partition 2 的，如果不是放在/home 下面的目录，那么数据就会被放置到 partition 1。<br>其实判断某个文件在哪个partition下面是很简单的（前提是你要知道有哪些patrition），通过反向追踪即可。以上图来说，当我想要知道/home/vbird/test 这个文件在哪个 partition 时，由test –&gt; vbird –&gt; home –&gt;/，看哪个“进入点”先被查到那就是使用的进入点了。所以test使用的是/home这个进入点而不是/</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>简单归纳了计算机磁盘和Linux文件系统的关系</p><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><p>整理笔记参考了 <a href="http://linux.vbird.org/linux_basic/0210filepermission.php#filepermission_perm" target="_blank" rel="noopener">《鸟哥的Linux私房菜》</a> 一书。这本书我是买的<a href="http://sale.jd.com/act/W5hugLDc1R.html" target="_blank" rel="noopener">京东阅读</a>的正版电子书籍。<br><br>如果不想买书看的话可以直接戳<a href="http://linux.vbird.org/" target="_blank" rel="noopener">这里进入鸟哥Linux私房菜的线上博客 : http://linux.vbird.org/</a>。请大家支持正版！！<br><br>至于笔记中的命令我是都敲过一遍的并进行了理解，并不是单纯的复制粘贴呦！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Linux系统安装在哪里？当然是在硬盘上。&lt;/p&gt;
&lt;h2 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; class=&quot;headerlink&quot; title=&quot;目录&quot;&gt;&lt;/a&gt;目录&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#1&quot;&gt;1. 计算机磁盘（机械）&lt;/a&gt;&lt;ul&gt;
&lt;
      
    
    </summary>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>vim编辑器</title>
    <link href="http://yoursite.com/2017/12/11/vim%E7%BC%96%E8%BE%91%E5%99%A8/"/>
    <id>http://yoursite.com/2017/12/11/vim编辑器/</id>
    <published>2017-12-11T11:10:44.000Z</published>
    <updated>2017-12-11T11:37:59.052Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux-vim编辑器"><a href="#Linux-vim编辑器" class="headerlink" title="Linux vim编辑器"></a>Linux vim编辑器</h1><p>没接触Linux之前就经常听到 vi、vim 这两个词，后来简单接触过vi编辑器，今天就来一探究竟。</p><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li><a href="#1">1. what</a></li><li><a href="#2">2. why</a></li><li><a href="#3">3. how</a></li><li><a href="#4">4. do</a></li><li><a href="#5">5. more</a><ul><li><a href="#5.1">5.1 Windows 与 Linux 换行字符</a></li><li><a href="#5.2">5.2 编码转换</a></li></ul></li><li><a href="#6">6. 说明</a></li></ul><h2 id="1">1. what? 什么是vim编辑器</h2><p>Linux 中所有内容都是以文件形式存在的，所以作为系统管理员(root)重要工作就是修改某些软件的配置文件(MySql、tomcat、MongoDB等都需要配置启动)，所以就必须要学会使用一种以上的命令行界面的文本编辑器。Linux发行版本众多，但<strong>所有发行版本都会有的一款文本编辑器就是vi编辑器</strong>。而 vim编辑器 就是 vi编辑器的升级版，支持语法高亮，还可以拿来编程，优点一大堆。</p><h2 id="2">2. why? 为啥要学vim编辑器</h2><p>这原因嘛，主要有四点</p><ol><li>所有类 UNIX 系统都会内置 vi编辑器。</li><li>很多软件的编辑接口会主动调用vi编辑器，这是最重要的一点原因，太多命令默认使用vi作为数据的编辑接口，所以一定要学会 vi 呀。</li><li>vim 具有编程能力，可以根据字体颜色辨别语法的正确性，快来试试吧~</li><li>编辑速度相当快。</li></ol><p>对vim编辑器(以下简称 vim) 是不是有好感了？ 其实 vim 的官方给vim的定位是程序开发工具，而不是文字处理软件，vim加入了很多功能如支持正则表达式的查找框架，多文件编辑等等等….总之 vim 用了都说好，你值的拥有。</p><h2 id="3">3. how? 怎么使用vim编辑器</h2><p>基本上 vi 分为三种模式:一般模式、编辑模式、命令行模式。下面会给出三种模式的按钮说明，不用全记（你有精力我也不拦你），记住每种模式常用按钮操作就可以啦！</p><ul><li>一般模式</li></ul><p>在一般模式下可以进行光标移动、复制粘贴、查找替换等操作</p><p><img src="http://p0bl99g4r.bkt.clouddn.com/vim2.jpg" alt=""></p><p><img src="http://p0bl99g4r.bkt.clouddn.com/vim1.jpg" alt=""></p><p><img src="http://p0bl99g4r.bkt.clouddn.com/vim6.jpg" alt=""></p><ul><li>一般模式切换到编辑模式可用按钮</li></ul><p><img src="http://p0bl99g4r.bkt.clouddn.com/vim5.jpg" alt=""></p><ul><li>一般模式切换到命令行模式可用按钮</li></ul><p><img src="http://p0bl99g4r.bkt.clouddn.com/vim3.jpg" alt=""></p><p><img src="http://p0bl99g4r.bkt.clouddn.com/vim4.jpg" alt=""></p><h2 id="4">4. do? vim编辑器可以做什么</h2><ul><li>块选择(Visual Block)</li></ul><p>上述的简单vi操作，几乎都是以航为单位操作。下面介绍对一块范围的操作。</p><p><img src="http://p0bl99g4r.bkt.clouddn.com/vi7.jpg" alt=""></p><ul><li>多文件编辑</li></ul><p>这是一个很爽的操作，你可以通过键盘复制一个文件的内容到另一个文件 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim file1 file2</span><br></pre></td></tr></table></figure><p>这样 vim 就会编辑两个文件了，图片是操作：</p><p><img src="http://p0bl99g4r.bkt.clouddn.com/vi8.jpg" alt=""></p><ul><li>多窗口的功能</li></ul><p>vim 另一个强大的功能就是”切割窗口”，将一个或多个文件切割成多个窗口，在命令行模式通过</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">：sp&#123;file&#125;</span><br><span class="line">file 可有可无，如果有则在该窗口中启动另一个文件，没有则是同一文件的两个窗口间</span><br></pre></td></tr></table></figure><p><img src="http://p0bl99g4r.bkt.clouddn.com/vi9.jpg" alt=""></p><ul><li>vim 环境设置与记录：~/.vimrc，~/.viminfo</li></ul><blockquote><p>有没有发现，如果我们以vim软件来查找一个文件内部的某个字符串时，这个字符串会被反白，而下次我们再次以vim编辑这个文件时，该查找的字符串反白情况还是存在呢。甚至于在编辑其他文件时，如果其他文件内也存在这个字符串，竟然还是主动反白。另外，当我们重复编辑同一个文件时，当第二次进入该文件时，光标竟然就在上次离开的那一行上面。<br>这是因为我们的vim会主动将你曾经做过的行为记录下来，好让你下次可以轻松作业。那个记录操作的文件就是：～/.viminfo。如果你曾经使用过vim，那你的主文件夹应该会存在这个文件才对。这个文件是自动产生的，你不必自行创建。而你在vim里头所做过的操作就可以在这个文件内部查询到。<br>此外，每个distributions对vim的默认环境都不太相同，举例来说，某些版本在查找到关键字时并不会高亮度反白，有些版本则会主动帮你进行缩排的行为。但这些其实都可以自行设置的，那就是vim 的环境设置。vim 的环境设置参数有很多，如果你想要知道目前的设置值，可以在一般模式时输入“:set all”来查阅，不过设置选项实在太多了，在这里仅列出一些平时比较常用的一些简单的设置值，提供给你参考。<br>所谓的缩排，就是当您按下[Enter]编辑新的一行时，光标不会在行首，而是在与上一行的第一个非空格符处对齐。</p></blockquote><p><img src="http://p0bl99g4r.bkt.clouddn.com/vi10.jpg" alt=""></p><p>整体vim的设置值一般是放置在/etc/vimrc这个文件中，不过，不建议你修改它。你可以修改～/.vimrc这个文件（默认不存在，请你自行手动创建），将你所希望的设置值写入。<br>举例来说，可以是这样的一个文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@www ～]# vim ～/.vimrc</span><br><span class="line">&quot;这个文件的双引号（&quot;） 是批注</span><br><span class="line">set hlsearch &quot;高亮度反白</span><br><span class="line">set backspace=2 &quot;可随时用退格键删除</span><br><span class="line">set autoindent &quot;自动缩排</span><br><span class="line">set ruler &quot;可显示最后一行的状态</span><br><span class="line">set showmode &quot;左下角那一行的状态</span><br><span class="line">set nu &quot;可以在每一行的最前面显示行号</span><br><span class="line">set bg=dark &quot;显示不同的底色色调</span><br><span class="line">syntax on &quot;进行语法检验，颜色显示</span><br><span class="line">在这个文件中，使用“set hlsearch”或“ :set hlsearch”，即最前面有没有冒号“:”效果都是一样的。至于双引号则是批注符号，不要用错批注符号，否则每次使用vim时都会发生警告信息。</span><br><span class="line">创建好这个文件后，当你下次重新以vim编辑某个文件时，该文件的默认环境设置就是这么设置的。这样是否很方便你的操作？所以多利用vim的环境设置功能吧！</span><br></pre></td></tr></table></figure></p><h2 id="5">5. more! 更多操作</h2><p>这一小节下面，介绍两个常见的文件编辑问题，不定义与 vim 有关</p><h3 id="5.1">5.1 Windows 与 Linux 换行字符</h3><p>熟悉 Windows 和 Linux 文本编辑的同学可能知道，这<strong>两种系统的换行方式是不一样的，Windows 是以 “\r\n”(^M$) 换行（即CRLF这两个符号），而 Linux 是以 “\n”($) 换行（即LF这个符号）</strong>。两种系统不同的换行符，造成的影响很大！ 比如将 Windos 下面的文件放到 Linux 下面时，你会发现每行都会多出来一个 “^M” ，如果这是一个在 Windows 下面编写的脚本文件，可能会造成程序无法执行的尴尬事件！ 如何解决？当然是将文件换行变为 Linux 可读的样子(LF)就好了呀。你会不会想到用 vim 将每行多出来的 “^M” 删掉？这也太没人性了，<strong>Linux 提供了简单的命令来进行格式转换</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@www ～]# dos2UNIX [-kn] file [newfile]</span><br><span class="line">[root@www ～]# UNIX2dos [-kn] file [newfile]</span><br><span class="line">参数：</span><br><span class="line">-k ：保留该文件原本的 mtime 时间格式（不更新文件上次内容经过修订的时间）</span><br><span class="line">-n ：保留原本的旧文件，将转换后的内容输出到新文件，如： dos2UNIX -n oldfile newfile</span><br></pre></td></tr></table></figure><p>在不同系统之间复制一些纯文本文件时，千万记得要使用UNIX2doc或doc2UNIX来转换一下换行格式。</p><h3 id="5.2">5.2 编码的转换</h3><p>还有一个很大的问题就是编码的转换，想要将big5编码转成utf8，怎么办?答案是使用 iconv 这个命令。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@www ～]# iconv --list</span><br><span class="line">[root@www ～]# iconv -f 原本编码 -t 新编码 filename [-o newfile]</span><br><span class="line">参数：</span><br><span class="line">--list ：列出 iconv 支持的语系数据</span><br><span class="line">-f ：from ，后接原本的编码格式；</span><br><span class="line">-t ：to ，即后来的新编码要是什么格式；</span><br><span class="line">-o file：如果要保留原本的文件，那么使用 -o 新文件名，可以建立新编码文件。</span><br></pre></td></tr></table></figure><p>当你输入命令 iconv –list ，会列出一大堆信息，那就是 iconv 支持的编码。</p><ul><li>举个例子</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">将 /tmp/vitest/vi.big5 转成 utf8 编码。</span><br><span class="line">[root@www ～]# cd /tmp/vitest</span><br><span class="line">[root@www vitest]# iconv -f big5 -t utf8 vi.big5 -o vi.utf8</span><br><span class="line">[root@www vitest]# file vi*</span><br><span class="line">vi.big5: ISO-8859 text, with CRLF line terminators</span><br><span class="line">vi.utf8: UTF-8 Unicode text, with CRLF line terminators</span><br><span class="line">你会发现有明显的不同</span><br></pre></td></tr></table></figure><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><p>整理笔记参考了 <a href="http://linux.vbird.org/linux_basic/0210filepermission.php#filepermission_perm" target="_blank" rel="noopener">《鸟哥的Linux私房菜》</a> 一书。这本书我是买的<a href="http://sale.jd.com/act/W5hugLDc1R.html" target="_blank" rel="noopener">京东阅读</a>的正版电子书籍。<br><br>如果不想买书看的话可以直接戳<a href="http://linux.vbird.org/" target="_blank" rel="noopener">这里进入鸟哥Linux私房菜的线上博客 : http://linux.vbird.org/</a>。请大家支持正版！！<br><br>至于笔记中的命令我是都敲过一遍的并进行了理解，并不是单纯的复制粘贴呦！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Linux-vim编辑器&quot;&gt;&lt;a href=&quot;#Linux-vim编辑器&quot; class=&quot;headerlink&quot; title=&quot;Linux vim编辑器&quot;&gt;&lt;/a&gt;Linux vim编辑器&lt;/h1&gt;&lt;p&gt;没接触Linux之前就经常听到 vi、vim 这两个词，后来
      
    
    </summary>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux文件与文件系统的打包</title>
    <link href="http://yoursite.com/2017/12/11/Linux%E6%96%87%E4%BB%B6%E4%B8%8E%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%89%93%E5%8C%85/"/>
    <id>http://yoursite.com/2017/12/11/Linux文件与文件系统的打包/</id>
    <published>2017-12-11T11:08:38.000Z</published>
    <updated>2017-12-11T11:08:38.771Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>文件与文件系统的压缩与打包</title>
    <link href="http://yoursite.com/2017/12/11/%E6%96%87%E4%BB%B6%E4%B8%8E%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%8E%8B%E7%BC%A9%E4%B8%8E%E6%89%93%E5%8C%85/"/>
    <id>http://yoursite.com/2017/12/11/文件与文件系统的压缩与打包/</id>
    <published>2017-12-11T11:07:28.000Z</published>
    <updated>2017-12-11T11:09:58.366Z</updated>
    
    <content type="html"><![CDATA[<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li><a href="#0">前言</a></li><li><a href="#1">1.压缩文件的用途与技术</a></li><li><a href="#2">2.Linux 系统常见的压缩命令</a><ul><li><a href="#2.1">2.1 gzip,zcat</a></li><li><a href="#2.2">2.2 bzip2,bzcat</a></li></ul></li><li><a href="#3">3.打包命令：tar</a><ul><li><a href="#3.1">3.1 tar</a></li></ul></li><li><a href="#4">4.完整备份工具：dump</a><ul><li><a href="#4.1">4.1 dump</a></li><li><a href="#4.2">4.2 restore</a><h2 id="0">前言</h2></li></ul></li></ul><p>在Linux下面有相当多的压缩指令命令可以运行操作。这些压缩指令命令可以让我们更方便地从网络上面下载大型的文件呢！此外，我们知道在Linux下面的扩展名是没有什么很特殊的意义的，不过，针对这些压缩指令命令所做出来的压缩文件，为了方便记忆，还是会有一些特殊的命名方式。</p><h2 id="1">1. 压缩文件的用途与技术</h2><br>文件太大会导致占据过大的磁盘空间，从网上下载资源时文件过大也会导致传输速度变慢。文件压缩技术就可以解决这类问题。较大型的文件通过文件压缩，可以将它的磁盘使用量降低，可以达到减低文件大小的效果，有的压缩程序还可以进行大小限制，是一个大型文件分成数个小型文件。<br><br>目前计算机系统中都是使用 byte 单位来计量，但计算机最小单位是 bit ，且 1byte=8bit 这意味着每个 byte 当中会有 8 个空格，每个空格可以是 0或1 。当我们将数据记录到计算机，为了满足操作系统数据的访问会将数据转为 byte 的形态来记录，这意味着当数据不满足 1byte 大小，该 byte 里面会有很多拿来“补位”的空格。一些计算机工程师利用复杂的计算方式，将这些没有使用到的空间丢出来，让文件占用的空间变小，这就是压缩技术。<br><br><br><h2 id="2">2. Linux 系统常见的压缩命令</h2><p>Linux 支持的压缩命令非常多，且不同的命令所用的压缩技术命不相同，当然彼此之间就无法相互压缩/解压缩文件。所以，虽然文件扩展名在 Linux 中并没什么卵用，但为了让我们人类知道某个压缩文件是那种压缩命令制作出来的，好用来对照着解压缩，<strong>所以压缩文件的扩展名还是 hin 有必要滴</strong>。以下是几个常见的压缩文件扩展名：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">*.Z compress程序压缩文件（已经不流行，淘汰啦！）</span><br><span class="line">*.gz gzip程序压缩的文件；</span><br><span class="line">*.bz2 bzip2程序压缩的文件；</span><br><span class="line">*.tar tar程序打包的数据，并没有压缩过；</span><br><span class="line">*.tar.gz tar程序打包的文件，其中经过gzip的压缩；</span><br><span class="line">*.tar.bz2 tar程序打包的文件，其中经过bzip2的压缩。</span><br></pre></td></tr></table></figure></p><p><strong>Linux 中最常见的压缩命令就是 gZip和bzip2</strong>。</p><h3 id="2.1">2.1 gZip,zcat</h3><p><strong>gZip 是应用最广的压缩命令</strong>。目前 gZip 可以解开 compress，Zip 与gZip等软件压缩文件。以下是命令语法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@www~]#gzip [-cdtv#] 文件名</span><br><span class="line">[root@www ~]# zcat 文件名.gz</span><br><span class="line">参数：</span><br><span class="line">-c ：将压缩的数据输出到屏幕上，可通过数据流重定向来处理；</span><br><span class="line">-d ：解压缩的参数；</span><br><span class="line">-t ：可以用来检验一个压缩文件的一致性，看看文件有无错误；</span><br><span class="line">-v ：可以显示出原文件/压缩文件的压缩比等信息；</span><br><span class="line">-# ：压缩等级，-1最快，但是压缩比最差，-9 最慢，但是压缩比最好默认是 –6。</span><br><span class="line">``` </span><br><span class="line">- 范例：使用 gZip 进行压缩,默认状态下原文件会被压缩成 .gz 文件，原文件就不存在了。</span><br></pre></td></tr></table></figure></p><p>[root@www ~]#cd /tmp<br>[root@www tmp]#cp/ etc/man.config .<br>[root@www tmp]#gzip -v man.config<br>man.config: 56.1% – replaced with man.config.gz<br>[root@www tmp]# ll /etc/man.config /tmp/man*<br>-rw-r–r–1root root 4617 Jan 6 2007 /etc/man.config<br>-rw-r–r–1root root 2057 Nov 10 17:14 /tmp/man.config.gz &lt;==gzip压缩比较佳<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 范例：用 zcat 将上一范例压缩的文本文件读出来</span><br></pre></td></tr></table></figure></p><p>[root@www tmp]# zcat man.config.gz</p><h1 id="此时屏幕上会显示该压缩文件解压后的文件内容。"><a href="#此时屏幕上会显示该压缩文件解压后的文件内容。" class="headerlink" title="此时屏幕上会显示该压缩文件解压后的文件内容。"></a>此时屏幕上会显示该压缩文件解压后的文件内容。</h1><h1 id="zcat可以读取纯文本文件被压缩后的压缩文件。"><a href="#zcat可以读取纯文本文件被压缩后的压缩文件。" class="headerlink" title="zcat可以读取纯文本文件被压缩后的压缩文件。"></a>zcat可以读取纯文本文件被压缩后的压缩文件。</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 范例：将第一个范例的文件解压缩</span><br></pre></td></tr></table></figure><p>[root@www tmp]#gzip -d man.config.gz</p><h1 id="与gzip相反，gzip-d-会将原本的-gz-删除，产生原本的-man-config-文件。"><a href="#与gzip相反，gzip-d-会将原本的-gz-删除，产生原本的-man-config-文件。" class="headerlink" title="与gzip相反，gzip -d 会将原本的 .gz 删除，产生原本的 man.config 文件。"></a>与gzip相反，gzip -d 会将原本的 .gz 删除，产生原本的 man.config 文件。</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 范例：将上一范例解压缩的文件用最佳压缩比压缩，并保留原来的文件</span><br></pre></td></tr></table></figure><p>[root@www tmp]#gzip -9 -c man.config &gt; man.config.gz</p><p>#其实gzip的压缩已经优化过了，所以虽然gzip提供1~9的压缩等级，不过使用默认的6就非常好用了。因此上述的范例四可以不要加入那个-9的参数。</p><p>#范例的重点在那个-c与&gt;的使用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;h3 id=&quot;2.2&quot;&gt;2.2 bzip2,bzcat&lt;/h3&gt;</span><br><span class="line"></span><br><span class="line">如果gzip是为了替代compress并提供更好的压缩比而成立的，那么bzip2则是为了取代gzip并提供更佳的压缩比而来的。bzip2真是很不错的东西，这玩意的压缩比竟然比gzip还要好。至于bzip2的用法几乎与gzip相同。</span><br></pre></td></tr></table></figure></p><p>[root@www ~]#bzip2[-cdkzv#] 文件名<br>[root@www ~]# bzcat 文件名.bz2<br>参数：<br>-c ：将压缩过程中产生的数据输出到屏幕上；<br>-d ：解压缩的参数；<br>-k ：保留原文件，而不会删除原始的文件；<br>-z ：压缩的参数；<br>-v ：可以显示出原文件/压缩文件的压缩比等信息；<br>-# ：与gzip同样的，都是在计算压缩比的参数，-9 最佳，-1最快。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 范例： 将文件以 bzip2 进行压缩</span><br></pre></td></tr></table></figure></p><p>[root@www tmp]#bzip2-z man.config</p><h1 id="此时-man-config-会变成-man-config-bz2"><a href="#此时-man-config-会变成-man-config-bz2" class="headerlink" title="此时 man.config 会变成 man.config.bz2"></a>此时 man.config 会变成 man.config.bz2</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 范例：将上一范例内容读出来</span><br></pre></td></tr></table></figure><p>[root@www tmp]# bzcat man.config.bz2</p><h1 id="此时屏幕上会显示-man-config-bz2-解压缩之后的文件内容。"><a href="#此时屏幕上会显示-man-config-bz2-解压缩之后的文件内容。" class="headerlink" title="此时屏幕上会显示 man.config.bz2 解压缩之后的文件内容。"></a>此时屏幕上会显示 man.config.bz2 解压缩之后的文件内容。</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 范例： 将第一个范例的文件解压缩</span><br></pre></td></tr></table></figure><p>[root@www tmp]#bzip2 -d man.config.bz2<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 范例： 用最佳压缩比压缩，并保留原文件</span><br></pre></td></tr></table></figure></p><p>[root@www tmp]#bzip2 -9 -c man.config &gt; man.config.bz2<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;h2 id=&quot;3&quot;&gt;3. 打包命令 tar&lt;/h2&gt;</span><br><span class="line"></span><br><span class="line">上面提到的 gip、bzip2大多仅针对单一文件来进行压缩。而将多个文件过目录包成一个大文件的命令功能，称他为 &quot;打包命令&quot; 。Linux 下面这种打包命令就是大名鼎鼎的 **tar** 。 **tar 不仅可以将多个目录或文件打包成一个大文件，还可以通过 gZip/bzip2 的支持，将该文件同时进行压缩**。目前 Windows 的WinRAR 也支持 .tar.gz 文件名的解压缩。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;h3 id=&quot;3.1&quot;&gt;3.1 tar&lt;/h3&gt;</span><br><span class="line"></span><br><span class="line">tar 的参数很多，具体可以找男人 man 一下</span><br></pre></td></tr></table></figure></p><p>[root@www ~]#tar [-j|-z] [cv] [-f 新建的文件名] filename… &lt;==打包与压缩<br>[root@www ~]#tar [-j|-z] [tv] [-f新建的文件名] &lt;==查看文件名<br>[root@www ~]#tar [-j|-z] [xv] [-f 新建的文件名] [-C 目录] &lt;==解压缩<br>参数：<br>-c ：新建打包文件，可搭配 -v 来查看过程中被打包的文件名（filename）。<br>-t ：查看打包文件的内容含有哪些文件名，重点在查看文件名。<br>-x ：解打包或解压缩的功能，可以搭配 -C（大写） 在特定目录解开。<br>特别留意的是，-c, -t, -x 不可同时出现在一串命令行中。<br>-j ：通过bzip2的支持进行压缩/解压缩，此时文件名最好为 <em>.tar.bz2。<br>-z ：通过gzip的支持进行压缩/解压缩，此时文件名最好为 </em>.tar.gz。<br>-v ：在压缩/解压缩的过程中，将正在处理的文件名显示出来。<br>-f filename：-f 后面要接被处理的文件名。建议 -f 单独写一个参数。<br>-C 目录 ：这个参数用在解压缩时，若要在特定目录解压缩，可以使用这个参数。<br>其他后续练习会使用到的参数介绍：<br>-p ：保留备份数据的原本权限与属性，常用于备份（-c）重要的配置文件。<br>-P ：保留绝对路径，即允许备份数据中含有根目录存在之意。<br>–exclude=FILE：在压缩的过程中，不要将 FILE 打包。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 最简单的使用 tar 就只要记忆下面的方式即可</span><br><span class="line"></span><br><span class="line">&gt; 压 缩：tar -jcv -f filename.tar.bz2 要被压缩的文件或目录名称</span><br><span class="line">查 询：tar -jtv -f filename.tar.bz2</span><br><span class="line">解压缩：tar -jxv -f filename.tar.bz2 -C 欲解压缩的目录</span><br><span class="line">filename.tar.bz2 使我们自己取的文件名，tar 并不会主动创建文件名，要我们自定义。所以扩展名就显得很重要了。如果不加 -j|-z 的话，文件名是\*.tar 就行。 使用 -j|-z 最好根据 压缩软件的支持取名为\* .tar.gz或\*.tar.bz2。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- 范例：使用 tar 加入 -j 或 -z 的参数备份 /etc/目录</span><br></pre></td></tr></table></figure></p><p>[root@www ~]#tar -zpcv -f /root/etc.tar.gz /etc<br>tar: Removing leading `/‘ from member names &lt;==注意这个警告消息<br>/etc/<br>….中间省略….<br>/etc/esd.conf<br>/etc/crontab</p><h1 id="由于加上-v-这个参数，因此正在作用中的文件名就会显示在屏幕上。"><a href="#由于加上-v-这个参数，因此正在作用中的文件名就会显示在屏幕上。" class="headerlink" title="由于加上 -v 这个参数，因此正在作用中的文件名就会显示在屏幕上。"></a>由于加上 -v 这个参数，因此正在作用中的文件名就会显示在屏幕上。</h1><h1 id="如果你可以翻到第一页，会发现出现上面的错误信息，下面会讲解。"><a href="#如果你可以翻到第一页，会发现出现上面的错误信息，下面会讲解。" class="headerlink" title="如果你可以翻到第一页，会发现出现上面的错误信息，下面会讲解。"></a>如果你可以翻到第一页，会发现出现上面的错误信息，下面会讲解。</h1><h1 id="至于-p的参数，重点在于保留原本文件的权限与属性之意。"><a href="#至于-p的参数，重点在于保留原本文件的权限与属性之意。" class="headerlink" title="至于 -p的参数，重点在于保留原本文件的权限与属性之意。"></a>至于 -p的参数，重点在于保留原本文件的权限与属性之意。</h1><p>[root@www ~]#tar -jpcv -f /root/etc.tar.bz2 /etc</p><h1 id="显示的消息会跟上面一模一样。"><a href="#显示的消息会跟上面一模一样。" class="headerlink" title="显示的消息会跟上面一模一样。"></a>显示的消息会跟上面一模一样。</h1><p>[root@www ~]# ll /root/etc*<br>-rw-r–r–1root root 8740252 Nov 15 23:07 /root/etc.tar.bz2<br>-rw-r–r–1root root 13010999 Nov 15 23:01/root/etc.tar.gz</p><h1 id="为什么建议你使用-j-这个参数？从上面的数值你可以知道了吧？"><a href="#为什么建议你使用-j-这个参数？从上面的数值你可以知道了吧？" class="headerlink" title="为什么建议你使用 -j 这个参数？从上面的数值你可以知道了吧？"></a>为什么建议你使用 -j 这个参数？从上面的数值你可以知道了吧？</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 使用 tar 文件的数据内容（可查看文件名），与备份文件名有否根目录的意义</span><br></pre></td></tr></table></figure><p>[root@www ~]#tar -jtv -f /root/etc.tar.bz2<br>….前面省略….<br>-rw-r–r– root/root 1016 2008-05-25 14:06:20 etc/dbus-1/session.conf<br>-rw-r–r– root/root 153 2007-01-07 19:20:54 etc/esd.conf<br>-rw-r–r– root/root 255 2007-01-06 21:13:33 etc/crontab<br>如果加上-v 这个参数时，详细的文件权限/属性都会被列出来。<br>如果只是想要知道文件名而已，那么就将-v去掉即可。<br>从上面的数据我们可以发现一件很有趣的事情，那就是每个文件名都没了根目录了。<br>这也是上一个练习中出现的那个警告信息“tar:Removing leading <code>/&#39; from member names（删除了文件名开头的</code>/‘）”所告知的情况。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">去掉根目录的原因主要是为了安全。我们使用tar备份的数据可能会需要解压缩回来使用，在 tar 所记录的文件名（就是我们刚才使用 tar -jtvf 所查看到的文件名）那就是解压缩后的实际文件名。如果去掉了根目录，假设你将备份数据在/tmp 中解开，那么解压缩的文件名就会变成“/tmp/etc/xxx”。但如果没有去掉根目录，解压缩后的文件名就会是绝对路径，即解压缩后的数据一定会被放置到/etc/xxx去。如此一来，你的原本的/etc/下面的数据就会被备份数据所覆盖过去了。</span><br><span class="line"></span><br><span class="line">- 将文件名中的根目录也备份下来，并查看以下内分文件内容文件名</span><br></pre></td></tr></table></figure></p><p>[root@www ~]#tar -jpPcv -f /root/etc.and.root.tar.bz2 /etc<br>….中间过程省略….<br>[root@www ~]#tar -jtf /root/etc.and.root.tar.bz2<br>/etc/dbus-1/session.conf<br>/etc/esd.conf<br>/etc/esd.conf<br>/etc/crontab</p><h1 id="这次查阅文件名不含-v-参数，所以仅有文件名而已，没有详细属性-权限等参数。"><a href="#这次查阅文件名不含-v-参数，所以仅有文件名而已，没有详细属性-权限等参数。" class="headerlink" title="这次查阅文件名不含 -v 参数，所以仅有文件名而已，没有详细属性/权限等参数。"></a>这次查阅文件名不含 -v 参数，所以仅有文件名而已，没有详细属性/权限等参数。</h1><p>有发现不同点了吧？如果加上-P 参数，那么文件名内的根目录就会存在。不过，个人建议，还是不要加上-P 这个参数来备份。毕竟很多时候，我们备份是为了要未来追踪问题用的，倒不一定需要还原回原本的系统中。所以拿去根目录后，备份数据的应用会比较有弹性，也比较安全。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 使用 tar 解打包</span><br></pre></td></tr></table></figure></p><p>[root@www ~]#tar-jxv -f /root/etc.tar.bz2<br>[root@www ~]# ll<br>….（前面省略）….<br>drwxr-xr-x 105 root root 12288 Nov 1104:02 etc<br>….（后面省略）….<br>此时该打包文件会在本目录下进行解压缩的操作。所以，你等一下就会在主文件夹下面发现一个名为 etc 的目录<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">如果想在 /tmp 文件夹下解开这个打包文件，当然可以 `cd/tmp` 但是有一种更简单的方法在指定路径下解压</span><br><span class="line"></span><br><span class="line">- 使用 -C 在指定路径下解压缩</span><br></pre></td></tr></table></figure></p><p>[root@www ~]#tar -jxv -f /root/etc.tar.bz2 -C /tmp<br>[root@www ~]# ll /tmp<br>….（前面省略）….<br>drwxr-xr-x 105 root root 12288 Nov 1104:02 etc<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">- 仅解开单一文件</span><br></pre></td></tr></table></figure></p><h1 id="1-先找到我们要的文件名，假设解开-shadow-文件好了："><a href="#1-先找到我们要的文件名，假设解开-shadow-文件好了：" class="headerlink" title="1. 先找到我们要的文件名，假设解开 shadow 文件好了："></a>1. 先找到我们要的文件名，假设解开 shadow 文件好了：</h1><p>[root@www ~]#tar -jtv -f /root/etc.tar.bz2 |grep’shadow’<br>-r——– root/root 1230 2008-09-29 02:21:20 etc/shadow-<br>-r——– root/root 622 2008-09-29 02:21:20 etc/gshadow-<br>-r——– root/root 636 2008-09-29 02:21:25 etc/gshadow<br>-r——– root/root 1257 2008-09-29 02:21:25 etc/shadow &lt;==这是我们要的。</p><h1 id="先找出重要的文件名。其中那个grep是“选取”关键字的功能。"><a href="#先找出重要的文件名。其中那个grep是“选取”关键字的功能。" class="headerlink" title="先找出重要的文件名。其中那个grep是“选取”关键字的功能。"></a>先找出重要的文件名。其中那个grep是“选取”关键字的功能。</h1><h1 id="2-将该文件解开。语法与实际方法如下："><a href="#2-将该文件解开。语法与实际方法如下：" class="headerlink" title="2. 将该文件解开。语法与实际方法如下："></a>2. 将该文件解开。语法与实际方法如下：</h1><p>[root@www ~]#tar -jxv -f 打包文件.tar.bz2 待解开文件名<br>[root@www ~]#tar -jxv -f /root/etc.tar.bz2 etc/shadow<br>etc/shadow<br>[root@www ~]# ll etc<br>total 8<br>-r——–1root root 1257 Sep29 02:21shadow &lt;==只有一个文件。</p><p>#此时只会解开一个文件而已。不过，重点是那个文件名。你要找到正确的文件名。</p><h1 id="在本例中，你不能写成-etc-shadow-，因为它是记录在-etc-tar-bz2-内的文件名。"><a href="#在本例中，你不能写成-etc-shadow-，因为它是记录在-etc-tar-bz2-内的文件名。" class="headerlink" title="在本例中，你不能写成 /etc/shadow ，因为它是记录在 etc.tar.bz2 内的文件名。"></a>在本例中，你不能写成 /etc/shadow ，因为它是记录在 etc.tar.bz2 内的文件名。</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 打包某目录但不包含该目录下的某些文件做法 --exclude</span><br></pre></td></tr></table></figure><p>[root@www ~]#tar -jcv -f /root/system.tar.bz2 –exclude=/root/etc*  –exclude=/root/system.tar.bz2 /etc/root<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">上面这个例子在打包的时候，将/root/etc* 和本身排除在外进行打包</span><br><span class="line"></span><br><span class="line">- 仅备份比某个时刻还要新的文件 --newer-mtime --newer</span><br><span class="line"></span><br><span class="line">其中 --newer 表示后续的日期包含 mtime（文件内容更改时间）与ctime（文件站状态如权限与属性更改时间），--newer-mtime 只包含 mtime</span><br></pre></td></tr></table></figure></p><p>[root@www ~]#tar-jcv -f /root/etc.newer.then.passwd.tar.bz2  –newer-mtime=”2008/09/29” /etc/*<br>….（中间省略）….<br>/etc/smartd.conf &lt;==真的有备份的文件<br>….（中间省略）….<br>/etc/yum.repos.d/ &lt;==目录都会被记录下来<br>tar: /etc/yum.repos.d/CentOS-Base.repo: file iSunchanged; not dumped</p><h1 id="最后一行显示的是“没有被备份的”，也即-not-dumped-的意思。"><a href="#最后一行显示的是“没有被备份的”，也即-not-dumped-的意思。" class="headerlink" title="最后一行显示的是“没有被备份的”，也即 not dumped 的意思。"></a>最后一行显示的是“没有被备份的”，也即 not dumped 的意思。</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">范例中的仅仅把 /etc/ 文件下,文件内容更改时间 mtime 比 2008/09/29 新的文件进行打包。这个命令是一个对差异文件备份特别方便的命令。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- 基本名称 tarfile tarball</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">tar 打包出来的文件有没有进行压缩所得到的文件称谓的不同。如果只是打包而已，就是 `tar -cv -f file.tar` 而已，这个文件称之为 tarfile。如果还有压缩支持 `tar -jcv -f file.tar.bz2` 即使用 gZip 或 bZip2 进行压缩压缩，称呼为 tarball。当然，这就是一个基本称谓而已。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">此外，tar 除了可以将数据打包成为文件之外，还能够将文件打包到某些特别的设备去，举例来说，磁带机（tape）就是一个常见的例子。磁带机由于是一次性读取/写入的设备，因此我们不能够使用类似 cp 等命令来复制的。那如果想要将/home, /root, /etc 备份到磁带机（/dev/st0）时，就可以使用“tar -cv -f /dev/st0 /home /root /etc”，很简单容易吧？磁带机用在备份（尤其是企业应用）是很常见的工作。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- tar 特殊应用 **利用管道命令与数据流**</span><br><span class="line"></span><br><span class="line">在 tar 的使用中，有一种方式最特殊，那就是通过标准输入输出的数据流重定向（standard input/standard output），以及管道命令（pipe）的方式，将待处理的**文件一边打包一边解压缩到目标目录去**。下面是范例</span><br></pre></td></tr></table></figure><h1 id="将-etc-整个目录一边打包一边在-tmp中解开"><a href="#将-etc-整个目录一边打包一边在-tmp中解开" class="headerlink" title="将 /etc 整个目录一边打包一边在 /tmp中解开"></a>将 /etc 整个目录一边打包一边在 /tmp中解开</h1><p>[root@www ~]#cd /tmp<br>[root@www ~]#tar -cvf - /etc |tar-xvf -</p><h1 id="这个操作有点像是cp-r-etc-tmp依旧是有其有用途的。"><a href="#这个操作有点像是cp-r-etc-tmp依旧是有其有用途的。" class="headerlink" title="这个操作有点像是cp -r /etc /tmp依旧是有其有用途的。"></a>这个操作有点像是cp -r /etc /tmp依旧是有其有用途的。</h1><h1 id="要注意的地方在于输出文件变成-而输入文件也变成-，又有一个-存在。"><a href="#要注意的地方在于输出文件变成-而输入文件也变成-，又有一个-存在。" class="headerlink" title="要注意的地方在于输出文件变成 - 而输入文件也变成 - ，又有一个 | 存在。"></a>要注意的地方在于输出文件变成 - 而输入文件也变成 - ，又有一个 | 存在。</h1><h1 id="这分别代表-standard-output-standard-input-与管道命令。"><a href="#这分别代表-standard-output-standard-input-与管道命令。" class="headerlink" title="这分别代表 standard output, standard input 与管道命令。"></a>这分别代表 standard output, standard input 与管道命令。</h1><h1 id="简单的想法中，你可以将-想成是在内存中的一个设备（缓冲区）。"><a href="#简单的想法中，你可以将-想成是在内存中的一个设备（缓冲区）。" class="headerlink" title="简单的想法中，你可以将 - 想成是在内存中的一个设备（缓冲区）。"></a>简单的想法中，你可以将 - 想成是在内存中的一个设备（缓冲区）。</h1><h1 id="在当前目录下-ll-你会发现，目录下会直接出现-解压后的-etc"><a href="#在当前目录下-ll-你会发现，目录下会直接出现-解压后的-etc" class="headerlink" title="在当前目录下 ll 你会发现，目录下会直接出现 解压后的 etc/"></a>在当前目录下 ll 你会发现，目录下会直接出现 解压后的 etc/</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">上面的例子中，想要将 /etc 下面的数据直接复制到目前路径下 /tmp，但是又觉得直接复制 cp -r /etc /tmp 有点麻烦，那么就直接以这个方式来打包，其中，命令里面的 - 就是表示那个被打包的文件。由于我们不想让那个中间文件存在，所以就用这个方式来进行复制行为。</span><br><span class="line"></span><br><span class="line">- 系统备份范例</span><br><span class="line"></span><br><span class="line">系统上有非常多的重要目录需要进行备份，而且其实我们也不建议你将备份数据放置到/root目录下。假设目前你已经知道重要的目录有下面这几个：</span><br><span class="line">/etc/（配置文件）</span><br><span class="line">/home/（用户的主文件夹）</span><br><span class="line">/var/spool/mail/（系统中，所有账号的邮件信箱）</span><br><span class="line">/var/spool/cron/（所有账号的工作调度配置文件）</span><br><span class="line">/root（系统管理员的主文件夹）</span><br><span class="line">/home/loop*不需要备份，而且/root下面的压缩文件也不需要备份，另外假设你要将备份的数据放置到/backups，并且该目录仅有 root 有权限进入。此外，每次备份的文件名都希望不相同，例如使用backup-system-20171011.tar.bz2 之类的文件名来处理。那你该如何处理这个备份数据呢？（请先动手操作试试，再来查看一下下面的参考解答。）</span><br></pre></td></tr></table></figure><p>#1. 先处理要放置备份数据的目录与权限：<br>[root@www ~]# mkdir /backups<br>[root@www ~]#chmod 700 /backups<br>[root@www ~]# ll -d /backups<br>drwx—— 2 root root 4096 Nov 30 16:35 /backups</p><h1 id="2-假设今天是-2017-10-11-，则新建备份的方式如下："><a href="#2-假设今天是-2017-10-11-，则新建备份的方式如下：" class="headerlink" title="2. 假设今天是 2017/10/11 ，则新建备份的方式如下："></a>2. 假设今天是 2017/10/11 ，则新建备份的方式如下：</h1><p>[root@www ~]#tar -jcv -f /backups/backup-system-20171011.tar.bz2 \</p><blockquote><p>–exclude=/root/<em>.bz2 –exclude=/root/</em>.gz –exclude=/home/loop* \<br>/etc /home /var/spool/mail /var/spool/cron /root<br>…. 这是一个超级漫长的过程….<br>[root@www ~]# ll -h /backups/<br>-rw-r–r–1root root 8.4M Nov 30 16:43 backup-system-20091130.tar.bz2<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;h2 id=&quot;4&quot;&gt;4. 完整备份工具：dump&lt;/h2&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">某些夜黑人静的夜晚，你想要针对文件系统进行备份或者存储功能时，不能不谈到这个 dump 命令。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;h3 id=&quot;4.1&quot;&gt;4.1 dump&lt;/h3&gt;</span><br><span class="line"></span><br><span class="line">假设你的 /home 是独立的一个文件系统，那你第一次进行过dump后，再进行第二次dump时，你可以指定不同的备份等级，假如指定等级为1时，此时新备份的数据只会记录与第一次备份所有差异的文件而已。</span><br><span class="line">比如，第一次备份时使用的是 level 0，这个等级也是完整的备份。等到第二次备份时，实时文件系统内的数据已经与 level 0 不一样了，而level1 仅只是比较目前的文件系统与 level 0 之间的差异后，备份有变化过的文件而已。至于 level 2则是与 level 1 进行比较。</span><br><span class="line"></span><br><span class="line">- dump 对单一文件备份的限制</span><br><span class="line"></span><br><span class="line">`dump` 支持对整个文件系统或者是单一目录，但是**对单一目录的支持比较不足**，废话要不然还要 `tar`干啥。</span><br><span class="line">如果是单一文件系统，那么该文件系统可以使用完整的dump功能，包括利用0~9的数个level来备份，同时，备份时可以使用挂载点或者是设备文件名（例如/dev/sda5 之类的设备文件名）来进行备份。 但如果带备份数据只是目录，并非单一文件系统就包括以下限制</span><br><span class="line"></span><br><span class="line">&gt; 所有的备份数据都必须要在该目录（本例为/home/someone/）下面；</span><br><span class="line">&gt;且仅能使用 level 0，即仅支持完整备份而已；</span><br><span class="line">&gt;不支持-u参数，即无法创建/etc/dumpdates这个level备份的时间记录文件。</span><br><span class="line">&gt;dump 的参数虽然非常繁杂，不过如果只是想要简单的操作时，你只要记得下面的几个参数就很够用了。</span><br><span class="line"></span><br><span class="line">- dump 简单操作</span><br></pre></td></tr></table></figure></p></blockquote><p>[root@www ~]# dump [-Suvj] [-level] [-f 备份文件] 待备份数据<br>[root@www ~]# dump -W<br>参数：<br>-S ：仅列出后面的待备份数据需要多少磁盘空间才能够备份完毕；<br>-u ：将这次 dump的时间记录到 /etc/dumpdateS文件中；<br>-v ：将 dump的文件过程显示出来；<br>-j ：加入bzip2的支持，将数据进行压缩，默认bzip2压缩等级为 2；<br>-level：就是我们谈到的等级，从 -0 ~ -9 共10个等级；<br>-f ：有点类似tar，后面接产生的文件，可接例如 /dev/st0 设备文件名等；<br>-W ：列出在 /etc/fstab 里面的具有 dump设置的分区是否有备份过。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 用 dump 备份完整的文件系统</span><br></pre></td></tr></table></figure></p><h1 id="1-先找出系统中最小的那个文件系统，如下所示："><a href="#1-先找出系统中最小的那个文件系统，如下所示：" class="headerlink" title="1. 先找出系统中最小的那个文件系统，如下所示："></a>1. 先找出系统中最小的那个文件系统，如下所示：</h1><p>[root@www ~]# df -h<br>Filesystem Size Used Avail Use% Mounted on<br>/dev/hdc2 9.5G 3.7G 5.3G 42% /<br>/dev/hdc3 4.8G 651M 3.9G 15% /home<br>/dev/hdc1 99M 11M 83M 12% /boot &lt;==看起来最小的就是它。<br>tmpfS 363M 0 363M 0% /dev/shm</p><h1 id="2-先测试一下如果要备份此文件系统需多少容量"><a href="#2-先测试一下如果要备份此文件系统需多少容量" class="headerlink" title="2. 先测试一下如果要备份此文件系统需多少容量"></a>2. 先测试一下如果要备份此文件系统需多少容量</h1><p>[root@www ~]# dump -S/dev/hdc1<br>5630976 &lt;==注意一下，这个单位是 byte，所以差不多是 5.6MB。</p><h1 id="3-将完整备份的文件名记录成为-root-boot-dump，同时更新记录文件："><a href="#3-将完整备份的文件名记录成为-root-boot-dump，同时更新记录文件：" class="headerlink" title="3. 将完整备份的文件名记录成为 /root/boot.dump，同时更新记录文件："></a>3. 将完整备份的文件名记录成为 /root/boot.dump，同时更新记录文件：</h1><p>[root@www ~]# dump -0u -f /root/boot.dump/boot<br>DUMP: Date of thiSlevel0dump: Tue Dec 2 02:53:45 2008&lt;==记录等级与备份时间<br>DUMP: Dumping /dev/hdc1（/boot）to /root/boot.dump &lt;==dump的源与目标<br>DUMP: Label: /boot &lt;==文件系统的 label<br>DUMP: Writing 10 Kilobyte records<br>DUMP: mapping（PasSI）[regular files] &lt;==开始进行文件对应<br>DUMP: mapping（PasSII）[directories]<br>DUMP: estimated 5499 blocks. &lt;==评估整体block数量<br>DUMP: Volume1started with block1at: Tue Dec 2 02:53:46 2008<br>DUMP: dumping（PasSIII）[directories] &lt;==开始 dump工作<br>DUMP: dumping（PasSIV）[regular files]<br>DUMP:Closing /root/boot.dump &lt;==结束写入备份文件<br>DUMP: Volume1completed at: Tue Dec 2 02:53:47 2008<br>DUMP: Volume15550 blockS（5.42MB） &lt;==最终备份数据容量<br>DUMP: Volume1took 0:00:01<br>DUMP: Volume1transfer rate: 5550 kB/s<br>DUMP: 5550 blockS（5.42MB）on1volume（s）<br>DUMP: finished in1seconds, throughput 5550 kBytes/sec<br>DUMP: Date of thiSlevel0dump: Tue Dec 2 02:53:45 2008<br>DUMP: Date thiSdumpCompleted: Tue Dec 2 02:53:47 2008<br>DUMP: Average transfer rate: 5550 kB/s<br>DUMP: DUMPISDONE</p><h1 id="在命令的执行方面，dump后面接-boot-或-dev-hdc1都可以的。"><a href="#在命令的执行方面，dump后面接-boot-或-dev-hdc1都可以的。" class="headerlink" title="在命令的执行方面，dump后面接 /boot 或 /dev/hdc1都可以的。"></a>在命令的执行方面，dump后面接 /boot 或 /dev/hdc1都可以的。</h1><h1 id="而执行-dump的过程中会出现如上的一些信息，你可以自行仔细查看。"><a href="#而执行-dump的过程中会出现如上的一些信息，你可以自行仔细查看。" class="headerlink" title="而执行 dump的过程中会出现如上的一些信息，你可以自行仔细查看。"></a>而执行 dump的过程中会出现如上的一些信息，你可以自行仔细查看。</h1><p>[root@www ~]# ll /root/boot.dump/etc/dumpdates<br>-rw-rw-r–1root disk 43 Dec 2 02:53 /etc/dumpdates<br>-rw-r–r–1root root 5683200 Dec 2 02:53 /root/boot.dump</p><h1 id="由于加上-u-的选项，因此-etc-dumpdates文件的内容会被更新。注意，"><a href="#由于加上-u-的选项，因此-etc-dumpdates文件的内容会被更新。注意，" class="headerlink" title="由于加上 -u 的选项，因此 /etc/dumpdates文件的内容会被更新。注意，"></a>由于加上 -u 的选项，因此 /etc/dumpdates文件的内容会被更新。注意，</h1><h1 id="这个文件仅有在-dump完整的文件系统时才有支持自动更新的功能。"><a href="#这个文件仅有在-dump完整的文件系统时才有支持自动更新的功能。" class="headerlink" title="这个文件仅有在 dump完整的文件系统时才有支持自动更新的功能。"></a>这个文件仅有在 dump完整的文件系统时才有支持自动更新的功能。</h1><h1 id="4-查看一下系统自动新建的记录文件："><a href="#4-查看一下系统自动新建的记录文件：" class="headerlink" title="4. 查看一下系统自动新建的记录文件："></a>4. 查看一下系统自动新建的记录文件：</h1><p>[root@www ~]#cat /etc/dumpdates<br>/dev/hdc1 0 Tue Dec 2 02:53:47 2008 +0800<br>[文件系统] [等级] [ Ctime 的时间 ]</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">这样就很简单的新建了/root/boot.dump 文件。该文件将整个 /boot 文件系统都备份下来，并且将备份时间写入 /etc/dumpdates 文件中，准备让下次备份时可以做一个参考依据。</span><br><span class="line"></span><br><span class="line">- 新建 level 1 备份</span><br></pre></td></tr></table></figure><h1 id="1-看一下有没有任何文件系统被-dump过的数据"><a href="#1-看一下有没有任何文件系统被-dump过的数据" class="headerlink" title="1. 看一下有没有任何文件系统被 dump过的数据"></a>1. 看一下有没有任何文件系统被 dump过的数据</h1><p>[root@www ~]# dump -W<br>Last dump（s）done（Dump’&gt;’ file systems）:</p><blockquote><p>/dev/hdc2 （ /）Last dump: never<br>/dev/hdc3 （ /home）Last dump: never<br>/dev/hdc1 （ /boot）Last dump: Level 0, Date Tue Dec 2 02:53:47 2008</p><h1 id="如上面的结果，该结果会找出-etc-fstab-里面第五字段设置有需要-dump的"><a href="#如上面的结果，该结果会找出-etc-fstab-里面第五字段设置有需要-dump的" class="headerlink" title="如上面的结果，该结果会找出 /etc/fstab 里面第五字段设置有需要 dump的"></a>如上面的结果，该结果会找出 /etc/fstab 里面第五字段设置有需要 dump的</h1><h1 id="分区，然后与-etc-dumpdateS进行比对，可以得到上面的结果。"><a href="#分区，然后与-etc-dumpdateS进行比对，可以得到上面的结果。" class="headerlink" title="分区，然后与 /etc/dumpdateS进行比对，可以得到上面的结果。"></a>分区，然后与 /etc/dumpdateS进行比对，可以得到上面的结果。</h1><h1 id="尤其是第三行，可以显示我们曾经对-dev-hdc1进行过-dump的备份操作。"><a href="#尤其是第三行，可以显示我们曾经对-dev-hdc1进行过-dump的备份操作。" class="headerlink" title="尤其是第三行，可以显示我们曾经对 /dev/hdc1进行过 dump的备份操作。"></a>尤其是第三行，可以显示我们曾经对 /dev/hdc1进行过 dump的备份操作。</h1><h1 id="2-先恶搞一下，新建一个大约-10-MB-的文件在-boot-内："><a href="#2-先恶搞一下，新建一个大约-10-MB-的文件在-boot-内：" class="headerlink" title="2. 先恶搞一下，新建一个大约 10 MB 的文件在 /boot 内："></a>2. 先恶搞一下，新建一个大约 10 MB 的文件在 /boot 内：</h1><p>[root@www ~]#dd if=/dev/zero of=/boot/testing.img bs=1MCount=10<br>10+0 recordSin<br>10+0 recordSout<br>10485760 byteS（10 MB）Copied, 0.166128 seconds, 63.1MB/s</p><h1 id="3-开始新建差异备份文件，此时我们使用-level-1吧："><a href="#3-开始新建差异备份文件，此时我们使用-level-1吧：" class="headerlink" title="3. 开始新建差异备份文件，此时我们使用 level 1吧："></a>3. 开始新建差异备份文件，此时我们使用 level 1吧：</h1><p>[root@www ~]# dump -1u -f /root/boot.dump.1/boot<br>….（中间省略）….<br>[root@www ~]# ll /root/boot*<br>-rw-r–r–1root root 5683200 Dec 2 02:53 /root/boot.dump<br>-rw-r–r–1root root 10547200 Dec 2 02:56 /root/boot.dump.1</p><h1 id="看看文件大小，岂不是就是刚才我们所新建的那个大文件的大小吗？"><a href="#看看文件大小，岂不是就是刚才我们所新建的那个大文件的大小吗？" class="headerlink" title="看看文件大小，岂不是就是刚才我们所新建的那个大文件的大小吗？"></a>看看文件大小，岂不是就是刚才我们所新建的那个大文件的大小吗？</h1><h1 id="4-最后再看一下是否有记录-level-1备份的时间点呢？"><a href="#4-最后再看一下是否有记录-level-1备份的时间点呢？" class="headerlink" title="4. 最后再看一下是否有记录 level 1备份的时间点呢？"></a>4. 最后再看一下是否有记录 level 1备份的时间点呢？</h1><p>[root@www ~]# dump -W<br>Last dump（s）done（Dump’&gt;’ file systems）:<br>/dev/hdc2 （ /）Last dump: never<br>/dev/hdc3 （ /home）Last dump: never<br>/dev/hdc1 （ /boot）Last dump: Level 1, Date Tue Dec 2 02:56:33 2008<br>….（中间省略）….<br>通过这个简单的方式，我们就能够仅备份差异文件的部分了。下面再来看看针对单一目录的dump用途。<br>用dump备份非文件系统，即单一目录的方法<br>现在让我们来处理一下/etc的dump备份。因为/etc并非单一文件系统，它只是个目录而已。所以依据限制的说明，-u evel 1~9 都是不适用的。我们只能够使用 level 0 的完整备份将/etcdump 下来，因此就变得很简单了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- dump 备份单一目录</span><br></pre></td></tr></table></figure></p></blockquote><p>#让我们将 /etc 整个目录通过 dump进行备份，且含压缩功能<br>[root@www ~]# dump -0j -f /root/etc.dump.bz2 /etc<br>DUMP: Date of thiSlevel0dump: Tue Dec 2 12:08:22 2008<br>DUMP: Dumping /dev/hdc2（/（dir etc））to /root/etc.dump.bz2<br>DUMP: Label: /1<br>DUMP: Writing 10 Kilobyte records<br>DUMP:Compressing output atCompression level 2（bzlib）<br>DUMP: mapping（PasSI）[regular files]<br>DUMP: mapping（PasSII）[directories]<br>DUMP: estimated 115343 blocks.<br>DUMP: Volume1started with block1at: Tue Dec 2 12:08:23 2008<br>DUMP: dumping（PasSIII）[directories]<br>DUMP: dumping（PasSIV）[regular files]<br>DUMP:Closing /root/etc.dump.bz2<br>DUMP: Volume1completed at: Tue Dec 2 12:09:49 2008<br>DUMP: Volume1took 0:01:26<br>DUMP: Volume1transfer rate: 218 kB/s<br>DUMP: Volume1124680kB uncompressed, 18752kBCompressed, 6.649…</p><h1 id="上面特殊字体的部分显示：原本有-124680KB-的容量，被压缩成为-18752KB，"><a href="#上面特殊字体的部分显示：原本有-124680KB-的容量，被压缩成为-18752KB，" class="headerlink" title="上面特殊字体的部分显示：原本有 124680KB 的容量，被压缩成为 18752KB，"></a>上面特殊字体的部分显示：原本有 124680KB 的容量，被压缩成为 18752KB，</h1><h1 id="整个压缩比为-6-649-1，还可以。"><a href="#整个压缩比为-6-649-1，还可以。" class="headerlink" title="整个压缩比为 6.649:1，还可以。"></a>整个压缩比为 6.649:1，还可以。</h1><p>一般来说dump不会使用包含压缩的功能，不过如果你想要将备份的空间降低的话，那个-j的参数是可以使用的。加上-j之后你的dump结果会使用较少的硬盘空间。如上述的情况来看，文件大小由原本的128MB左右下滑到18MB左右，当然可以节省备份空间。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;h3 id=&quot;4.2&quot;&gt;4.3 restore&lt;/h3&gt;</span><br><span class="line"></span><br><span class="line">备份文件就是在急用时可以恢复系统的重要数据。所以有备份当然要学习如何恢复。dump 的恢复使用的就是 restore 这个命令。它的参数相当多，可以自行 man restore,下面仅是一个简单的介绍。</span><br></pre></td></tr></table></figure></p><p>[root@www ~]# restore -t [-f dumpfile] [-h] &lt;==用来查看 dump文件<br>[root@www ~]# restore -C [-f dumpfile] [-D挂载点] &lt;==比较dump与实际文件<br>[root@www ~]# restore -i [-f dumpfile] &lt;==进入互动模式<br>[root@www ~]# restore -r [-f dumpfile] &lt;==还原整个文件系统<br>参数：<br>相关的各种模式，各种模式无法混用。例如不可以写 -tC 。<br>-t ：此模式用在查看 dump起来的备份文件中含有什么重要数据。类似tar-t 功能。<br>-C ：此模式可以将 dump内的数据拿出来跟实际的文件系统做比较，<br>最终会列出“在 dump文件内有记录的，且目前文件系统不一样”的文件。<br>-i ：进入互动模式，可以仅还原部分文件，用在 dump目录时的还原。<br>-r ：将整个文件系统还原的一种模式，用在还原针对文件系统的 dump备份。<br>其他较常用到的参数功能：<br>-h ：查看完整备份数据中的 inode 与文件系统 label 等信息。<br>-f ：后面就接你要处理的那个 dump文件。<br>-D ：与 -C 进行搭配，可以查出后面接的挂载点与 dump内有不同的文件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 使用 restore -t 查阅 dump 内容</span><br></pre></td></tr></table></figure></p><p>[root@www ~]# restore -t -f /root/boot.dump<br>Dump date: Tue Dec 2 02:53:45 2008 &lt;==说明备份的日期<br>Dumped from: the epoch<br>Level0dumpof /boot on www.vbird.tsai:/dev/hdc1 &lt;==说明 level 状态<br>Label: /boot &lt;==说明该文件系统的表头。<br>2 .<br>11 ./lost+found<br>2009 ./grub<br>2011 ./grub/grub.conf<br>….下面省略….<br>[root@www ~]# restore -t -f /root/etc.dump<br>Dumptape isCompressed. &lt;==加注说明数据有压缩<br>Dump date: Tue Dec 2 12:08:22 2008<br>Dumped from: the epoch<br>Level0dumpof /（dir etc）on ubuntu:/dev/hdc2 &lt;==是目录。<br>Label: /1<br>2 .<br>1912545 ./etc<br>1912549 ./etc/rpm<br>1912550 ./etc/rpm/platform<br>….下面省略….<br>这个查阅的数据其实显示出的是文件名与原文件的inode状态，所以我们可以说，dump会参考inode的记录。通过这个查询我们也能知道dump的内容为何<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 比较差异并且还原整个文件系统</span><br><span class="line"></span><br><span class="line">dump 可以进行累计备份，是因为它具有可以查询文件系统与备份文件之间的差异，并且将分析到的差异数据进行备份的缘故。</span><br></pre></td></tr></table></figure></p><h1 id="1-先尝试更改文件系统的内容："><a href="#1-先尝试更改文件系统的内容：" class="headerlink" title="1. 先尝试更改文件系统的内容："></a>1. 先尝试更改文件系统的内容：</h1><p>[root@www ~]#cd /boot<br>[root@www boot]# mvConfig-2.6.18-128.el5Config-2.6.18-128.el5-back</p><h1 id="2-看看查询文件系统与备份文件之间的差异。"><a href="#2-看看查询文件系统与备份文件之间的差异。" class="headerlink" title="2. 看看查询文件系统与备份文件之间的差异。"></a>2. 看看查询文件系统与备份文件之间的差异。</h1><p>[root@www boot]# restore -C -f /root/boot.dump<br>Dump date: Tue Dec 2 02:53:45 2008<br>Dumped from: the epoch<br>Level0dumpof /boot on ubuntu:/dev/hdc1<br>Label: /boot<br>filesys= /boot<br>restore: unable to stat ./config-2.6.18-128.el5: No such file or directory Some fileSwere modified!<br>1compare errors</p><h1 id="看到上面的特殊字体了吧。那就是有差异的部分。总共有一个文件被更改。"><a href="#看到上面的特殊字体了吧。那就是有差异的部分。总共有一个文件被更改。" class="headerlink" title="看到上面的特殊字体了吧。那就是有差异的部分。总共有一个文件被更改。"></a>看到上面的特殊字体了吧。那就是有差异的部分。总共有一个文件被更改。</h1><p>```</p><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><p>整理笔记参考了 <a href="http://linux.vbird.org/linux_basic/0210filepermission.php#filepermission_perm" target="_blank" rel="noopener">《鸟哥的Linux私房菜》</a> 一书。这本书我是买的<a href="http://sale.jd.com/act/W5hugLDc1R.html" target="_blank" rel="noopener">京东阅读</a>的正版电子书籍。<br><br>如果不想买书看的话可以直接戳<a href="http://linux.vbird.org/" target="_blank" rel="noopener">这里进入鸟哥Linux私房菜的线上博客 : http://linux.vbird.org/</a>。请大家支持正版！！<br><br>至于笔记中的命令我是都敲过一遍的并进行了理解，并不是单纯的复制粘贴呦！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; class=&quot;headerlink&quot; title=&quot;目录&quot;&gt;&lt;/a&gt;目录&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#0&quot;&gt;前言&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#1&quot;&gt;1.压缩文件的用途与技术&lt;/a&gt;&lt;/li&gt;

      
    
    </summary>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux的文件权限与目录配置</title>
    <link href="http://yoursite.com/2017/12/11/Linux%E7%9A%84%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90%E4%B8%8E%E7%9B%AE%E5%BD%95%E9%85%8D%E7%BD%AE/"/>
    <id>http://yoursite.com/2017/12/11/Linux的文件权限与目录配置/</id>
    <published>2017-12-11T10:58:47.000Z</published>
    <updated>2017-12-11T11:37:30.963Z</updated>
    
    <content type="html"><![CDATA[<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li><a href="#1">1. Linux文件权限</a><ul><li><a href="#1.1">1.1 用户与用户组</a></li><li><a href="#1.2">1.2 Linux文件权限概念</a></li></ul></li><li><a href="#2">2. Linux目录配置</a><ul><li><a href="#2.1">2.1 Linux目录配置</a></li></ul></li></ul><h2 id="1">1. Linux文件权限</h2><blockquote><p>Linux最优秀的地方之一，就在于它的<strong>多用户、多任务环境</strong>。而为了让各个用户具有较保密的文件数据，因此文件的权限管理就变得很重要了。Linux一般将文件可存取访问的身份分为 3 个类别，分别是<strong>owner、group、others</strong>，且 3 种身份各有<strong>read、write、execute</strong>等权限。</p></blockquote><h3 id="1.1">1.1 用户与用户组</h3><ul><li>文件所有者（用户）</li></ul><blockquote><p>　由于 Linux 是多用户多、多任务的系统，因此可能常常会有很多人同时在这套主机来进行工作的情况发生，为了考虑每个人的隐私权以及每个热洗好的工作环境，因此 “文件所有者” 的概念就显得<strong>相当重要</strong>。<br><br>　例如当你将你的Email情书转存成文件之后，放在你自己的主文件夹中，你总不希望被其他人看见自己的情书吧？这个时候你就把该文件<strong>设置成只有文件所有者才能查看与修改这个文件的内容</strong>，那么即使其他人知道你有这个相当“有趣”的文件，不过由于<strong>你有设置适当的权限，所以其他人自然也就无法知道该文件的内容</strong>。</p></blockquote><ul><li>用户组</li></ul><blockquote><p>　其实用户组最有用的功能之一，就是当你在团队开发资源的时候。不同团体之间是有竞争性质的，但却要交纳同一份报告。<strong>每组的组员之间必须要能够互相修改对方的数据，但是其他组的组员则不能看到本组自己的文件内容</strong>，此时该如何是好？<br><br>　在Linux下面这样的限制是很简单的，可以<strong>进行简单的文件权限设置，就能限制非自己团队（也即是用户组）的其他人不能够阅览内容，而且也可以让自己的团队成员可以修改你所创建的文件</strong>。同时，如果你自己还有私人隐密的文件，仍然可以设置成让自己的团队成员也看不到我的文件数据。</p></blockquote><p><strong>不过 root 用户（超级用户）可以到达任何他想去的地方哦！</strong></p><ul><li>Linux 用户身份与用户组记录的文件</li></ul><blockquote><p>Linux 系统中，默认所有系统账号与一般身份用户和 root 相关信息都记录在 <strong>/etc/passwd</strong> 这个文件内可以使用 <code>cat</code>命令查看该文件中是否有指定用户。所有用户组名都记录在 <strong>/etc/group</strong> 文件内，同样可以使用 <code>cat</code>查看。个人密码记录在  <strong>/etc/shadow</strong> 文件下（默认只用 root 才可以打开这个文件）。</p></blockquote><h3 id="1.2">1.2 Linux文件权限概念</h3><ul><li>Linux 文件属性</li></ul><p><strong>以 root 身份登录</strong> Linux 执行 <code>ls -al</code>(list命令，显示文件档案相关属性， 常用命令 <code>-l</code>)</p><blockquote><p>[root@www ~]# ls -al<br><br>total 156<br><br>drwxr-x—　4　root　root　4096　Sep　8 14:06 .<br><br>drwxr-xr-x　23　root　root　4096　Sep　8 14:21 ..<br><br>-rw——-　1　root　root　1474　Sep　4 18:27 anaconda-ks.cfg<br><br>-rw——-　1　root　root　199　Sep　8 17:14 .bash_history<br><br>-rw-r–r–　1　root　root　　24　Jan　6　2007 .bash_logout<br><br>-rw-r–r–　1　root　root　191　Jan　6　2007 .bash_profil<br>-rw-r–r–　1　root　root　176　Jan　6　2007 .bashrc<br><br>-rw-r–r–　1　root　root　100　Jan　6　2007 .cshrc<br><br>drwx——　3　root　root　4096　Sep　5 10:37 .gconf　&lt;=范例说明处<br><br>drwx——　2　root　root　4096　Sep　5 14:09 .gconfd`<br><br>-rw-r–r–　1　root　root　42304　Sep　4 18:26 install.log &lt;=范例说明处<br><br>-rw-r–r–　1　root　root　5661　Sep　4 18:25 install.log.syslog<br><br> [1] 　　　[2]　　[３]　[４]　[５]　[　６　　　]　　[７]<br><br>[１权限 ] 　 [２连接]　[３所有者]　　[４用户组]　[５文件容量]　　　[６修改日期]　[７文件名]</p></blockquote><ul><li>第一列权限与文件类型</li></ul><p>仔细看的话，会发现这里共有十个字符</p><blockquote><p>第一个字符代表这个文件是“目录、文件或链接文件等”。<br><br>若是[d]则是目录，例如上面文件名为“.gconf”的第11行。<br><br>若是[-]则是文件，例如上面文件名为“install.log”第5行。<br><br>若是[l]则表示为连接文件（linkfile）。<br><br>若是[b]则表示设备文件里面的可供存储的接口设备。<br><br>若是[c]则表示设备文件里面的串行端口设备，例如键盘、鼠标（一次性读取设备）。<br><br>接下来的字符中，以3个为一组，且<strong>均为“rwx”的3个参数的组合</strong>。<strong>其中[r]代表可读（read）， [w]代表可写（write），[x]代表可执行（execute）。要注意的是，这3个权限的位置不会改变</strong>，<strong>如果没有权限，就会出现减号[-]而已</strong>。</p></blockquote><ul><li>其他列解释</li></ul><blockquote><p>根据每列的名字可以看出个大概，此处省略，大家可以<a href="http://linux.vbird.org/linux_basic/0210filepermission.php#filepermission_perm" target="_blank" rel="noopener">戳这里《看看鸟哥的Linux私房菜》</a>是怎么说的。</p></blockquote><ul><li>改变文件属性与权限</li></ul><blockquote><p><strong>chgrp：改变文件所属用户组</strong>。<br><br>chgrp改变一个文件的用户组真是很简单的，直接以chgrp来改变即可，这个命令就是change group的简称。不过，请记得，要被改变的组名必须要在/etc/group文件内存在才行，否则就会显示错误。<br><br>[root@www ~]# chgrp [-R] dirname/filename …<br><br>选项与参数：<br><br>-R : 进行递归（recursive）的持续更改，也即连同子目录下的所有文件、目录都更新成为这个用户组之意。常常用在更改某一目录内所有的文件情况。<br><br>范例：<br><br>[root@www ~]# chgrp users install.log<br><br>[root@www ~]# ls -l<br><br>-rw-r–r– 1 root users 68495 Jun 25 08:53 install.log</p><p><strong>chown：改变文件所有者</strong>。<br><br>[root@www ~]# chown [-R] 账号名称 文件或目录<br><br>[root@www ~]# chown [-R] 账号名称:组名 文件或目参数：<br>-R : 进行递归（recursive）的持续更改，即连同子目录下的所有文件都更改<br><br>范例：将install.log的所有者改为bin这个账号：<br><br>[root@www ~]# chown bin install.log<br><br>[root@www ~]# ls -l<br><br>-rw-r–r– 1 bin users 68495 Jun 25 08:53 install.log<br><br>范例：将install.log的所有者与用户组改回为root：<br><br>[root@www ~]# chown root:root install.log<br><br>[root@www ~]# ls -l<br><br>-rw-r–r– 1 root root 68495 Jun 25 08:53 install.log</p><p><strong>chmod：改变文件的权改变所属用户组</strong>：<br>文件权限的改变使用的是chmod这个命令，但是权限的设置方法有两种，分别可以使用<strong>数字</strong>或者是<strong>符号</strong>来进行权限的更改。<br><br><em>数字类型改变文件权限</em> :<br><br>Linux文件的基本权限就有9个，分别是owner、group、others三种身份各有自己的read、write、execute权限，先复习一下刚刚上面提到的数据：文件的权限字符为“-rwxrwxrwx”，这 9 个权限是三个三个一组的。其中，我们可以使用数字来代表各个权限，各权限的分数对照表如下：<br><br>r:4<br><br>w:2<br><br>x:1<br><br>每种身份（owner、group、others）各自的三个权限（r、w、x）分数是需要累加的，例如当权限为 [-rwxrwx—]，分数则是：<br><br>owner = rwx = 4+2+1 = 7<br><br>group = rwx = 4+2+1 = 7<br><br>others= — = 0+0+0 = 0<br><br>所以等一下我们设置权限的更改时，该文件的权限数字就是770，更改权限的命令chmod的语法是这样的：<br><br>[root@www ~]# chmod [-R] xyz 文件或目录<br><br>参数：<br><br>xyz : 就是刚刚提到的数字类型的权限属性，为 rwx 属性数值的相加。<br><br>-R : 进行递归（recursive）的持续更改，即连同子目录下的所有文件都会更改<br><br>举例来说，如果要将.bashrc这个文件所有的权限都设置启用，那么就执行<br><br>[root@www ~]# ls -al .bashrc<br><br><strong>-rw-r–r–</strong> 1 root root 395 Jul 4 11:45 .bashrc<br><br>[root@www ~]# chmod 777 .bashrc<br><br>[root@www ~]# ls -al .bashrc<br><br><strong>-rwxrwxrwx</strong> 1 root root 395 Jul 4 11:45 .bashrc<br><br><em>符号类型改变文件权限</em> :<br><br>user（u）：具有可读、可写、可执行的权限；<br><br>group与others（g/o）：具有可读与执行的权限。<br><br>所以就是：<br><br>[root@www ~]# chmod u=rwx,go=rx .bashrc<br><br><strong>注意：那个 u=rwx,go=rx 是连在一起的，中间并没有任何空格</strong>。<br><br>[root@www ~]# ls -al .bashrc<br><br>-rwxr-xr-x 1 root root 395 Jul 4 11:45 .bashrc<br><br><strong>那么假如是“-rwxr-xr”这样的权限呢？可以使用“ chmod u=rwx,g=rx,o=r filename”来设置</strong>。<br>如果我不知道原先的文件属性，而我只想要增加.bashrc这个文件的<strong>每个人均可写入的权限</strong>，那么我就可以使用：<br><br>[root@www ~]# ls -al .bashrc<br>[root@www ~]# chmod <strong>a+w</strong> .bashrc<br><br>[root@www ~]# ls -al .bashrc<br><br>-rwxrwxrwx 1 root root 395 Jul 4 11:45 .bashrc<br><br>而如果是要将权限去掉而不更改其他属性呢？例如要去掉全部人的可执行权限，则：<br><br>[root@www ~]# chmod a-x .bashrc<br><br>[root@www ~]# ls -al .bashrc<br><br>-rw-rw-rw- 1 root root 395 Jul 4 11:45 .bashrc</p></blockquote><ul><li>权限对 文件 的重要性</li></ul><blockquote><p>　<strong>文件是实际含有数据的地方</strong>，包括一般文本文件、数据库内容文件、二进制可执行文件（binary program）等。因此权限对于文件来说，它的意义如下。<br><br>　　　r（read）：可读取此文件的实际内容，如读取文本文件的文字内容等。<br><br>　　　w（write）：可以编辑、新增或者是修改该文件的内容（<strong>但不含删除该文件</strong>）。<br><br>　　　x（eXecute）：该文件具有可以被系统执行的权限。<br><br>　可执行（x）权限，这里必须要小心啦！<strong>因为在 Windows 下面一个文件是否具有执行的能力是通过“扩展名”来判断的，例如.exe，.bat，.com等，但是在Linux下面，我们的文件是否能被执行则是由是否具有“x”这个权限来决定，而跟文件名是没有绝对的关系</strong>。<br><br>　至于最后一个w权限呢？当你对一个文件具有w权限时，你可以具有写入、编辑、新增修改文件的内容的权限，<strong>但并不具备删除该文件本身的权限</strong>。<strong>对于文件的 r、w、x 来说，主要都是针对“文件的内容”而言，与文件名的存在与否没有关系的。因为文件记录的是实际的数据</strong>。</p></blockquote><ul><li>权限对目录的重要性</li></ul><blockquote><p>　文件是存放实际数据的所在，目录主要的内容是记录文件名列表，文件名与目录有强烈的关联。所以如果是针对目录时，那个r、w、x对目录是什么意义呢？<br><br>　　r（read contents in directory）<br>表示具有<strong>读取目录结构列表的权限</strong>，所以当你具有读取（r）一个目录的权限时，表示你可以查询该目录下的文件名数据，<strong>所以你就可以利用ls这个命令将该目录的内容列表显示出来</strong>。<br><br>　　w（modify contents of directory）<br>这个可写入的权限对目录来说是很强大的。因为它表示你具有更改该目录结构列表的权限，也就是下面这些权限：<br><br>　　　　新建新的文件与目录；<br><br>　　　　删除已经存在的文件与目录（<strong>不论该文件的权限为何</strong>）将已存在的文件或<br>目录进行重命名；<br><br>　　　　转移该目录内的文件、目录位置。<br>总之，目录的w权限就与该目录下面的文件名变动有关就对了。<br><br>　　x（access directory）<br>目录的执行权限有啥用途啊？目录只是记录文件名而已，总不能拿来执行吧？没错，目录不可以被执行，<strong>目录的 x 代表的是用户能否进入该目录成为工作目录的用途</strong>，所谓的工作目录（work directory）就是你目前所在的目录。举例来说，当你登录 Linux时，你所在的主文件夹就是你当下的工作目录。而变换目录的命令是<strong>“cd”</strong> (change directory）</p></blockquote><h2 id="2">2. Linux目录配置</h2><blockquote><p>　Linux 发行版本和开发团队或公司实在太多了。如何保证你所接触到的 Linux 目录配置方法和之前学习的 Linux 系统的目录配置一样，这就出现了后来的 Filesystem Hierarchy Standard (FHS)标准的出炉。<br><br>　根据 <a href="http://www.pathname.com/fhs/" target="_blank" rel="noopener">FHS: http://www.pathname.com/fhs/</a>　的官方文件指出，其主要目的是希望让用户可以了解到已安装软件通常放置于那个目录下，所以其希望独立的软件开发商、操作系统制作者以及想要维护系统的用户，都能够遵循FHS的标准。也就是说，FHS的重点在于规范每个特定的目录下应该要放置什么样子的数据而已。这样做好处非常多，因为Linux操作系统就能够在既有的面貌下（目录架构不变）发展出开发者想要的独特风格<br><br>　事实上，FHS是根据过去的经验一直在持续改版的，FHS依据文件系统使用的频繁与否与是否允许用户随意改动，而将目录定义成为四种交互作用的形态</p></blockquote><p><img src="http://p0bl99g4r.bkt.clouddn.com/dir_type.jpg" alt=""></p><blockquote><p>可分享的：可以分享给其他系统挂载使用的目录，所以包括执行文件与用户的邮件等数据，是能够分享给网络上其他主机挂载用的目录。<br><br>不可分享的：自己机器上面运行的设备文件或者是与程序有关的socket文件等，由于仅与自身机器有关，所以当然就不适合分享给其他主机了。<br><br>不变的：有些数据是不会经常变动的，跟随着distribution而不变动。例如函数库、文件说明文件、系统管理员所管理的主机服务配置文件等。<br><br>可变动的：经常改变的数据，例如登录文件、新闻组等。</p></blockquote><h3 id="2.1">2.1 Linux目录配置</h3><ul><li>FHS 目录树架构</li></ul><blockquote><p>FHS 针对目录树架构金鼎移除三层目录下面应该放置什么数据，分别是<br><br>/（root,根目录）：与开机系统有关；<br><br>/usr（UNIX software resource）：与软件安装/执行有关；<br><br>/var（variable）：与系统运作过程有关。</p></blockquote><ul><li>根目录( / ) 的意义与内容</li></ul><blockquote><p>　根目录是整个系统最重要的一个目录，<strong>因为不但所有的目录都是由根目录衍生出来的，同时根目录也与开机、还原、系统修复等操作有关</strong>。由于系统开机时需要特定的开机软件、内核文件、开机所需程序、函数库等文件数据，若系统出现错误时，<strong>根目录也必须要包含有能够修复文件系统的程序才行</strong>。因为根目录是这么重要，所以在FHS的要求方面，其希望根目录不要放在非常大的分区内，因为越大的分区录所在分区就可能会有较多发生错误的机会。<br><br>　因此FHS标准建议：<strong>根目录（/）所在分区应该越小越好</strong>，<strong>且应用程序所安装的软件最好不要与根目录放在同一个分区内，保持根目录越小越好</strong>。如此不但性能较好，根目录所在的文件系统也较不容易发生问题</p></blockquote><p><em>有鉴于上述的说明，因此 FHS 定义出根目录（/）下面应该要有下面这些子目录的存在才好</em><br></p><p><img src="http://p0bl99g4r.bkt.clouddn.com/dir_01.jpg" alt=""></p><p><img src="http://p0bl99g4r.bkt.clouddn.com/dir_02.jpg" alt=""></p><p><em>FHS 针对根目录所定义的标准金上面图片中举例数据，不过 Linux 下面还有许多目录也需要了解，下面是几个在 Linux 当中也是非常重要的目录</em></p><p><img src="http://p0bl99g4r.bkt.clouddn.com/dir_03.jpg" alt=""></p><ul><li>不可与根目录分开的目录</li></ul><blockquote><p>　因为根目录与开机有关，开机过程中仅有根目录会被挂载，其他分区则是在开机完成之后才会持续进行挂载的行为。就是因为如此，因此根目录下与<strong>开机过程有关的目录就不能够与根目录放到不同的分区去</strong>。有下面<br>　/bin：重要执行文件<br><br>　/etc:　配置文件<br><br>　/dev：所需要的设备文件<br><br>　/lib：执行文件所需的函数库与内核所需的模块<br><br>　/sbin：重要的系统执行文件<br><br><strong>这五个目录千万不可与根目录分开放在不同的分区</strong>。</p></blockquote><ul><li>/usr 的意义与内容</li></ul><blockquote><p>　依据FHS的基本定义，/usr里面放置的数据属于可分享的与不可变动的（shareable，static），如果你知道如何通过网络进行分区的挂载（例如在服务器篇会谈到的NFS服务器），那么/usr确实可以分享给局域网内的其他主机来使用。<br> <br>　其实 usr 是 UNIX Software Resource 的缩写，也就是<strong>“UNIX 操作系统软件资源”所放置的目录</strong>，而不是用户的数据。这点要注意。FHS<strong>建议所有软件开发者应该将他们的数据合理地分别放置到这个目录下的子目录，而不要自行新建该软件自己独里的目录</strong>。<br>　因为是所有系统默认的软件（distribution 发布者提供的软件）都会放置到/usr 下面，因此这个目录有点类似 Windows 系统的“C:\Windows\”和“C:\Program files\”这两个目录的综合体，系统刚安装完毕时，这个目录会占用最多的硬盘容量。一般来说，/usr的子目录建议有下图所示的这些</p></blockquote><p><img src="http://p0bl99g4r.bkt.clouddn.com/usr_dir.jpg" alt=""><br></p><ul><li>/var 的意义与内容</li></ul><blockquote><p>如果/usr是安装时会占用较大硬盘容量的目录，那么<strong>/var就是在系统运行后才会渐渐占用硬盘容量的目录</strong>。 <strong>因为/var目录主要针对常态性变动的文件，包括缓存（cache）、登录文件（log file）以及某些软件运行所产生的文件，包括程序文件（lock file，run file）</strong>，或者例如 MySQL数据库的文件等。</p></blockquote><p> <img src="https://github.com/DomBro96/MyNotes/blob/master/img/LinuxNoteImg/var_dir.jpg" alt=""><br></p><ul><li>目录树</li></ul><blockquote><p>　<strong>所有的文件与目录都是由根目录开始的</strong>。那是所有目录与文件的源头。然后再一个一个分支下来，<strong>有点像是树枝状。因此我们也称这种目录配置方式为“目录树（directorytree）”</strong>。<br>这个目录树有什么特性呢？它主要的特性有：<br><br>　　·目录树的起始点为根目录（/，root）；<br><br>　　·每一个目录不只能使用本地端的文件系统，也可以使用网络上的文件系统。举例来说，可以利用Network File System（NFS）服务器挂载某特定目录等。<br><br>　　·每一个文件在此目录树中的文件名（包含完整路径）都是独一无二的。</p></blockquote><p>　<img src="http://p0bl99g4r.bkt.clouddn.com/filetree.jpg" alt=""></p><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><p>整理笔记参考了 <a href="http://linux.vbird.org/linux_basic/0210filepermission.php#filepermission_perm" target="_blank" rel="noopener">《鸟哥的Linux私房菜》</a> 一书。这本书我是买的<a href="http://sale.jd.com/act/W5hugLDc1R.html" target="_blank" rel="noopener">京东阅读</a>的正版电子书籍。<br><br>如果不想买书看的话可以直接戳<a href="http://linux.vbird.org/" target="_blank" rel="noopener">这里进入鸟哥Linux私房菜的线上博客 : http://linux.vbird.org/</a>。请大家支持正版！！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; class=&quot;headerlink&quot; title=&quot;目录&quot;&gt;&lt;/a&gt;目录&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#1&quot;&gt;1. Linux文件权限&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#1.1&quot;&gt;1.1 用户与用户组&lt;
      
    
    </summary>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>文件系统管理</title>
    <link href="http://yoursite.com/2017/12/10/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86/"/>
    <id>http://yoursite.com/2017/12/10/文件系统管理/</id>
    <published>2017-12-10T03:07:25.000Z</published>
    <updated>2017-12-11T10:56:56.790Z</updated>
    
    <content type="html"><![CDATA[<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li><a href="#1">1. EXT2文件系统</a><ul><li><a href="#1.1">1.1 硬盘组成与分区</a></li><li><a href="#1.2">1.2 文件系统特性</a></li><li><a href="#1.3">1.3 Linux 的Ext2文件系统(inode)</a></li><li><a href="#1.4">1.4 与目录树的关系</a></li><li><a href="#1.5">1.5 Ext2/Ext3 文件的访问与日志文件系统功能</a></li><li><a href="#1.6">1.6 Linux 文件系统操作</a></li><li><a href="#1.7">1.7 挂载点(mount point)的意义</a></li></ul></li><li><a href="#2">2. 文件系统的简单操作</a><ul><li><a href="#2.1">2.1 磁盘与目录的容量：df,du</a></li><li><a href="#2.2">2.2 连接文件:ln</a></li></ul></li></ul><h2 id="1">1. Ext2文件系统</h2><p> Linux 最传统的磁盘文件系统使用的是 EXT2 。所以要了解文件系统就得要由认识 EXT2 开始。</p><h3 id="1.1">1.1 硬盘组成与分区</h3><ul><li>整块磁盘的（物理）组成主要有</li></ul><blockquote><p>圆形的盘片（主要记录数据的部分）;<br>机械手臂与机械手臂上的磁头（可读写盘片上的数据）；</p></blockquote><p> <em>主轴马达，可以转动盘片，让机械手臂的磁头在盘片上读写数据。而数据存储与读取的重点在于盘片</em></p><ul><li>盘片上的物理组成</li></ul><blockquote><p>扇区（Sector）为最小的物理存储单位，每个扇区为512bytes；<br>将扇区组成一个圆，那就是柱面（Cylinder），柱面是分区（partition）的最小单位；<br>第一个扇区最重要，里面有硬盘主引导记录（Masterbootrecord,MBR）及分区表（partition table），其中MBR 占有446bytes，而partition table 则占有64bytes。<br>各种接口的磁盘在Linux中的文件名分别为：<br>/dev/sd[a-p][1-15]：为SCSI,SATA，USB，Flash等接口的磁盘文件名；<br>/dev/hd[a-d][1-63]：为IDE接口的磁盘文件名。</p></blockquote><ul><li>磁盘的分区</li></ul><blockquote><p>主分区与扩展分区最多可以有4个（硬盘的限制）；<br>扩展分区最多只能有一个（操作系统的限制）；<br>逻辑分区是由扩展分区持续分出来的分区；<br>能够被格式化后作为数据访问的分区为主要分区与逻辑分区，扩展分区无法格式化；</p></blockquote><p><em>所谓的磁盘分区指的是告诉操作系统“我这块磁盘在此分区可以访问的区域是由A柱面到B柱面之间的块”，如此一来操作系统就能够知道它可以在所指定的块内进行文件数据的读/写/查找等操作了。也就是说，磁盘分区意即指定分区的起始与结束柱面就可以</em></p> <h3 id="1.2">1.2 文件系统特性</h3><p>操作系统的文件数据除了文件实际内容外，通常含有很多属性，例如Linux操作系统的文件权限（rwx）与文件属性（所有者、群组、时间参数等）。文件系统通常会将这两部分的数据分别存放在不同的块，权限与属性放置到<strong>inode </strong>中，至于实际数据则放置到<strong>data block</strong> 块中。另外，还有一个<strong>超级块（superblock）</strong>会记录整个文件系统的整体信息，包括inode与block的总量、使用量、剩余量等。</p><ul><li>三个数据的简略意义</li></ul><blockquote><p>super block：记录此文件系统的整体信息，包括 inode/block 的总量、使用量、剩余量，以及文件系统的格式与相关信息等；<br>inode：记录文件的属性，<strong>一个文件占用一个inode</strong>，同时记录此文件的数据所在的block号码；<br>block：实际记录文件的内容，若文件太大时，会占用多个block。</p></blockquote><p><em>inode—–&gt;block号码——&gt;文件实际数据 我们将这种数据访问的方法称为  <strong>索引式文件系统</strong> EXT2就是索引式文件系统 如下图</em></p><p><img src="http://p0bl99g4r.bkt.clouddn.com/inodeblock.jpg" alt="图片1"></p><h3 id="1.3">1.3 Linux 的Ext2文件系统(inode)</h3><p>inode 的内容用于记录文件的权限与相关属性，至于 block 块则是在记录文件的实际内容，而且文件系统一开始就将inode与block规划好了，除非重新格式化（或者利用resize2fs等命令更改文件系统大小），否则inode与block固定后就不再变动。但是，如果我的文件系统高达数百GB时，那么将所有的inode与block放置在一起将是很不明智的决定，因为inode与block的数量太大时，不容易管理。<br>因此 Ext2 文件系统在格式化的时候基本上是区分为多个块组（block group）的，每个块组都有独立的 inode/block/superblock 系统。感觉上就好像我们在当兵时，一个营里面有分成数个连，每个连有自己的联络系统，但最终都向营部回报连上最正确的信息一般。这样分成一群比较好管理。整个来说，Ext2格式化后如下图所示。</p><p><img src="http://p0bl99g4r.bkt.clouddn.com/block.jpg" alt="图片2"></p><ul><li>data block（数据块）</li></ul><blockquote><p>data block 是用来放置文件内容地方，在Ext2 文件系统中所支持的block 大小有1KB,2KB 及4KB三种而已。在格式化时block的大小就固定了，且每个block都有编号，以方便inode的记录。不过要注意的是，由于 block 大小的区别，会导致该文件系统能够支持的最大磁盘容量与最大单一文件容量并不相同</p></blockquote><table><thead><tr><th style="text-align:left">Block大小</th><th style="text-align:center">1KB</th><th style="text-align:center">2KB</th><th style="text-align:center">4KB</th></tr></thead><tbody><tr><td style="text-align:left">最大单一文件限制</td><td style="text-align:center">16GB</td><td style="text-align:center">256GB</td><td style="text-align:center">2TB</td></tr><tr><td style="text-align:left">最大文件系统总量</td><td style="text-align:center">2TB</td><td style="text-align:center">8TB</td><td style="text-align:center">16TB</td></tr></tbody></table><ul><li>Ext2 文件系统 block 限制</li></ul><blockquote><p>原则上，block的大小与数量在格式化完就不能够再改变了（除非重新格式化）；<br>每个block内<strong>最多只能够放置一个文件</strong>的数据；<br>承上，如果<strong>文件大于block的大小，则一个文件会占用多个block数量</strong>；<br>承上，若<strong>文件小于block，则该block的剩余空间就不能够再被使用了（磁盘空间会浪费）</strong>。</p></blockquote><ul><li>范例</li></ul><blockquote><p>假设你的Ext2文件系统使用4KB的block，而该文件系统中有10000个小文件，每个文件大小均为50bytes，请问此时你的磁盘浪费多少容量<br>答：Ext2 文件系统中一个 block 仅能容纳一个文件，因此每个 block 会浪费 4 × 1024 - 50 = 4046(bytes),整个系统会浪费 10000 × 4046 = 38.6 MB。然而所有文件大小仅为 10000 × 50(bytes) = 488.3KB 。</p></blockquote><ul><li>inodetable(inode表格)</li></ul><p>如上所述，inode的内容主要记录文件的属性以及该文件实际数据是放置在哪几号block内！基本上，inode记录的文件数据至少有下面这些</p><blockquote><p>该文件的访问模式（read/write/excute）；<br>该文件的所有者与组（owner/group）；<br>该文件的大小；<br>该文件创建或状态改变的时间（ctime）；<br>最近一次的读取时间（atime）；<br>最近修改的时间（mtime）；<br>定义文件特性的标志（flag），如SetUID等该文件真正内容的指向（pointer）。</p></blockquote><ul><li>inode的数量与大小也是在格式化时就已经固定了，除此之外inode的特色</li></ul><blockquote><p>每个inode大小均固定为128bytes；</p></blockquote><p>每个文件都仅会占用一个inode而已；<br>系统读取文件时需要先找到inode，并分析inode所记录的权限与用户是否符合，若符合才能够开始实际读取block的内容。</p><p><em>承上，因此文件系统能够创建的文件数量与inode的数量有关</em></p><ul><li>inode/block 与文件大小关系</li></ul><blockquote><p>inode要记录的数据非常多，但偏偏又只有128bytes而已，而inode记录一个block号码要花掉4byte，假设我一个文件有400MB且每个block为4KB时，那么至少也要10万条block号码的记录。inode哪有这么多可记录的信息？为此我们的系统很聪明地将inode记录block号码的区域定义为<strong>12个直接、一个间接、一个双间接与一个三间接记录区</strong>。我们将inode的结构画一下好了，下图所示。<br>图中最左边为inode本身（128bytes），里面有12个直接指向block号码的对照，这12个记录就能够直接取得block号码。至于所谓的间接就是再拿一个block来当作记录block号码的记录区，如果文件太大时，就会使用间接会利用所谓的双间接，第一个block仅再指出下一个记录编号的block在哪里，实际记录的在第二个block当中。依此类推，三间接就是利用第三层block来记录编号。<br>这样子inode能够指定多少个block呢？我们以较小的1KB的block来说明好了，可以指定的情况如下：<br>12 个直接指向：12 × 1K=12K（<strong>可以提供的 block 的总大小</strong>）<br>由于是直接指向，所以总共可记录12条记录。<br>间接：256 × 1K=256K (<strong>1K ÷ 4byte = 256个block号码记录，所以共可以提供 256K 的block</strong>)<br>每条block号码的记录会花去4bytes，因此1K的大小能够记录256条记录。<br>双间接：256 × 256 × 1K = 2 562K(<strong>1K ÷ 4byte = 记录的 256个block，其中每个block 又可以记录 256个block 共提供 2562K 的block</strong>)<br>第一层block会指定256个第二层，每个第二层可以指定256个号码<br>三间接：256 × 256 × 256 × 1K = 2 56 3 K<br>第一层block会指定256个第二层，每个第二层可以指定256个第三层，每个第三层可以指定256个号码。<br>总额：将直接、间接、双间接、三间接加总，得到12+256+256 × 256+256 × 256 × 256（K）=16GB </p></blockquote><p><img src="http://p0bl99g4r.bkt.clouddn.com/inode.jpg" alt=""></p><ul><li>Superblock(超级块)</li></ul><p><em>Superblock 是记录整个文件系统信息相关的地方，没有Surperblock，就没有这个文件系统了，他记录的主要信息有</em></p><blockquote><p>block与inode的总量；<br>未使用与已使用的inode/block数量block 与inode 的大小（block 为1K,2K,4K，inode 为128 bytes）；<br>文件系统的挂载时间、最近一次写入数据的时间、最近一次检验磁盘（fsck）的时间等文件系统的相关信息；<br>一个validbit 数值，若此文件系统已被挂载，则valid bit 为0，若未被挂载，则valid bit 为1。</p></blockquote><p>　Superblock是非常重要的，因为我们这个文件系统的基本信息都写在这里，如果 superblock 死掉了，你的文件系统可能就需要花费很多时间去挽救。一般来说， superblock 的大小为 1 024bytes。<br>　此外，每个 block group 都可能含有 superblock。但是我们也说一个文件系统应该仅有一个superblock 而已，<strong>事实上除了第一个 block group 内会含有 superblock 之外，后续的 block group 不一定含有 superblock</strong>，而若含有 superblock 则该 superblock 主要是作为第一个 block group 内 superblock 的备份了，这样可以进行 superblock 的救援。</p><ul><li>File system Description(文件系统描述)</li></ul><blockquote><p>这个区段可以描述每个 block group 的开始与结束的 block 号码，以及说明每个区段（superblock,bitmap,inodemap,data block）分别介于哪一个 block 号码之间。这部分也能够用dumpe2fs来查的。</p></blockquote><ul><li>block bitmap(block 对照表)</li></ul><blockquote><p>如果你想要添加文件时总会用到block。那你要使用哪个block来记录呢？当然是选择“空的block”来记录新文件的数据。那你怎么知道哪个 block 是空的？这就得要通过 block bitmap的辅助了。从 block bitmap 当中可以知道哪些 block 是空的，因此我们的系统就能够很快速地找到可使用的空间来处置文件。<br>同样，如果你删除某些文件时，那么那些文件原本占用的block号码就得要释放出来，此时在block bitmpap 当中相对应到该 block 号码的标志就得要修改成为“未使用中”。这就是 bitmap的功能。</p></blockquote><ul><li>inode bitmap(inode 对照表)</li></ul><blockquote><p>这个其实与 block bitmap 是类似的功能，只是 block bitmap 记录的是使用与未使用的 block号码，至于 inode bitmap 则是记录使用与未使用的 inode 号码。</p></blockquote><ul><li>dumpe2fs[-bh] 查询每个区段superblock的信息</li></ul><blockquote><p>[root@www ～]# dumpe2fs [-bh] 设备文件参数：<br>-b ：列出保留为坏道的部分（一般用不到吧！）<br>-h ：仅列出 superblock 的数据，不会列出其他的区段内容。</p></blockquote><ul><li>范例 找出根目录磁盘文件名，并查看文件系统相关信息</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">[root@www ～]# df　&lt;==这个命令可以调出目前挂载的设备</span><br><span class="line">Filesystem　1K-blocks　Used Available Use% Mounted on</span><br><span class="line">/dev/hdc2　　9920624　3822848　5585708　41% /　　&lt;==就是这个</span><br><span class="line">/dev/hdc3　　4956316　141376　4559108　4% /home</span><br><span class="line">/dev/hdc1　　101086　11126　84741　12% /boot</span><br><span class="line">tmpfs　　　371332　　0　371332　0% /dev/sh</span><br><span class="line">[root@www ～]# dumpe2fs /dev/hdc2</span><br><span class="line">dumpe2fs 1.39（29-May-2006）</span><br><span class="line">Filesystem volume name:　/1　　　&lt;==这个是文件系统的名称（Label）</span><br><span class="line">Filesystem features:　has_journal ext_attr resize_inode dir_index</span><br><span class="line">filetype needs_recovery sparse_super large_file</span><br><span class="line">Default mount options:　user_xattr acl &lt;==默认挂载的参数</span><br><span class="line">Filesystem state:　　clean　　　&lt;==这个文件系统是没问题的（clean）</span><br><span class="line">Errors behavior:　　Continue</span><br><span class="line">Filesystem OS type:　　Linux</span><br><span class="line">Inode count:　　　2560864　　&lt;==inode的总数</span><br><span class="line">Block count:　　　2560359　　&lt;==block的总数</span><br><span class="line">Free blocks:　　　1524760　　&lt;==还有多少个 block 可用</span><br><span class="line">Free inodes:　　　2411225　　&lt;==还有多少个 inode 可用</span><br><span class="line">First block:　　　0</span><br><span class="line">Block size:　　　4096　　&lt;==每个 block 的大小</span><br><span class="line">Filesystem created:　　Fri Sep　5 01:49:20 2008</span><br><span class="line">Last mount time:　　Mon Sep 22 12:09:30 2008</span><br><span class="line">Last write time:　　Mon Sep 22 12:09:30 2008</span><br><span class="line">Last checked:　　　Fri Sep　5 01Inode size:　　　128　　　&lt;==每个 inode 的大小</span><br><span class="line">Journal inode:　　　8　　　&lt;==下面这三个与下一小节有关</span><br><span class="line">Journal backup:　　inode blocks</span><br><span class="line">Journal size:　　　128M</span><br><span class="line">Group 0:（Blocks 0-32767） &lt;==第一个 data group 内容, 包含 block 的起始、结束号码</span><br><span class="line">Primary superblock at 0, Group descriptors at 1-1　&lt;==超级块在 0 号 block</span><br><span class="line">Reserved GDT blocks at 2-626</span><br><span class="line">Block bitmap at 627（+627）, Inode bitmap at 628（+628）</span><br><span class="line">Inode table at 629-1641（+629）　　　　　&lt;==inode table 所在的 block</span><br><span class="line">0 free blocks, 32405 free inodes, 2 directories　&lt;==所有 block 都用完了</span><br><span class="line">Free blocks:</span><br><span class="line">Free inodes: 12-32416　　　　　　&lt;==剩余未使用的 inode 号码</span><br><span class="line">Group 1:（Blocks 32768-65535）</span><br><span class="line">....（下面省略）....</span><br></pre></td></tr></table></figure><h3 id="1.4">1.4 与目录树的关系</h3><p>　上面提到在 Linux 系统下，每个文件（不管是一般文件还是目录文件）都会占用一个 inode，且可依据文件内容大小来分配多个 block 给文件使用。而且我们知道目录的内容在记录文件名，一般文件才是实际记录数据内容的地方。下面来介绍目录与文件在 Ext2 文件系统当中是如何记录数据的。</p><ul><li>目录</li></ul><blockquote><p>当我们在 Linux 下的 ext2 文件系统新建一个目录时，ext2会分配一个inode与至少一块block给该目录。其中，<strong>inode记录该目录的相关权限与属性，并可记录分配到的那块block号码</strong>；<strong>而block则是记录在这个目录下的文件名与该文件名占用的inode号码数据</strong>。也就是说目录所占用的block内容在记录如下的信息：</p></blockquote><p>　如果想要实际查看 root 目录内的文件所占用的 inode 号码时，可以使用 ls-i 这个参数来处理：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@www ～]# ls -li</span><br><span class="line">total 92</span><br><span class="line">654683 -rw------- 1 root root　1474 Sep　4 18:27 anaconda-ks.cfg</span><br><span class="line">648322 -rw-r--r-- 1 root root 42304 Sep　4 18:26 install.log</span><br><span class="line">648323 -rw-r--r-- 1 root root　5661 Sep　4 18:25 install.log.syslogi9</span><br></pre></td></tr></table></figure><p>　可以发现，使用<code>ls -l /</code>时，出现的目录几乎都是1024的倍数，因为每个block的大小都是1K,2K,4K。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@www ～]# ll -d / /bin /boot /proc /lost+found /sbin</span><br><span class="line">drwxr-xr-x 23 root root　4096 Sep 22 12:09 /　　&lt;==一个 4K block</span><br><span class="line">drwxr-xr-x　2 root root　4096 Sep 24 00:07 /bin　　&lt;==一个 4K block</span><br><span class="line">drwxr-xr-x　4 root root　1024 Sep　4 18:06 /boot　　&lt;==一个 1K block</span><br><span class="line">drwx------　2 root root 16384 Sep　5 01:49 /lost+found &lt;==4个 4K block</span><br><span class="line">dr-xr-xr-x 96 root root　0 Sep 22 20:07 /proc　　&lt;==此目录不占硬盘空间</span><br><span class="line">drwxr-xr-x　2 root root 12288 Sep　5 12:33 /sbin　　&lt;==3个 4K block</span><br></pre></td></tr></table></figure><p>　<em>目录并不只会占用一个 block 而已，即在目录下面的文件数如果太多而导致一个  block 无法容纳所有的文件名与 indoe 对照表时，Linux 会给予该目录一个 block 来继续记录相关的数据。</em></p><ul><li>文件</li></ul><blockquote><p>当我们在Linux下的ext2新建一个一般文件时，ext2会分配一个inode与相对于该文件大小的block数量给该文件。<br>例如：假设我的一个block为4KB，而我要新存储该文件。但同时请注意，由于inode仅有12个直接指向，因此还要多一个block来作为块号码的记录。</p></blockquote><ul><li>目录树读取</li></ul><blockquote><p>inode 本身并不记录文件名，文件名的记录是在目录的block当中。因此在<a href="https://github.com/DomBro96/MyNotes/blob/master/LinuxNote/Linux%E7%9A%84%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90%E4%B8%8E%E7%9B%AE%E5%BD%95%E9%85%8D%E7%BD%AE.md#1.2" target="_blank" rel="noopener">文件与目录的权限说明</a>中，我们才会提到新增/删除/重命名文件名与目录的w权限有关的特点。那么因为文件名是记录在目录的block当中，因此当我们要读取某个文件时，就务必会经过<strong>目录的inode与block</strong>，然后才能够找到那个待读取文件的inode号码，最终才会读到正确的文件的block内的数据。</p></blockquote><p>　由于目录树是由根目录开始读起，因此系统通过挂载的信息可以找到挂载点的 inode 号码（通常一个文件系统的最顶层inode号码会由2号开始），此时就能够得到根目录的inode内容，并依据该inode读取根目录的block内的文件名数据，再一层一层地往下读到正确的文件名。</p><ul><li>范例 当读取/etc/passwd 这个文件，系统如何读取</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1．/的inode</span><br><span class="line">通过挂载点的信息找到/dev/hdc2的inode号码为2的根目录inode，且inode具有的权限让我们可以读取该block的内容（有r与x）。</span><br><span class="line">2．/的block</span><br><span class="line">经过上个步骤取得block的号码，并找到该内容有etc/目录的inode号码。</span><br><span class="line">3．etc/的inode</span><br><span class="line">读取etc/的inode得知具有r与x的权限，因此可以读取etc/的block内容。</span><br><span class="line">4．etc/的block</span><br><span class="line">经过上个步骤取得block号码，并找到该内容有passwd文件的inode号码。</span><br><span class="line">5．passwd的inode</span><br><span class="line">读取passwd文件的inode得知具有r的权限，因此可以读取passwd的block内容。</span><br><span class="line">6．passwd的block</span><br><span class="line">最后将该block内容的数据读出来。</span><br></pre></td></tr></table></figure><h3 id="1.5">1.5 Ext2/Ext3 文件的访问与日志文件系统功能</h3><ul><li>文件访问</li></ul><p>上一节谈到了<a href="#1.4">Ext2文件系统文件读取</a>，新建一个文件或目录时，Ext2处理过程需要用到 blockmap 和 inodemap。假设想要新增一个文件，此时系统的行为是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1．先确定用户对于欲添加文件的目录是否具有w与x的权限，若有的话才能添加。</span><br><span class="line">2．根据inode bitmap 找到没有使用的inode 号码，并将新文件的权限/属性写入。</span><br><span class="line">3．根据block bitmap 找到没有使用中的block 号码，并将实际的数据写入block 中，且更新inode的block指向数据。</span><br><span class="line">4．将刚才写入的inode 与block 数据同步更新inode bitmap 与block bitmap，并更新superblock的内容。</span><br></pre></td></tr></table></figure><blockquote><p>一般来说，我们将inode table与data block称为数据存放区域，至于其他例如super block、block bitmap与inode bitmap 等区段就被称为 metadata（中间数据），因为super block,inode bitmap及block bitmap的数据是经常变动的，每次添加、删除、编辑时都可能会影响到这三个部分的数据，因此才被称为中间数据的。</p></blockquote><ul><li>日志文件系统功能</li></ul><p>　数据不一致状态</p><blockquote><p>在一般正常的情况下，上述的新增操作当然可以顺利完成。但是如果有个万一怎么办？例如你的文件在写入文件系统时，因为不明原因导致系统中断（例如突然停电、系统内核发生错误等的怪事发生时），所以写入的数据仅有 inode table 及 data block 而已，最后一个同步更新中间数据的步骤并没有做完，此时就会发生 meta dat的内容与实际数据存放区产生不一致的情况了。</p></blockquote><p>　日志文件系统（Journaling file system）</p><blockquote><p>为了避免上述提到的文件系统不一致的情况发生，因此我们的前辈们想到一个方式，如果在我们的文件系统当中规划出一个块，该块专门记录写入或修订文件时的步骤，那不就可以简化一致性检查的步骤了？也就是说：<br>1．预备：当系统要写入一个文件时，会先在日志记录块中记录某个文件准备要写入的信息。<br>2．实际写入：开始写入文件的权限与数据；开始更新meta data 的数据。<br>3．结束：完成数据与meta data 的更新后，在日志记录块当中完成该文件的记录在这样的程序当中，万一数据的记录过程当中发生了问题，那么我们的系统只要去检查日志记录块就可以知道哪个文件发生了问题，针对该问题来做一致性的检查即可，而不必针对整块文件系统去检查，这样就可以达到快速修复文件系统的能力了。这就是日志式文件最基础的功能。</p></blockquote><h3 id="1.6">1.6 Linux 文件系统操作</h3><ul><li>Linux 文件系统操作</li></ul><blockquote><p>所有的数据都得要加载到内存后CPU才能够对该数据进行处理。如果你经常编辑一个很大的文件，在编辑的过程中又频繁地要系统来写入磁盘中，由于磁盘写入的速度要比内存慢很多，因此你会经常耗在等待硬盘的写入/读取上。真没效率。<br>为了解决这个效率的问题，因此我们的Linux使用的方式是通过一个称为<strong>异步处理（asynchronously）的方式</strong>。所谓的异步处理是这样的：<br>当系统加载一个文件到内存后，如果该文件没有被改动过，则在内存区段的文件数据会被设置为（clean）的。但如果内存中的文件数据被更改过了（例如你用nano去编辑过这个文件），此时该内存中的数据会被设置为<strong>Dirty</strong>。此时所有的操作都还在内存中执行，并没有写入到磁盘中。系统会不定时地将内存中设置为 Dirty 的数据写回磁盘，以保持磁盘与内存数据的一致性。你也可以利用第 5 章谈到的sync命令来手动强迫写入磁盘。<br>我们知道内存的速度要比硬盘快得多，因此如果能够将常用的文系统会将常用的文件数据放置到主存储器的缓冲区，以加速文件系统的读/写。<br>承上，因此Linux的物理内存最后都会被用光。这是正常的情况，可加速系统性能。<br><strong>你可以手动使用sync来强迫内存中设置为Dirty的文件回写到磁盘中</strong>。<br>若正常关机时，关机命令会主动调用sync来将内存的数据回写入磁盘内。<br>但若不正常关机（如断电、死机或其他不明原因），由于数据尚未回写到磁盘内，因此重新启动后可能会花很多时间在进行磁盘检验，甚至可能导致文件系统的损毁（非磁盘损坏）。</p></blockquote><h3 id="1.7">1.7 挂载点(mount point)的意义</h3><p>每个文件系统都有<strong>独立的 inode、block、super block</strong> 等信息，这个<strong>文件系统要能够链接到目录树</strong>才能被我们使用。将文件系统与目录树结合的操作我们称为挂载。重点是：<strong>挂载点一定是目录</strong>，该目录为进入该文件系统的入口。因此并不是你有任何文件系统都能使用，必须要“挂载”到目录树的某个目录后，才能够使用该文件系统的。</p><ul><li>范例 </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@www ～]# ls -lid / /boot /home</span><br><span class="line">2 drwxr-xr-x 23 root root 4096 Sep 22 12:09 /</span><br><span class="line">2 drwxr-xr-x　4 root root 1024 Sep　4 18:06 /boot</span><br><span class="line">2 drwxr-xr-x　6 root root 4096 Sep 29 02:21 /home</span><br><span class="line">由于文件系统最顶层的目录的inode一般为2号，因此可以发现/,/boot,/home为三个不同的文件系统。（因为每一行的文件属性并不相同，</span><br><span class="line">且三个目录的挂载点也均不相同之故。）</span><br><span class="line">如果从使用文件系统的观点来看，同一个文件系统的某个inode只会对应到一个文件内容而已（因为一个文件占用一个inode的原因）</span><br></pre></td></tr></table></figure><h2 id="2">2. 文件系统的简单操作</h2><h3 id="2.1">2.1 磁盘与目录的容量：df,du</h3><ul><li>df: 列出文件系统的整体磁盘使用量</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@www ～]# df [-ahikHTm] [目录或文件名参数：</span><br><span class="line">-a ：列出所有的文件系统，包括系统特有的 /proc 等文件系统；</span><br><span class="line">-k ：以 KB的容量显示各文件系统；</span><br><span class="line">-m ：以 MB的容量显示各文件系统；</span><br><span class="line">-h ：以人们较易阅读的 GB、 MB、 KB等格式自行显示；</span><br><span class="line">-H ：以 M=1000K 替代 M=1024K 的进位方式；</span><br><span class="line">-T ：连同该分区的文件系统名称（例如 ext3） 也列出；</span><br><span class="line">-i ：不用硬盘容量，而以 inode 的数量来显示。</span><br></pre></td></tr></table></figure><ul><li>范例：df 将系统内所有的文件系统列出来(不同系统会有不同显示)</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@www ～]# df</span><br><span class="line">Filesystem　1K-blocks　Used Available Use% Mounted on</span><br><span class="line">/dev/hdc2　　9920624　3823112　5585444　41% /</span><br><span class="line">/dev/hdc3　　4956316　141376　4559108　4% /home</span><br><span class="line">/dev/hdc1　　101086　11126　84741　12% /boot</span><br><span class="line">tmpfs　　　371332　　0　371332　0% /dev/shm</span><br><span class="line"># 在 Linux 下面如果 df 没有加任何参数，那么默认会将系统内所有的被挂载的文件系统（不含特殊内存内的文件系统与 swap） 都以 1 KB 的容量来列出来。</span><br><span class="line"># 至于那个 /dev/shm 是与内存有关的挂载。</span><br></pre></td></tr></table></figure><ul><li>df范例 : 将容量以已读的容量格式显示出来</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@www ～]# df -h</span><br><span class="line">Filesystem　　　Size　Used Avail Use% Mounted on</span><br><span class="line">/dev/hdc2　　　9.5G　3.7G　5.4G　41% /</span><br><span class="line">/dev/hdc3　　　4.8G　139M　4.4G　4% /home</span><br><span class="line">/dev/hdc1　　　99M　11M　83M　12% /boot</span><br><span class="line">tmpfs　　　　363M　0　363M　0% /dev/shm</span><br><span class="line"># 不同上一范例，这里会以 G、M 等容量格式显示出来，比较容易看。</span><br></pre></td></tr></table></figure><ul><li>df范例：将系统内的所有特殊文件格式及名称都列出来</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@www ～]# df -aT</span><br><span class="line">Filesystem　Type 1K-blocks　Used Available Use% Mounted on</span><br><span class="line">/dev/hdc2　ext3　9920624 3823112　5585444　41% proc　　proc　　0　　0　　0　-　/proc</span><br><span class="line">sysfs　　sysfs　　0　　0　　0　-　/sys</span><br><span class="line">devpts　devpts　　0　　0　　0　-　/dev/pts</span><br><span class="line">/dev/hdc3　ext3　4956316　141376　4559108　4% /home</span><br><span class="line">/dev/hdc1　ext3　101086　11126　84741　12% /boot</span><br><span class="line">tmpfs　　tmpfs　371332　　0　371332　0% /dev/shm</span><br><span class="line">none　binfmt_misc　　0　　0　　0　-　/proc/sys/fs/binfmt_misc</span><br><span class="line">sunrpc　rpc_pipefs　　0　　0　　0　-　/var/lib/nfs/rpc_pipefs</span><br><span class="line"># 系统里面其实还有很多特殊的文件系统存在的。那些比较特殊的文件系统几乎都是在内存当中，例如 /proc 这个挂载点。</span><br><span class="line">因此，这些特殊的文件系# 都不会占据硬盘空间。</span><br></pre></td></tr></table></figure><ul><li>df范例：将 /etc 下面的可用的磁盘容量以易读的容量格式显示</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@www ～]# df -h /etc</span><br><span class="line">Filesystem　　　Size　Used Avail Use% Mounted on</span><br><span class="line">/dev/hdc2　　　 9.5G　3.7G　5.4G　41%    /</span><br><span class="line"># 这个范例比较有趣一点，在 df 后面加上目录或者是文件时，df 会自动分析该目录或文件所在的分区，并将该分区的容量显示出来，</span><br><span class="line"># 所以，你就可以知道某个目录下面还有多少容量可以使用了。</span><br></pre></td></tr></table></figure><ul><li>df范例：将目前各个分区当中可用的 inode 数量列出</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@www ～]# df -ih</span><br><span class="line">Filesystem　　　Inodes　IUsed　IFree IUse% Mounted on</span><br><span class="line">/dev/hdc2　　　2.5M　   147K　  2.3M　 6%     /</span><br><span class="line">/dev/hdc3　　　1.3M　    46　   1.3M　 1%     /home</span><br><span class="line">/dev/hdc1　　　26K　     34　    26K　 1%     /boot</span><br><span class="line">tmpfs　　　　   91K　　   1　     91K　1%      /dev/shm</span><br><span class="line"># 这个范例则主要列出可用的 inode 剩余量与总容量。</span><br><span class="line"># 你可以清楚地发现到，通常 inode 的数量剩余都比 block 还要多呢！</span><br></pre></td></tr></table></figure><ul><li>范例输出的信息说明</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Filesystem：代表该文件系统是在哪个分区，所以列出设备名称。</span><br><span class="line">1k-blocks：说明下面的数字单位是1KB。可利用-h或-m来改变容量Used：顾名思义，就是使用掉的硬盘空间啦！</span><br><span class="line">Available：也就是剩下的磁盘空间大小。</span><br><span class="line">Use%：就是磁盘的使用率。如果使用率高达 90%以上时，最好需要注意一下了，免得容量不足造成系统问题。（例如最容易被填满的/var/spool/mail这个放置邮件的磁盘）。</span><br><span class="line">Mountedon：就是磁盘挂载的目录所在（挂载点）。</span><br></pre></td></tr></table></figure><ul><li>注意</li></ul><blockquote><p>　另外需要注意的是，如果使用-a 这个参数时，系统会出现/proc 这个挂载点，但是里面的东西都是0，不要张。/proc的东西都是Linux系统所需要加载的系统数据，而且是挂载在内存当中的，所以当然没有占任何的硬盘空间。<br>　至于那个/dev/shm/目录，其实是利用内存虚拟出来的磁盘空间。由于是通过内存虚拟出来的磁盘，因此你在这个目录下面新建任何数据文件时，访问速度是非常快速的（在内存内工作）。不过，也由于它是内存虚拟出来的，因此这个文件系统的大小在每部主机上都不一样，而且新建的东西在下次开机时就消失了，因为是在内存中。</p></blockquote><ul><li>du 查看文件和目录磁盘使用空间</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@www ～]# du [-ahskm] 文件或目录名称</span><br><span class="line">选项与参数：</span><br><span class="line">-a ：列出所有的文件与目录容量，因为默认仅统计目录下面的文件量而已；</span><br><span class="line">-h ：以人们较易读的容量格式（G/M） 显示；</span><br><span class="line">-s ：列出总量而已，而不列出每个各别的目录占用</span><br><span class="line">-k ：以 KB列出容量显示；</span><br><span class="line">-m ：以 MB列出容量显示。</span><br></pre></td></tr></table></figure><ul><li>du 范例： 列出目前目录下得所有文件容量</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@www ～]# du</span><br><span class="line">8　　./test4　&lt;==每个目录都会列出来</span><br><span class="line">8　　./test2</span><br><span class="line">....中间省略....</span><br><span class="line">12　./.gconfd　&lt;==包括隐藏文件的目录</span><br><span class="line">220　.　　&lt;==这个目录（.）所占用的总量</span><br><span class="line"># 直接输入 du 没有加任何参数时，则 du 会分析目前所在目录的文件与目录所占用的硬盘空间。但是，实际显示时，仅会显示目录容量（不含文件），</span><br><span class="line"># 因此 . 目录有很多文件没有被列出来，所以全部的目录相加不会等于 . 的容量。</span><br><span class="line"># 此外，输出的数值数据为 1K 大小的容量单位。</span><br></pre></td></tr></table></figure><ul><li>du 范例：将文件的容量也列出来</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@www ～]# du -a</span><br><span class="line">12　./install.log.syslog　&lt;==有文件的列表了</span><br><span class="line">8　　./.bash_logout</span><br><span class="line">8　　./test4</span><br><span class="line">8　　./test212　./.gconfd</span><br><span class="line">220　.</span><br></pre></td></tr></table></figure><ul><li>du 范例：检查根目录下每个目录所占用的容量</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@www ～]# du -sm /*</span><br><span class="line">7　　/bin</span><br><span class="line">6　　/boot</span><br><span class="line">.....中间省略....</span><br><span class="line">0　　/proc</span><br><span class="line">.....中间省略....3859　/usr　&lt;==系统初期最大就是它了。</span><br><span class="line">77　/var</span><br><span class="line"># 这是个很常被使用的功能：利用通配符 * 来代表每个目录，</span><br><span class="line"># 如果想要检查某个目录下那个子目录占用最大的容量，可以用这个方法找出来</span><br><span class="line"># 值得注意的是，如果刚才安装好 Linux 时，那么整个系统容量最大的应该是 /usr</span><br><span class="line"># 而 /proc 虽然有列出容量，但是那个容量是在内存中，不占硬盘空间。</span><br></pre></td></tr></table></figure><p><em>与 df 不一样的是，du 这个命令其实会直接到文件系统内去查所有的文件数据</em></p><h3 id="2.2">2.2 连接文件:ln</h3><p>　Linux 下面连接文件有两种，一种是类似 Windows 的快捷方式功能文件，可以快速连接到目标文件；另一种是通过文件系统的 inode 连接来产生新文件名，而不是产生新文件，这种成为硬链接(hard link)。这两个完全是不一样的东西。</p><ul><li>hard link（硬连接或实际连接）</li></ul><blockquote><p>前面提到，文件名只与目录有关，但文件内容与 inode 有关。那么想一想，有没有可能有多个文件名对应到同一个inode 号码呢？那就是 hard link 的由来。<br>所以简单地说：hardlink只是在某个<strong>目录下新建一条文件名连接到某inode号码的关联记录</strong>而已。</p></blockquote><ul><li>举个例子:</li></ul><p>假设系统有个/root/crontab它是/etc/crontab的实际连接，也就是说这<strong>两个文件名连接到同一个inode</strong>，自然这两个文件名的所有相关信息都会一模一样（除了文件名之外）。实际的情况可以如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@www ～]# ln /etc/crontab . &lt;==创建实际连接的命令</span><br><span class="line">[root@www ～]# ll -i /etc/crontab /root/crontab</span><br><span class="line">1912701 -rw-r--r-- 2 root root 255 Jan 6 2007 /etc/crontab</span><br><span class="line">1912701 -rw-r--r-- 2 root root 255 Jan 6 2007 /root/crontab</span><br></pre></td></tr></table></figure><p>你可以发现两个文件名都连接到1912701这个inode号码，是否文件的权限、属性完全一样呢？因为这两个“文件名”其实是一模一样的“文件”，而且你也会发现第二个字段由原本的1 变成2 了！那个字段称为“连接”，这个字段的意义为“有多少个文件名连接到这个inode号码”的意思，如下图</p><p><img src="http://p0bl99g4r.bkt.clouddn.com/hardlink.jpg" alt=""></p><p>上图的意思是，你可以通过1或2的目录inode指定的block找到两个不同的文件名，而不管使用哪个文件名均可以指到real那个inode去读取到最终数据。那这样有什么好处呢？最大的好处就是“安全”。如图所示，如果你将任何一个“文件名”删除，其实inode与block都还是存在的。此时你可以通过另一个“文件名”来读取到正确的文件数据。此外，不论你使用哪个“文件名”来编辑，最终的结果都会写入到相同的inode与block中，因此均能进行数据的修改。</p><p><em>由此可以知道，使用 hard link 设置连接文件时，磁盘空间与 inode 的数目都不会改变。 hard link 只是在某个目录下的 block 多写入一个关联数据而已，既不会增加 inode 也不会耗用 block 数量。</em></p><ul><li>hard link 限制</li></ul><blockquote><p>不能跨文件系统；<br>不能连接到目录。<br>不能跨文件系统还好理解，那不能硬连接到目录又是怎么回事呢？这是因为如果使用hard link连接到目录时，连接的数据需要连同被连接目录下面的所有数据都建立连接，举例来说，如果你要将/etc 使用硬连接创建一个/etc_hd 的目录时，那么在/etc_hd 下面的所有文件名同时都与/etc下面的文件名要创建硬连接的，而不是仅连接到/etc_hd与/etc而已。并且，未来如果需要在/etc_hd 下面创建新文件时，连带的，/etc 下面的数据又得要创建一次 hard link，因此造成环境相当大的复杂度。目前 hard link 对于目录暂时还是不支持的。</p></blockquote><ul><li>symbolic link(符号连接,也即是快捷方式)</li></ul><blockquote><p>相比于 hard link symbolic link 就好理解多了。基本上，symbolic link 就是在创建一个独立的文件，而这这个文件会让数据的读取指向它连接的那个文件的文件名。由于只是利用文件来作为指向操作，所以，当源文件被删除之后，symbolic link 的文件会“开不了”，会一直说“无法打开某文件”。实际上就是找不到源文件“文件名”而已。</p></blockquote><ul><li>举个例子:我们先创建一个符号连接文件连接到/etc/crontab去看看：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@www ～]# ln -s /etc/crontab crontab2</span><br><span class="line">[root@www ～]# ll -i /etc/crontab /root/crontab2</span><br><span class="line">1912701 -rw-r--r-- 2 root root 255 Jan 6 2007 /etc/crontab</span><br><span class="line">654687 lrwxrwxrwx 1 root root 12 Oct 22 13:58 /root/crontab2 -&gt; /etc/crontab</span><br></pre></td></tr></table></figure><p>由上面的结果我们可以知道两个文件指向不同的inode号码，当然就是两个独立的文件存在。而且连接文件的重要内容就是它会写上目标文件的“文件名”，你可以发现为什么上面连接文件的大小为12bytes呢？因为箭头（-&gt;）右边的文件名“/etc/crontab”总共有12个英文，每个英文占用1个byte，所以文件大小就是12bytes了！如下图</p><p><img src="http://p0bl99g4r.bkt.clouddn.com/symboliclink.jpg" alt=""></p><p>由1 号inode 读取到连接文件的内容仅有文件名，根据文件名连接到正确的目录去取得目标文件的 inode ，最终就能够读取到正确的数据了。你可以发现的是，如果目标文件（/etc/crontab）被删除了，那么整个环节就会无法继续进行下去，所以就会发生无法通过连接文件读取的问题了。</p><ul><li>ln 命令</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@www ～]# ln [-sf] 源文件 目标文件</span><br><span class="line">参数：</span><br><span class="line">-s ：如果不加任何参数就进行连接，那就是hard link，至于 -s 就是symbolic link</span><br><span class="line">-f ：如果目标文件存在时，就主动将目标文件直接删除后再创建。</span><br></pre></td></tr></table></figure><ul><li>ln 范例</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">范例一：将 /etc/passwd 复制到 /tmp 下面，并且查看 inode 与 block</span><br><span class="line">[root@www ～]# cd /tmp</span><br><span class="line">[root@www tmp]# cp -a /etc/passwd .</span><br><span class="line">[root@www tmp]# du -sb ; df -i .Filesystem　　　Inodes　IUsed　IFree IUse% Mounted on</span><br><span class="line">/dev/hdc2　　　2560864　149738 2411126　6% /</span><br><span class="line"># 利用 du 与 df 来检查一下目前的参数，那个 du -sb</span><br><span class="line"># 是计算整个 /tmp 下面有多少 bytes 的啦！</span><br><span class="line"></span><br><span class="line">范例二：将 /tmp/passwd 制作 hard link 成为 passwd-hd 文件，并查看文件与容量</span><br><span class="line">[root@www tmp]# ln passwd passwd-hd</span><br><span class="line">[root@www tmp]# du -sb ; df -i .</span><br><span class="line">18340　.</span><br><span class="line">Filesystem　　　Inodes　IUsed　IFree IUse% Mounted on</span><br><span class="line">/dev/hdc2　　　2560864　149738 2411126　6% /</span><br><span class="line">#即使多了一个文件在 /tmp 下面，整个 inode 与 block 的容量并没有改变。</span><br><span class="line">[root@www tmp]# ls -il passwd*</span><br><span class="line">586361 -rw-r--r-- 2 root root 1945 Sep 29 02:21 passwd</span><br><span class="line">586361 -rw-r--r-- 2 root root 1945 Sep 29 02:21 passwd-hd</span><br><span class="line"># 原来是指向同一个 inode ，另外，那个第二列的连接数也会增加！</span><br><span class="line"></span><br><span class="line">范例三：将 /tmp/passwd 创建一个符号连接</span><br><span class="line">[root@www tmp]# ln -s passwd passwd-so</span><br><span class="line">[root@www tmp]# ls -li passwd*</span><br><span class="line">586361 -rw-r--r-- 2 root root 1945 Sep 29 02:21 passwd</span><br><span class="line">586401 lrwxrwxrwx 1 root root 6 Oct 22 14:18 passwd-so -&gt; passwd</span><br><span class="line"># passwd-so 指向的 inode number 不同了。这是一个新的文件，这个文件的内容是指向</span><br><span class="line"># passwd 的。passwd-so 的大小是 6bytes ，因为 passwd 共有6个字符之故</span><br><span class="line">[root@www tmp]# du -sb ; df -i .</span><br><span class="line">18346 .</span><br><span class="line">Filesystem　　　Inodes　IUsed　IFree IUse% Mounted on</span><br><span class="line">/dev/hdc2　　　2560864　149739 2411125　6% /</span><br><span class="line">#整个容量与 inode 使用数都改变了。</span><br><span class="line"></span><br><span class="line">范例四：删除源文件 passwd ，其他两个文件是否能够开启？</span><br><span class="line">[root@www tmp]# rm passwd[root@www tmp]# cat passwd-hd</span><br><span class="line">......正常显示完毕！</span><br><span class="line">[root@www tmp]# cat passwd-so</span><br><span class="line">cat: passwd-so: No such file or directory</span><br><span class="line">[root@www tmp]# ll passwd*</span><br><span class="line">-rw-r--r-- 1 root root 1945 Sep 29 02:21 passwd-hd</span><br><span class="line">lrwxrwxrwx 1 root root 6 Oct 22 14:18 passwd-so -&gt; passwd</span><br><span class="line">#符号连接果然无法打开。另外，如果符号链接的目标文件不存在，</span><br><span class="line"># 其实文件名的部分就会有特殊的颜色显示。</span><br></pre></td></tr></table></figure><p><em>使用ln 如果不加任何参数的话，那么就是 hard link。如同范例二的情况，增加了 hard link 之后，可以发现使用ls-l时，显示的link那一列属性增加。而如果这个时候删掉passwd会发生什么事情呢？passwd -hd 的内容还是会跟原来 passwd 相同，但是 passwd-so 就会找不到该文件。</em></p><ul><li>关于目录的连接数量</li></ul><p><em>当我们新建一个空目录时，新的目录连接数为2 （. 和 ..） 而上层目录连接数增加 1。</em></p><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><p>整理笔记参考了 <a href="http://linux.vbird.org/linux_basic/0210filepermission.php#filepermission_perm" target="_blank" rel="noopener">《鸟哥的Linux私房菜》</a> 一书。这本书我是买的<a href="http://sale.jd.com/act/W5hugLDc1R.html" target="_blank" rel="noopener">京东阅读</a>的正版电子书籍。</p><p>如果不想买书看的话可以直接戳<a href="http://linux.vbird.org/" target="_blank" rel="noopener">这里进入鸟哥Linux私房菜的线上博客 : http://linux.vbird.org/</a>。请大家支持正版！！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; class=&quot;headerlink&quot; title=&quot;目录&quot;&gt;&lt;/a&gt;目录&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#1&quot;&gt;1. EXT2文件系统&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#1.1&quot;&gt;1.1 硬盘组成与分区&lt;
      
    
    </summary>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux文件与目录管理</title>
    <link href="http://yoursite.com/2017/12/10/Linux%E6%96%87%E4%BB%B6%E4%B8%8E%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86/"/>
    <id>http://yoursite.com/2017/12/10/Linux文件与目录管理/</id>
    <published>2017-12-10T02:52:32.000Z</published>
    <updated>2017-12-11T10:57:29.831Z</updated>
    
    <content type="html"><![CDATA[<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li><a href="#1">1. 目录与路径</a><ul><li><a href="#1.1">1.1 相对路径与绝对路径</a></li><li><a href="#1.2">1.2 目录的相关操作</a></li><li><a href="#1.3">1.3 常见目录处理命令</a></li><li><a href="#1.4">1.4 执行文件路径变量 $PATH</a></li></ul></li><li><a href="#2">2. 文件与目录管理</a><ul><li><a href="#2.1">2.1 查看文件与目录 : ls</a></li><li><a href="#2.2">2.2 复制、删除与移动 : cp , rm , mv</a></li><li><a href="#2.3">2.3 取得文件名与目录名称</a></li></ul></li><li><a href="#3">3. 文件内容查阅</a><ul><li><a href="#3.1">3.1 直接查看文件内容 : cat , tac , nl</a></li><li><a href="#3.2">3.2 可翻页查看 : more , less </a></li><li><a href="#3.3">3.3 数据选取 : head , tail</a></li><li><a href="#3.4">3.4 非纯文本文件 : od</a></li><li><a href="#3.5">3.5 修改文件时间或创建新文件 : touch</a></li></ul></li><li><a href="#4">4.文件与目录的默认权限与隐藏权限</a><ul><li><a href="#4.1">4.1 文件默认权限 : umask</a></li><li><a href="#4.2">4.2 文件隐藏属性 : chattr , lsattr</a></li><li><a href="#4.3">4.3 查看文件类型 : file</a></li></ul></li><li><a href="#5">5. 命令与文件名的查询</a><ul><li><a href="#5.1">5.1 脚本文件的查询</a></li><li><a href="#5.2">5.2 文件名查找</a></li></ul></li><li><a href="#6">6. 权限与命令之间的关系 <strong>(很重要)</strong></a></li></ul><h2 id="1">1. 目录与路径</h2><ul><li>目录与文件的操作</li></ul><blockquote><p>Linux 下目录的操作包括在不同的目录间切换、创建与删除目录，创建与删除文件、查找文件、查看文件内容等。</p></blockquote><h3 id="1.1">1.1 相对路径与绝对路径</h3><ul><li>绝对路径</li></ul><blockquote><p>路径的写法一定由根目录/写起，例如/usr/share/doc这个目录。</p></blockquote><ul><li>相对路径</li></ul><blockquote><p>路径的写法不是由/写起，例如由/usr/share/doc 要到/usr/share/man 下面时，可以写成“cd ../man”，这就是相对路径的写法。相对路径意指相对于目前工作目录的路径。</p></blockquote><p> <em>至于特点——&gt;使用相对路径更加简洁方便，但绝对路径的正确度要比较好</em></p><h3 id="1.2">1.2 目录的相关操作</h3><ul><li>比较特殊的目录</li></ul><blockquote><p>. 　代表此层目录<br>　<br>..　代表上一层目录<br>　<br>-　代表前一个工作目录<br>　<br>～　代表“目前用户身份”所在的主文件～account 代表 account 这个用户的主文　件夹（account是个账号名称）</p></blockquote><h3 id="1.3">1.3 常见处理目录命令</h3><ul><li>常见处理目录命令</li></ul><blockquote><p>cd：切换目录<br><br><strong>pwd：显示当前目录</strong><br><br>参数：<br><br>-P ：显示出当前的路径，而非使用连接（link） 路径。<br><br>范例：单纯显示出当前的工作目录：<br><br>[root@www ～]# pwd<br><br>/root　&lt;== 显示出目范例：显示出实际的工作目录，而非连接文件本身的目录名而已<br><br>[root@www ～]# cd /var/mail　&lt;==注意，/var/mail是一个连接文件<br><br>[root@www mail]# pwd<br><br>/var/mail　　&lt;==列出目前的工作目录<br><br>[root@www mail]# pwd -P<br><br>/var/spool/mail　&lt;==怎么回事？有没有加 -P 差很多～<br><br>[root@www mail]# ls -ld /var/mail<br><br>lrwxrwxrwx 1 root root 10 Sep　4 17:54 /var/mail -&gt; spool/mail<br><br><em>看到这里应该知道为啥了吧？因为 /var/mail 是连接文件，连接到 /var/spool/mail</em>。</p><p><br><strong>mkdir：新建一个新的目录</strong><br>   <br>参数：<br><br>-m ：配置文件案的权限。直接设置，不需要看默认权限（umask）<br><br>-p ：<strong>帮助你直接将所需要的目录（包含上层目录）递归创建起来</strong>。</p><p><br><strong>rmdir：删除一个空的目录</strong><br>   <br>参数：<br><br>-p ：连同上层“<strong>空的</strong> 目录也一起删除</p></blockquote><h3 id="1.4">1.4 执行文件路径变量 $PATH</h3><blockquote><p>　当我们在执行一个命令的时候，举例来说“ls”好了，系统会依照　PATH　的设置去每个<strong>PATH定义的目录下查询文件名为ls的可执行文件</strong>，如果在PATH定义的目录中含有多个文件名为ls的可执行文件，那么先查询到的同名命令先被执行</p></blockquote><p><em>我们执行的每个命令实际上都是可执行的文件，可以通过输入这个文件的绝对路径(比如 /bin/ls )去执行这个文件，但当将这个 /bin 放入到 PATH 变量中，就不需要去将这个可执行文件的绝对路径打出，直接 ls 就可以了</em></p><p> 执行 echo $PATH 查看哪些目录被定义出来( echo 命令为 显示出打印，PATH 前面接的 $ 表示后面接的是变量，会显示出目前的路径！)</p><ul><li>范例</li></ul><blockquote><p>[root@www ～]# echo $PATH<br>/usr/kerberos/sbin:/usr/kerberos/bin:/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin:/root/bin<br>[root@www ～]# su - vbird<br><br>[vbird@www ～]# echo $PATH<br>/usr/kerberos/bin:/usr/local/bin:/bin:/usr/bin:/home/vbird/bin<br><br>仔细看，一般用户 vbird 的PATH中，并不包含任何“sbin”的目录存在喔！<br>PATH（一定是大写）这个变量的内容是由一堆目录所组成的，每个目录中间用冒号（:）来隔开，每个目录是有“<strong>顺序</strong>”之分的，<strong>如果两个路径下有相同可执行文件，优先执行排在前面目录中的文件</strong>。仔细看一下上面的输出，<strong>你可以发现无论是 root 还是 vbird 都有/bin 这个目录在PATH变量内，所以当然就能够在任何地方执行ls来找到/bin/ls执行文件</strong>。</p></blockquote><h2 id="2">2. 文件与目录管理</h2><p>文件与目录的管理在 Linux 重视很重要的，尤其是每个人自己主文件夹的数据也都需要注意管理。</p><h3 id="2.1">2.1 查看文件与目录 : ls</h3><ul><li>ls 命令</li></ul><blockquote><p>[root@www ～]# ls [-aAdfFhilnrRSt]目录名称<br>[root@www ～]# ls [–color={never,auto,always}]目录名<br>[root@www ～]# ls [–full-time]目录名称<br><br>参数：<br><br><strong>-a ：全部的文件，连同隐藏文件（ 开头为 . 的文件） 一起列出来（常用）</strong><br><br>-A ：列出全部的文件（连同隐藏文件，但不包括 . 与 .. 这两个目录）<br><br><strong>-d ：仅列出目录本身，而不是列出目录内的文件数据（常用）</strong><br><br>-f ：直接列出结果，而不进行排序（ls 默认会以文件名排序）<br><br>-F ：根据文件、目录等信息给予附加数据结构，<br>例如：<br>*:代表可执行文件； /:代表目录； =:代表 socket 文件； |:代表 FIFO 文件<br><br>-h ：将文件容量以人类较易读的方式（例如 GB, KB 等）列出来<br><br>-i ：列出 inode 号码，inode 的意义下一章将会介绍<br><br><strong>-l ：列出长数据串，包含文件的属性与权限等数据（常用)</strong><br><br>-n ：列出 UID 与 GID，而非用户与用户组的名称（UID与GID会在账号管理提到）<br><br>-r ：将排序结果反向输出，例如：原本文件名由小到大，反向则为由大到小<br><br>-R ：连同子目录内容一起列出来，等于该目录下的所有文件都会显示出来<br><br>-S ：以文件容量大小排序，而不是用文件名排序<br><br>-t ：依时间排序，而不是用文件名<br><br>–color=never ：不要依据文件特性给予颜色显示<br><br>–color=always ：显示颜色<br><br>–color=auto　：让系统自行依据设置来判断是否给予颜色<br><br>–full-time　：以完整时间模式（包含年、月、日、时、分） 输–time={atime,ctime} ：输出访问时间或改变权限属性时间（ctime）</p></blockquote><h3 id="2.2">2.2 复制、删除与移动 : cp , rm , mv</h3><ul><li>cp 复制文件或目录</li></ul><blockquote><p>[root@www ～]# cp [-adfilprsu] 源文件(source) 目标文件(destination)<br><br>[root@www ～]# cp [options] source1 source2 source3 …. directory<br><br>参数：<br><br><strong>-a ：连同文件的权限一同拷贝过来（常用）</strong>；<br><br>-d ：若源文件为连接文件的属性（link file），则复制连接文件属性而非文件本身；<br><br>-f ：为强制（force）的意思，若目标文件已经存在且无法开启，则删除后再尝试一次；<br><br><strong>-i ：若目标文件（destination）已经存在时，在覆盖时会先询问操作的进行（常用）</strong>；<br><br>-l ：进行硬连接（hard link）的连接文件创建，而非复制文件本身；<br><br>-p ：连同文件的属性一起复制过去，而非使用默认属性（备份常用）<br><strong>-r ：递归持续复制，用于目录的复制行为（常用）</strong>；<br><br>-s ：复制成为符号链接文件（symbolic link），即“快捷方式”文件；<br><br>-u ：若 destination 比 source 旧才更新 destination。<br><br><strong>最后需要注意的，如果源文件有两个以上，则最后一个目的文件一定要是“目录”才行</strong>！</p></blockquote><ul><li>cp -a 特性</li></ul><blockquote><p>[root@www tmp]# cp -a /var/log/wtmp wtmp_2<br><br>[root@www tmp]# ls -l /var/log/wtmp wtmp_2<br><br>-rw-rw-r– 1 root utmp 96384 Sep 24 11:54 /var/log/wtmp<br><br>-rw-rw-r– 1 root utmp 96384 Sep 24 11:54 wtmp_2<br><br>#整个数据特性完全一模一样。这就是 -a 的特性。<br><br>这个cp的功能很多，由于我们经常会进行一些数据的复制，所以也会经常用到这个命令的。一般来说，我们如果去复制别人的数据（当然，该文件你必须要有read的权限才行.）时，总是希望复制到的数据最后是我们自己的，所以，<strong>在默认的条件中，cp 的源文件与目的文件的权限是不同的，目的文件的所有者通常会是命令操作者本身</strong>。<br><br>由于具有这个特性，因此当我们在进行备份的时候，某些需要特别注意的特殊权限文件，例如<strong>密码文件（/etc/shadow）以及一些配置文件，就不能直接以cp来复制，而必须要加上-a或者是-p等可以完整复制文件权限的所有者等）</strong> 否则，其他人还是无法针对你给予的文件进行修订的操作**。</p></blockquote><ul><li>rm 移除文件或目录</li></ul><blockquote><p>[root@www ～]# rm [-fir]文件或目录<br><br>参数：<br><br>-f ：就是 force 的意思，忽略不存在的文件，不会出现警告信息；<br><br>-i ：<strong>互动模式，在删除前会询问用户是否操作；</strong><br><br>-r ：<strong>递归删除。最常用在目录的删除了。这是非常危险的参数！！！</strong></p></blockquote><p><em>在进行删除操作时尽量加上 -i 选项</em></p><ul><li>mv 移动文件目录或更名</li></ul><blockquote><p>[root@www ～]# mv [-fiu] source destination<br><br>[root@www ～]# mv [options] source1 source2 source3 …. dire参数：<br><br>-f ：force 强制的意思，如果目标文件已经存在，不会询问而直接覆盖；<br><br>-i ：若目标文件（destination） 已经存在时，就会询问是否覆盖；<br><br>-u ：若目标文件已经存在，且 source 比较新，才会更新（update）。</p></blockquote><ul><li>移动文件范例</li></ul><blockquote><p>[root@www ～]# cd /tmp<br>   <br>[root@www tmp]# cp ～/.bashrc bashrc<br>   <br>移动单个文件<br><br>[root@www tmp]# mkdir mvtest<br>   <br>[root@www tmp]# mv bashrc mvtest<br>   <br>移动多个文件<br>   [root@www tmp]# cp ～/.bashrc bashrc1<br>   <br>[root@www tmp]# cp ～/.bashrc bashrc2<br>   <br>[root@www tmp]# mv bashrc1 bashrc2 mvtest2<br>   <br><strong>注意如果由多个源文件或目录，则最后一个目标文件一定是目录，意思是说将所有的数据移动到该目录</strong>。</p></blockquote><ul><li>重命名范例</li></ul><blockquote><p>[root@www tmp]# mv mvtest mvtest2 &lt;== 这样就重命名了。</p></blockquote><h3 id="2.3">2.3 取得文件名与目录名称</h3><ul><li>basename 与 dirname</li></ul><blockquote><p>[root@www ～]# basename /etc/sysconfig/network<br><br>network　　&lt;== 很简单！就取得最后的文件名。<br><br>[root@www ～]# dirname /etc/sysconfig/network<br><br>/etc/sysconfig &lt;== 取得目录名。</p></blockquote><h2 id="3">3. 文件内容查阅</h2><ul><li>查阅文件的几个基本命令</li></ul><blockquote><p>cat：由第一行开始显示文件内容。<br><br>tac：从最后一行开始显示，可以看出tac是cat的倒写形式。<br><br>nl：显示的时候，顺便输出行号。<br><br>more：一页一页地显示文件内容。<br><br>less：与more类似，但是比more更好的是，它可以往前翻页！<br><br>head：只看头几行。<br><br>tail：只看结尾几行。<br><br>od：以二进制的方式读取文件内容！</p></blockquote><h3 id="3.1">3.1 直接查看文件内容 : cat , tac , nl</h3><ul><li>cat (concatenate)</li></ul><blockquote><p>[root@www ～]# cat [-AbEnTv]<br><br>参数：<br><br>-A ：相当于 -vET 的整合参数，可列出一些特殊字符，而不是空白而已；<br><br>-b ：列出行号，仅针对非空白行做行号显示，空白行不标行号；<br><br>-E ：将结尾的断行字符 $ 显示出来；<br><br>-n ：打印出行号，连同空白行也会有行号，与-v ：列出一些看不出来的特殊字符。</p></blockquote><p><em>cat 是 concatenate(连续)的简写，主要功能是将一个文件的内容连续显示在屏幕上面。建议文件在超过40行时不要使用 cat ，因为根本来不及看到结果。</em></p><ul><li>tac (反向示例)</li></ul><blockquote><p>仔细看一下 cat 与 tac ，tac 刚好是将 cat 反写过来，所以他的功能和 cat 相反，由最后一行到第一行反向在屏幕上显示出来。</p></blockquote><ul><li>nl (添加行号打印)</li></ul><blockquote><p>[root@www ～]# nl [-bnw] 文件<br><br>参数：<br><br>-b ：指定行号指定的方式，主要有两种：<br><br>-b a ：表示不论是否为空行，也同样列出行号（类似 cat -n）；<br><br>-b t ：如果有空行，空的那一行不要列出行号（默-n ：列出行号表示的方法，主要有三种：<br><br>-n ln ：行号在屏幕的最左方显示；<br><br>-n rn ：行号在自己字段的最右方显示，且不加 0 ；<br><br>-n rz ：行号在自己字段的最右方显示，且加 0。<br><br>-w ：行号字段占用的位数。</p></blockquote><ul><li>nl 范例</li></ul><blockquote><p>[root@www ～]# nl -b a -n rz -w 3 /etc/issue<br><br>001　CentOS release 5.3 (Final)<br><br>002　Kernel \r on an \m<br><br>003</p></blockquote><p><em>nl 可以将输出的文件内容自动加上行号！其默认结果与 cat -n 不太一样，nl 可以将行号做比较多的现实射击，包括为数与是否自动补0的功能。</em></p><h3 id="3.2">3.2 可翻页查看 : more , less</h3><ul><li>more (一页一页的翻动)</li></ul><blockquote><p>[root@www ～]# more /etc/man.config<br><br>#<br><br># Generated automatically from man.conf.in by the<br><br># configure script.<br><br>#<br><br># man.conf from man-1.6d<br><br>….（中间省略）….<br><br>–More–(28%) &lt;== 重点在这一行。你的光标也会在这里等待你的命令。<br><br>仔细看看上面的范例，如果more后面接的文件内容行数大于屏幕输出的行数时，就会出现类似上面的图示。重点在最后一行，最后一行会显示出目前显示的百分比，而且还可以在最后一行输入一些有用的命令。<br>空格键（Space）：代表向下翻一页；<br><br>Enter　：代表向下滚动一行；<br><br>/字符串　：代表在这个显示的内容当中，向下查询“字符串”这个关键字；<br><br>:f　　：立刻显示出文件名以及目前显示的行数；<br><br>q　　：代表立刻离开more，不再显示该文件内容。<br><br>b或[ctrl]-b　：代表往回翻页，不过这操作只对文件有用，对管道无用。<br><br>要离开more这个命令的显示工作，可以按下q就能够离开了。而要向下翻页，就使用空格键即可。<br>比较有用的是搜寻字符串的功能，举例来说，我们使用“more /etc/man.config”来查看该文件，若想要在该文件内搜寻MANPATH这个字符串时，可以这样做：<br><br>[root@www ～]# more /etc/man.config<br><br># Generated automatically from man.conf.in by the<br><br># configure script.<br><br>#<br><br># man.conf from man-1.6d<br><br>….（中间省略）….<br><br>/MANPATH &lt;== 输入了 / 之后，光标就会自动跑到最下面一行等待输入。<br><br>如同上面的说明，输入了/之后，光标就会跑到最下面一行，并且等待你的输入，你输入了字符串并按下[Enter]之后，more就会开始向下查询该字符串，而重复查询同一个字符串，可以直接按下 n 即可。最后，不想要看了，就按下 q 即可离开 more。</p></blockquote><ul><li>less (一页一页的翻动)</li></ul><blockquote><p>[root@www ～]# less /etc/man.confi#<br><br># Generated automatically from man.conf.in by the<br><br># configure script.<br><br>#<br><br># man.conf from man-1.6d<br><br>….（中间省略）….<br><br>: &lt;== 这里可以等待你输入命令！<br><br>less的用法比起more又更加有弹性 。在使用more的时候，我们并没有办法向前面翻，只能往后面看，但若使用了less时，就可以使用下、下等按键的功能来往前往后翻看文件，你瞧，是不是更容易使用来查看一个文件的内容了呢！<br><br>除此之外，在less里头可以拥有更多的查询功能。不只可以向下查询，也可以向上查询，实在是很不错，基本上，可以输入的命令有空格键　：向下翻动一页；<br><br>[PageDown]　：向下翻动一页；<br><br>[PageUp] ：向上翻动一页；<br><br>/字符串　：向下查询“字符串”的功能；<br><br>?字符串　：向上查询“字符串”的功能；<br><br>n　：重复前一个查询（与　/ 或 ? 有关）;<br><br>N　：反向重复前一个查询（与　/ 或 ? 有关）;<br><br>q　：离开 less这个程序；</p></blockquote><p><em>less 是一个非常重要的可翻页查看文件的命令！</em></p><h3 id="3.3">3.3 数据选取 : head , tail</h3><ul><li>head（取出前面几行）</li></ul><blockquote><p>[root@www ～]# head [-n number] 文件<br><br>参数：<br><br>-n ：后面接数字，代表显示几行的意思<br><br>[root@www ～]# head /etc/man.config<br><br><em>默认的情况中，显示前10行！若要显示前 20 行，就得要这样：</em><br><br>[root@www ～]# head -n 20 /etc/man.confi<br>范例：如果后面100行的数据都不打印，只打印/etc/man.config的前面几行，该如何是好？<br><br>[root@www ～]# head -n -100 /etc/man.config<br><br>head的英文意思就是“头”，那么用法自然就是显示出一个文件的前几行。若没有加上-n这个参数时，默认只显示十行，若只要一行呢？那就加入“head -n 1 filename ”即可！<br><br>另外那个-n 参数后面的参数较有趣，如果接的是负数，例如上面范例的-n-100 时，代表列出前面的所有行数，但不包括后面100行。<br>举例来说，/etc/man.config共有141行，则上述的命令“head -n -100 /etc/man.config”就会列出前面 41 行，后面 100 行不会打印出来了。</p></blockquote><ul><li>tail (取出后面几行)</li></ul><blockquote><p>[root@www ～]# tail [-n number] 文件<br><br>参数：<br><br>-n ：后面接数字，代表显示几行的意思<br><br>-f ：表示持续检测后面所接的文件名，要等到按下[ctrl]-c才会结束tail的检<br>[root@www ～]# tail /etc/man.config<br># 默认的情况中，显示最后的10行。<br>若要显示最后的 20 行，就得要这样：<br><br>[root@www ～]# tail -n 20 /etc/man.config</p></blockquote><ul><li>例题 <br></li></ul><p>若想显示 /etc/passwd 的 第11行到20行怎么办？</p><blockquote><p>head -n 20 /etc/passwd | tail -n 10<br><br>虽然涉及到管道命令，但还是可以理解，即用head取出前 20 行，再用 tail 取出这20行中的后10行。</p></blockquote><h3 id="3.4">非纯文本文件 : od</h3><ul><li>od</li></ul><blockquote><p>[root@www ～]# od [-t TYPE] 文件<br><br>参数：<br><br>-t ：后面可以接各种“类型（TYPE）”的输出，例如：<br><br>a　：利用默认的字符来输出；<br><br>c　：使用 ASCII 字符来输出；<br><br>d[size] ：利用十进制（decimal）来输出数据，每个整数占用 size bytes ；<br><br>f[size] ：利用浮点数（floating）来输出数据，每个数占用 size bytes ；<br><br>o[size] ：利用八进制（octal）来输出数据，每个整数占用 size bytes ；<br><br>x[size] ：利用十六进制（hexadecimal）来输出数据，每个整数占用 size bytes。</p></blockquote><h3 id="3.5">3.5 修改文件时间或创建新文件 ： touch</h3><ul><li>Linux 下面 文件的三个主要变动时间</li></ul><blockquote><p>modification time（mtime）<br><br>当该文件的“内容数据”更改时，就会更新这个时间。内容数据指的是文件的内容，而不是文件的属性或权限。<br>status time(ctime)<br>当该文件的“状态”（status）改变时，就会更新这个时间，举例来说，像是权限与属性被更改了，都会更新这个时间。<br><br>access time（atime）<br><br>当“该文件的内容被取用”时，就会更新这个读取时间（access）。举例来说，我们使用cat去读取/etc/man.config，就会更新该文件的atime了。</p></blockquote><ul><li>touch [-acdmt] 文件</li></ul><blockquote><p>[root@www ~]#touch [-acdmt] 文件<br><br>参数<br><br>-a ：仅修改访问时间；<br><br>-c ：仅修改文件的时间，若该文件不存在则不创建新文件；<br><br>-d ：后面可以接欲修改的日期而不用目前的日期，也可以使用 –date=”日期或时间”；<br><br>-m ：仅修改 mtime ；<br><br>-t ：后面可以接欲修改的时间而不用目前的时间，格式为[YYMMDDhhmm]。</p></blockquote><ul><li>范例</li></ul><blockquote><p>[root@www tmp]# cp -a ～/.bashrc bashrc<br><br>[root@www tmp]# ll bashrc; ll –time=atime bashrc; ll –time=ctime bashrc<br><br>-rw-r–r– 1 root root 176 Jan　6　2007 bashrc　&lt;==这是 mtime<br><br>-rw-r–r– 1 root root 176 Sep 25 21:11 bashrc　&lt;==这是 atime<br><br>-rw-r–r– 1 root root 176 Sep 25 21:12 bashrc　&lt;==这是 ctime</p></blockquote><p><em>我们平时看的文件属性中，比较重要的还是 mtime 。我们经常挂心这个文件的 “内容” 是什么时候被改动过的。</em></p><h2 id="4">4.文件目录的默认权限与隐藏权限</h2><ul><li>Linux 隐藏权限</li></ul><blockquote><p>除了基本的 r,w,x 权限外，在 Linux 的 Ext2/Ext3文件系统下，我们课可以设置其他的系统隐藏属性，这部分可以使用 chatter 来设置，lsatter 来查看，最重要的是属性就是可以设置其不可修改的特性。让连文件所有这个都不能进行修改。</p></blockquote><h3 id="4.1">4.1 文件默认权限 : umask</h3><ul><li>umask</li></ul><blockquote><p>　我们知道如何新建或者是改变一个目录或文件的属性了，不过，你知道当你新建一个新的文件或目录时，它的默认权限会是什么吗？那就与umask这个玩意儿有关了。那么umask是在搞什么呢？基本上，umask 就是指定“目前用户在新建文件或目录时候的权限默认值”，那么如何得知或设置umask呢？它的指定条件以下面的方式来指定：<br><br>[root@www ～]# umask<br><br>0022　　　&lt;==与一般权限有关的是后面三个数字。<br><br>[root@www ～]# umask -S<br><br>u=rwx,g=rx,o=rx<br><br>　查看的方式有两种，一种可以直接输入umask，就可以看到数字形态的权限设置分数，一种则是加入-S（Symbolic）这个参数，就会以符号类型的方式来显示出权限了。奇怪的是，怎么umask会有四组数字啊？不是只有三组吗？是没错。第一组是特殊权限用的，我们先不要理他，所以先看后面三组即可。<br><br>　在默认权限的属性上，目录与文件是不一样的。从第6章我们知道x权限对于目录是非常重要的。<strong>但是一般文件的创建则不应该有执行的权限，因为一般文件通常是用于数据的记录。当然不需要执行的权限了</strong>。<br><br>因此，默认的情况如下：<br>若用户创建“文件”则默认没有可执行（x）权限，即只有r、w这两个选项，也就是最大为666，默认权限如下：<br><br>　-rw-rw-rw-<br><br>　若用户新建“目录”，则由于 x 与是否可以进入此目录有关，因此默认为所有权限均开放，即为777分，默认权限如下：<br><br>drwxrwxrwx<br><br>　要注意的是，umask的分数指的是“该默认值需要减掉的权限”。因为 r、w、x分别是 4、2、1，也就是说，当要拿掉能写的权限，就是输入 2，而如果要拿掉能读的权限，也就是 4，那么要拿掉读与写的权限，也就是6，而要拿掉执行与写入的权限，也就是3，这样了解吗？请问你，5是什么？就是读与执行的权限。</p></blockquote><ul><li>umask 的利用与重要性 ： 专题制作</li></ul><blockquote><p>　想象一个情况，如果你跟你的同学在同一台主机上工作时，因为你们两个正在进行同一个专题，老师也帮你们两个的账号创建好了相同用户组的状态，并且将/home/class/目录作为你们两个人的专题目录。想象一下，有没有可能你所制作的文件你的同学无法编辑？果真如此的话，那就伤脑筋了。<br><br>　这个问题很常发生啊！举上面的案例来看就好了，你看一下test1的权限是几？644。意思是如果umask设定为022，那新建的数据只有用户自己具有w的权限，同用户组的人只有r这个可读的权限而已，并无法修改。这样要怎么共同制作专题？。<br><br>　所以，当我们需要新建文件给同用户组的用户共同编辑时，那么 umask 的用户组就不能拿掉2这个w的权限。umask就得要是002之类的才可以。这样新建的文件才能够是-rw-rw-r–的权限模样。那么如何设置umask呢？直接在umask后面输入002就好了。<br><br>[root@www ～]# umask 002[root@www ～]# mkdir test4<br><br>[root@www ～]# ll<br><br>-rw-rw-r– 1 root root　0 Sep 27 00:36 test3<br><br>drwxrwxr-x 2 root root　4096 Sep 27 00:36 test4<br><br>　所以说，这个umask对于新建文件与目录的默认权限是很有关系的。这个概念可以用在任何服务器上面，尤其是未来在你架设文件服务器，如 SAMBA Server 或者是 FTP Server时，都是很重要的观念。这牵涉到你的用户是否能够将文件进一步利用的问题，不可小看了。</p></blockquote><h3 id="4.2">4.2 文件的隐藏属性chattr.lsattr</h3><ul><li>chattr (设置文件的隐藏属性)</li></ul><blockquote><p>[root@www ～]# chattr [+-=][ASacdistu] 文件或目录名称<br><br>参数：<br><br>+ ：增加某一个特殊参数，其他原本存在参数则不动。<br><br>- ：删除某一个特殊参数，其他原本存在参数则不动。<br><br>= ：仅有后面接的参数。<br><br>A ：当设置了 A 这个属性时，若你有访问此文件（或目录）时，他的访问时间 atime将不会被修改，可避免I/O较慢的机器过度访问磁盘。这对速度较慢的计算机有帮助。<br><br>S ：一般文件是异步写入磁盘的（原理请参考第5章sync的说明），如果加上 S 这个属性时，当你进行任何文件的修改，该改动会“同步”写入磁盘中。<br><br><strong>a ：当设置 a 之后，这个文件将只能增加数据，而不能删除也不能修改数据，只有root才能设置这个属性</strong>。<br><br>c ：这个属性设置之后，将会自动将此文件压缩，在读取的时候将会d ：当 dump 程序被执行的时候，设置 d 属性将可使该文件（或目录）不会被 dump 备份。<br><br><strong>i ：这个 i 可就很厉害了。它可以让一个文件“不能被删除、改名，设置连接也无法写入或添加数据。“对于系统安全性有相当大的帮助。只有 root 能设置此属性</strong>。<br><br>s ：当文件设置了 s 属性时，如果这个文件被删除，它将会被完全从这个硬盘空间中删除。<br><br>u ：与 s 相反，当使用 u 来配置文件时，如果该文件被删除了，则数据内容其实还存在磁盘中，可以使用来找回该文件。</p></blockquote><ul><li>chattr 范例</li></ul><blockquote><p>请尝试到/tmp下面创建文件，并加入 i 的参数，尝试删除看看。<br>[root@www ～]# cd /tmp<br><br>[root@www tmp]# touch attrtest　&lt;==创建一个空文件<br><br>[root@www tmp]# chattr +i attrtest &lt;==给予 i 的属性<br>[root@www tmp]# rm attrtest　　&lt;==尝试删除看看<br><br>rm: remove write-protected regular empty file `attrtest’? y<br><br>rm: cannot remove `attrtest’: Operation not permitted &lt;==操作不许可<br><br><strong>看到了吗？连 root 也没有办法将这个文件删除呢！赶紧解除设置！</strong><br><br>[root@www tmp]# chattr -i attrtest<br><br>这个命令是很重要的，尤其是在系统的数据安全上面！由于这些属性是隐藏的性质，所以需要以lsattr才能看到该属性。其中，个人认为最重要的当属+i与+a这个属性了。<strong>+i可以让一个文件无法被更动，对于需要强烈的系统安全的人来说，真是相当重要的。里头还有相当多的属性是需要root才能设置的</strong>。</p></blockquote><ul><li>lsattr (显示文件隐藏属性)</li></ul><blockquote><p>[root@www ～]# lsattr [-adR] 文件或目录<br><br>参数：<br><br>-a ：将隐藏文件的属性也秀出来；<br><br>-d ：如果接的是目录，仅列出目录本身的属性而非目录内的文件名；<br><br>-R ：连同子目录的数据也一并列出来！<br><br>[root@www tmp]# chattr +aij attrtest<br><br>[root@www tmp]# lsattr attrtest<br><br>—-ia—j— attrtest</p></blockquote><h3 id="4.3">4.3 查看文件类型 : file</h3><ul><li>file 得到某文件的基本类型</li></ul><blockquote><p>[root@www ～]# file ～/.bashrc<br><br>/root/.bashrc: ASCII text &lt;==告诉我们是 ASCII 的纯文本文件。<br><br>[root@www ～]# file /usr/bin/passwd<br><br>/usr/bin/passwd: setuid ELF 32-bit LSB executable, Intel 80386, version 1<br>(SYSV), for GNU/Linux 2.6.9, dynamically linked (uses shared libs), for<br>GNU/Linux 2.6.9, stripped<br><br># 执行文件的数据可就多得不得了！   <br>[root@www ～]# file /var/lib/mlocate/mlocate.db<br>/var/lib/mlocate/mlocate.db: data &lt;== 这是 data 文件。<br><br>通过这个命令，我们可以简单地先判断这个文件的格式为何。</p></blockquote><h2 id="5">5.命令与文件的查询</h2><h3 id="5.1">5.1 脚本文件名的查询</h3><ul><li>which (寻找“执行文件”)</li></ul><blockquote><p>[root@www ～]# which [-a] comman参数：<br><br>-a ：将所有由 PATH 目录中可以找到的命令均列出，而不只第一个被找到的命令名称<br><br>范例一：分别用root与一般账号查询 ifconfig 这个命令的完整文件名<br><br>[root@www ～]# which ifconfig<br><br>/sbin/ifconfig　　　&lt;==用 root 可以找到正确的执行文件名<br><br>[root@www ～]# su - vbird &lt;==切换身份成为 vbird 去！<br><br>[vbird@www ～]$ which ifconfig<br><br>/usr/bin/which: noifconfigin(/usr/kerberos/bin:/usr/local/bin:/bin:/usr/bin:/home/vbird/bin)　　&lt;==见鬼了！竟然一般身份账号找不到！<br><br># 因为 which 是根据用户所设置的 PATH 变量内的目录去查找可执行文件的，所以# 不同的 PATH 设置内容所找到的命令当然不一样了。<br>因为 /sbin 不在 vbird 的<br># PATH 中，找不到也是理所当然的。<br><br>[vbird@www ～]$ exit　&lt;==记得将身份切换回原本的 root</p></blockquote><h3 id="5.2">5.2 文件名的查找</h3><p>在Linux下面也有相当优异的查找命令。通常find不很常用的，因为速度慢！通常我们都是先使<strong>用whereis或者是locate来检查，如果真的找不到了，才以find来查找。为什么呢？因为whereis与locate是利用数据库来查找数据，所以相当快速，而且并没有实际查询硬盘，比较节省时间</strong>。</p><ul><li>whereis (寻找特定文件)</li></ul><blockquote><p>[root@www ～]# whereis [-bmsu] 文件或目录名<br><br>参数：<br><br>-b　:只找二进制格式的文件<br><br>-m　:只找在说明文件 manual 路径下的文件<br><br>-s　:只找 source 源文件<br><br>-u　:查找不在上述三个选项当中的其他特殊文件</p></blockquote><ul><li>locate</li></ul><blockquote><p>[root@www ～]# locate [-ir] keyword<br><br>参数：<br><br>-i ：忽略大小写的差异；<br><br>-r ：后面可接正则表达式的显示方式范例一：找出系统中所有与 passwd 相关的文件名<br><br>[root@www ～]# locate passwd<br><br>/etc/passwd<br><br>/etc/passwd-<br><br>/etc/news/passwd.nntp<br><br>/etc/pam.d/passwd<br><br>….（下面省略）….<br><br>　这个 locate 的使用更简单，直接在后面输入“文件的部分名称”后就能够得到结果。举上面的例子来说，我输入 locate passwd，那么在完整文件名（包含路径名称）当中，只要有 passwd在其中，就会被显示出来的！这也是个很方便好用的命令，如果你忘记某个文件的完整文件名时。<br><br>　但是，这个东西还是有使用上的限制。为什么呢？你会发现使用 locate 来寻找数据的时候特别，这是因为locate寻找的数据是由已创建的数据库/var/lib/mlocate/里面的数据所查找到的，所以不用直接在去硬盘当中访问数据，当然是很快速那么有什么限制呢？就是因为它是经由数据库来查找的，而数据库的创建默认是每天执行一次（每个 distribution 都不同，CentOS 5.x 是每天更新数据库一次），所以当你新建文件后查找该文件，那么locate会告诉你“找不到”！因为必须要更新数据库。<br><br>　那能否手动更新数据库吗？当然可以，更新 locate 数据库的方法非常简单，直接输入“updatedb”就可以了！updatedb命令会去读取/etc/updatedb.conf这个配置文件的设置，嗌然后再去硬盘里面进行查找文件名的操作，最后就更新整个数据库文件 ！<br>　因为 updatedb会去查找硬盘，所以当你执行updatedb时，可能会等待数分钟的时间。<br><br>　updatedb：根据/etc/updatedb.conf的设置去查找系统硬盘内的文件名，并更新/var/lib/mlocate内的数据库文件。<br><br>locate：依据/var/lib/mlocate内的数据库记载，找出用户输入的关键字文件名。</p></blockquote><h2 id="6">6. 权限与命令间的关系</h2><ul><li>让用户能进入某目录成为 “可工作目录” 的基本权限</li></ul><blockquote><p>可使用的命令：例如cd等切换工作目录的命令。<br><br>目录所需权限：用户对这个目录至少需要具有x的权限。<br><br>额外需求：如果用户想要在这个目录内利用 ls 查阅文件名，则用户对此目录还需要r的权限。</p></blockquote><ul><li>用户在某个目录内读取一个文件的基本权限</li></ul><blockquote><p>可使用的命令：例如 <a href="#3.1">3.1</a> 谈到的 cat, more, less 等。<br><br>目录所需权限：用户对这个目录至少需要具有x权限。<br><br>文件所需权限：用户对文件至少需要具有r的权限才行！</p></blockquote><ul><li>让用户可以修改一个文件的基本权限</li></ul><blockquote><p>可使用的命令：例如nano或未来要介绍的vi编辑器等。<br><br>目录所需权限：用户在该文件所在的目录至少要有x权限。<br><br>文件所需权限：用户对该文件至少要有 r, w 权限。</p></blockquote><ul><li>让一个用户可以创建一个文件的基本权限</li></ul><blockquote><p>目录所需权限：用户在该目录要具有w, x 的权限,重点在 w 。</p></blockquote><ul><li>让用户进入某目录并执行该目录下的某个命令的基本权限是什么</li></ul><blockquote><p>目录所需权限：用户在该目录至少要有x的权限。<br>文件所需权限：用户在该文件至少需要有x的权限。</p></blockquote><ul><li>范例</li></ul><blockquote><p>让一个用户vbird能够进行“cp/dir1/file1/dir2”的命令时，请说明dir1, file1, dir2的最小所需权限。<br><br>答：执行cp时，vbird要能够读取源文件，并且写入目标文件。所以应参考上述第二点与第四点的说明，因此各文件/目录的最小权限应该是：<br><br>◆ dir1：至少需要有 x 权限；<br><br>◆ file1：至少需要有 r 权限；<br><br>◆ dir2：至少需要有 w, x 权限。</p></blockquote><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><p>整理笔记参考了 <a href="http://linux.vbird.org/linux_basic/0210filepermission.php#filepermission_perm" target="_blank" rel="noopener">《鸟哥的Linux私房菜》</a> 一书。这本书我是买的<a href="http://sale.jd.com/act/W5hugLDc1R.html" target="_blank" rel="noopener">京东阅读</a>的正版电子书籍。<br><br>如果不想买书看的话可以直接戳<a href="http://linux.vbird.org/" target="_blank" rel="noopener">这里进入鸟哥Linux私房菜的线上博客 : http://linux.vbird.org/</a>。请大家支持正版！！<br><br>至于笔记中的命令我是都敲过一遍的并进行了理解，并不是单纯的复制粘贴呦！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; class=&quot;headerlink&quot; title=&quot;目录&quot;&gt;&lt;/a&gt;目录&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#1&quot;&gt;1. 目录与路径&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#1.1&quot;&gt;1.1 相对路径与绝对路径&lt;/
      
    
    </summary>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>动态规划-Floyed算法</title>
    <link href="http://yoursite.com/2017/12/06/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-Floyed%E7%AE%97%E6%B3%95/"/>
    <id>http://yoursite.com/2017/12/06/动态规划-Floyed算法/</id>
    <published>2017-12-06T12:00:23.000Z</published>
    <updated>2017-12-07T07:00:48.677Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Floyed-算法"><a href="#Floyed-算法" class="headerlink" title="Floyed 算法"></a>Floyed 算法</h1><p>做一个 Floyed算法 的笔记，往往在算法前面加上一个英文名字就感觉很高大上，有一种听着就hin难的感觉。我尽可能写的通俗易懂，方便以后我忘了这个算法的时候，能以最快的速度唤醒的记忆。</p><h2 id="what"><a href="#what" class="headerlink" title="what"></a>what</h2><p>Floyed算法 ,顾名思义一个叫 Floyed 的人发明的。这个算法具有很强的实际用用性，很多书上往往会用<strong>有向图这样的数据结构来讲解 Floyed算法</strong>，那我就反其道而行之吧！</p><h3 id="一个场景"><a href="#一个场景" class="headerlink" title="一个场景"></a>一个场景</h3><p>刚才说 Floyed算法 具有很强的应用性，那我就来举一个实际的例子将你带入。</p><p>  <img src="http://p0bl99g4r.bkt.clouddn.com/floyed.png" alt=""></p><p>如图，我们设定每两个地点之间的路线只能沿着箭头方向(生活中的单向车道)，而有地点之间甚至没有路线，<strong>如果你想知道任意两个地点之间的最短路线咋办</strong>？告诉你　Floyed 算法就帮你达到这个目的！瞅啥呢赶紧上车！</p><h3 id="场景格式化"><a href="#场景格式化" class="headerlink" title="场景格式化"></a>场景格式化</h3><p>还是刚才的场景中的图片，我们不妨按顺时针将每个地点编号，用数字表示他们的距离。比如体育馆到公园有2km的距离，我们把这句话变形为 : 1-&gt;2 = 2km 如此两两组合，我们不妨设一个二维数组(矩阵):<br>1）横坐标表示出发地，纵坐标表示目的地<br>2）<strong>坐标对应值就是出发地到目的地路线长度</strong>(注意这里加粗是因为所说的路线长度是考虑了方向的)<br>3）如果两地间没有路线我们将它的值看为无穷大(这是Floyed算法一个很重要的点)<br>4）如果两地是同一地点(横纵坐标相同)，那它所代表的路径长度就是 0</p><p><img src="http://p0bl99g4r.bkt.clouddn.com/mex.png" alt=""></p><p>如图，表格中第一列(横坐标)代表出发地，第一行代表目的地(纵坐标)。</p><h3 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h3><p>我们通过一个距离矩阵描述了场景中地点间的路径，使它可以由程序语言描述出来，事实上我们想做的是利用这个矩阵描述出地点间最短路径！还是要回到最开始的问题<strong>如果你想知道任意两个地点之间的最短路线咋办</strong>？这里Floyed算法给出了一个很明确的思路：<strong>利用中间地点！</strong> 有点生活常识的人都知道，有时候并不是两个地点的直接距离是最近的，就像图片中，家-&gt;学校 的路线比 家-&gt;体育馆-&gt;公园-&gt;学校 路线要远。这里所说的 体育馆、公园 就是中间地点，<strong>如果 出发地-&gt;目的地 的路线长度比 出发地 -&gt;中间地点 -&gt;目的地 的路线长度长，那就选取后者作为两地节点的最短路线</strong>。这也就是为什么，我们规定没有路线的两个地点间距离是无穷大的原因，是一个很好理解的解决方案。我们最终希望希望矩阵变成这个样子</p><p><img src="http://p0bl99g4r.bkt.clouddn.com/max2.png" alt=""></p><h2 id="how"><a href="#how" class="headerlink" title="how"></a>how</h2><p>知道了 Floyed算法的原理，来看下如何实现。</p><h3 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h3><p>上面说 Floyed算法 的核心思想就是要找一个中间地点，来比较经过中间地点的路线和直达线路的距离。可是如果有多个中间地点的路线怎么办？下面按照上图中地点的编号来代表地点，如果要知道 4 -&gt; 3 的最短路线，我们就一定要知道 4 -&gt; 3 的全部路线。这里有 4 -&gt; 1 -&gt; 3，4 -&gt; 1 -&gt; 2 -&gt; 3，还有 4 -&gt; 3 直达 三条线路，经过很简单的比较我们找出 4 -&gt; 1 -&gt; 2 -&gt; 3 是最短的一条线路。经过这个例子，解决思路已经很清晰了：<strong>Floyed算法 在寻找任意两点最短路径时会将所有点作为中间点，依次比较 出发点-&gt;每个中间点的距离+每个中间点-&gt;目标点的距离 与 出发点-&gt;目标点的距离 大小，小的就是两点间最短距离</strong>，又由于设定没有路线的两点间距离为无穷大，所以我们总是可以通过中间点找到没有路线的两点间最短距。</p><h3 id="核心代码"><a href="#核心代码" class="headerlink" title="核心代码"></a>核心代码</h3><p>Floyed算法 的核心代码很简单，如果不考虑记录最短距离的路线，仅仅五行就够了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @param disMatrix 记录两点间最短距离矩阵</span><br><span class="line"> * @param vertex    共有多少顶点(地点)</span><br><span class="line"> * @param pathMatrix 记录两点间最短路线的矩阵</span><br><span class="line"> */</span><br><span class="line">public static void floyed(int[][] disMatrix,int vertex,String[][] pathMatrix)&#123;</span><br><span class="line"></span><br><span class="line">   //这里的 K 表示中间顶点(元素)，即从第一个顶点作为中间顶点循环找到最短路径</span><br><span class="line">    for (int k = 1; k &lt;= vertex; k++)&#123;</span><br><span class="line">       for (int i = 1; i&lt;= vertex; i++)&#123;</span><br><span class="line">          for (int j = 1; j &lt;= vertex; j++)&#123;</span><br><span class="line">             //如果任何两个节点之间有一个中间节点使得两节点间的距离变得更短，那么就为其赋值为通过中间节点的路径和</span><br><span class="line">             //这里要注意的是还要判断起始和结束的节点到中间节点是不是通的，即 i-&gt;k 和 k-&gt;j 一定不能是无穷大</span><br><span class="line">             if (disMatrix[i][k] &lt; Integer.MAX_VALUE &amp;&amp; disMatrix[k][j] &lt; Integer.MAX_VALUE &amp;&amp; disMatrix[i][j] &gt; disMatrix[i][k] + disMatrix[k][j]) &#123;</span><br><span class="line">                 disMatrix[i][j] = disMatrix[i][k] + disMatrix[k][j];</span><br><span class="line"> //只记录需要中间顶点的路径，如果不需要则是直达</span><br><span class="line">                 pathMatrix[i][j] = &quot;最短路径是节点 &quot; + i + &quot; —&gt; 节点&quot; + k + &quot; —&gt; 节点&quot; + j;</span><br><span class="line">                &#125;    </span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>代码会将初始的距离矩阵 <code>int[][] disMatrix</code> 变为两点间最短距离矩阵。</p><h3 id="全部代码"><a href="#全部代码" class="headerlink" title="全部代码"></a>全部代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line">public class DynamicProgram &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 初始化距离矩阵</span><br><span class="line">     * @param disMatrix 距离矩阵</span><br><span class="line">     * @param vertex 图的顶点个数</span><br><span class="line">     * @param paths 一共有多少条路径</span><br><span class="line">     */</span><br><span class="line">     public static void initMatrix(int[][] disMatrix,int vertex,int paths)&#123;</span><br><span class="line"></span><br><span class="line">         /**</span><br><span class="line">          * 通过双重循环对距离矩阵初始化</span><br><span class="line">          */</span><br><span class="line">         for (int i = 1;i &lt;= vertex; i++)&#123;</span><br><span class="line">             for (int j = 1; j &lt;= vertex; j++)&#123;</span><br><span class="line">                 if (i==j)</span><br><span class="line">                     //自己到自己的距离记为 0</span><br><span class="line">                     disMatrix[i][j] = 0;</span><br><span class="line">                 else</span><br><span class="line">                     disMatrix[i][j] = Integer.MAX_VALUE;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         /**</span><br><span class="line">          *</span><br><span class="line">          * 为图中路径赋值</span><br><span class="line">          */</span><br><span class="line">         for (int i = 1; i &lt;= paths; i++)&#123;</span><br><span class="line">             System.out.println(&quot;请输入起始点:&quot;);</span><br><span class="line">             Scanner scanner = new Scanner(System.in);</span><br><span class="line">             int begin = scanner.nextInt();</span><br><span class="line">             System.out.println(&quot;请输入终止点:&quot;);</span><br><span class="line">             int end = scanner.nextInt();</span><br><span class="line">             System.out.println(&quot;请输入节点&quot;+begin+&quot;和节点&quot;+end+&quot;的距离:&quot;);</span><br><span class="line">             int distance = scanner.nextInt();</span><br><span class="line">             disMatrix[begin][end] = distance;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     *</span><br><span class="line">     * @param disMatrix 记录两点间最短距离矩阵</span><br><span class="line">     * @param vertex    共有多少顶点点(地点)</span><br><span class="line">     * @param pathMatrix 记录两点间最短路线的矩阵</span><br><span class="line">     */</span><br><span class="line">    public static void floyed(int[][] disMatrix,int vertex,String[][] pathMatrix)&#123;</span><br><span class="line"></span><br><span class="line">        //这里的 K 表示中间顶点(元素)，即从第一个顶点作为中间顶点循环找到最短路径</span><br><span class="line">        for (int k = 1; k &lt;= vertex; k++)&#123;</span><br><span class="line">            for (int i = 1; i&lt;= vertex; i++)&#123;</span><br><span class="line">                for (int j = 1; j &lt;= vertex; j++)&#123;</span><br><span class="line">                    //如果任何两个节点之间有一个中间节点使得两节点间的距离变得更短，那么就为其赋值为通过中间节点的路径和</span><br><span class="line">                    //这里要注意的是还要判断起始和结束的节点到中间节点是不是通的，即 ik 和 kj 一定不能是无穷大</span><br><span class="line">                        if (disMatrix[i][k] &lt; Integer.MAX_VALUE &amp;&amp; disMatrix[k][j] &lt; Integer.MAX_VALUE &amp;&amp; disMatrix[i][j] &gt; disMatrix[i][k] + disMatrix[k][j]) &#123;</span><br><span class="line">                            disMatrix[i][j] = disMatrix[i][k] + disMatrix[k][j];</span><br><span class="line">                            pathMatrix[i][j] = &quot;最短路径是节点 &quot; + i + &quot; —&gt; 节点&quot; + k + &quot; —&gt; 节点&quot; + j;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void printDisMatrix(int[][] disMatrix,int vertex,String[][] pathMatrix)&#123;</span><br><span class="line"></span><br><span class="line">        for (int i = 1; i &lt;= vertex; i++)&#123;</span><br><span class="line">            for (int j = 1;j &lt;= vertex; j++)&#123;</span><br><span class="line">                if (i != j )&#123;</span><br><span class="line">                    String message = &quot;节点&quot;+i+&quot;到节点&quot;+j+&quot;的最短距离为&quot;+disMatrix[i][j]+&quot; &quot;;</span><br><span class="line">                    if (pathMatrix[i][j] != null)&#123;</span><br><span class="line">                        message += pathMatrix[i][j];</span><br><span class="line">                    &#125;else &#123;</span><br><span class="line">                        message += &quot;最短路径为直接到达&quot;;</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(message);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(&quot;请输入图中结点个数&quot;);</span><br><span class="line">        Scanner scanner = new Scanner(System.in);</span><br><span class="line">        int vertex = scanner.nextInt();</span><br><span class="line">        System.out.println(&quot;请输入图中路径的条数&quot;);</span><br><span class="line">        int paths = scanner.nextInt();</span><br><span class="line">        int disMatrix[][] = new int[10][10];</span><br><span class="line">        String[][] pathMatrix = new String[10][10];</span><br><span class="line">        initMatrix(disMatrix,vertex,paths);</span><br><span class="line">        floyed(disMatrix,vertex,pathMatrix);</span><br><span class="line">        printDisMatrix(disMatrix,vertex,pathMatrix);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">请输入图中结点个数</span><br><span class="line">4</span><br><span class="line">请输入图中路径的条数</span><br><span class="line">8</span><br><span class="line">请输入起始点:</span><br><span class="line">1</span><br><span class="line">请输入终止点:</span><br><span class="line">4</span><br><span class="line">请输入节点1和节点4的距离:</span><br><span class="line">4</span><br><span class="line">请输入起始点:</span><br><span class="line">1</span><br><span class="line">请输入终止点:</span><br><span class="line">3</span><br><span class="line">请输入节点1和节点3的距离:</span><br><span class="line">6</span><br><span class="line">请输入起始点:</span><br><span class="line">1</span><br><span class="line">请输入终止点:</span><br><span class="line">2</span><br><span class="line">...输入略...</span><br><span class="line"></span><br><span class="line">节点1到节点2的最短距离为2 最短路径为直接到达</span><br><span class="line">节点1到节点3的最短距离为5 最短路径是节点 1 —&gt; 节点2 —&gt; 节点3</span><br><span class="line">节点1到节点4的最短距离为4 最短路径为直接到达</span><br><span class="line">节点2到节点1的最短距离为9 最短路径是节点 2 —&gt; 节点4 —&gt; 节点1</span><br><span class="line">节点2到节点3的最短距离为3 最短路径为直接到达</span><br><span class="line">节点2到节点4的最短距离为4 最短路径是节点 2 —&gt; 节点3 —&gt; 节点4</span><br><span class="line">节点3到节点1的最短距离为6 最短路径是节点 3 —&gt; 节点4 —&gt; 节点1</span><br><span class="line">节点3到节点2的最短距离为8 最短路径是节点 3 —&gt; 节点4 —&gt; 节点2</span><br><span class="line">节点3到节点4的最短距离为1 最短路径为直接到达</span><br><span class="line">节点4到节点1的最短距离为5 最短路径为直接到达</span><br><span class="line">节点4到节点2的最短距离为7 最短路径是节点 4 —&gt; 节点1 —&gt; 节点2</span><br><span class="line">节点4到节点3的最短距离为10 最短路径是节点 4 —&gt; 节点2 —&gt; 节点3</span><br></pre></td></tr></table></figure><h2 id="about"><a href="#about" class="headerlink" title="about"></a>about</h2><p>总的来说 Floyed算法 是一个很好理解的算法，来分析一下。</p><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>Floyed算法通过三重循环实现，时间复杂度可以看到是 O(N^3)。核心代码仅要五行，如果对时间复杂度要求不高，使用 Floyed算法求两点间最短距离 是一个很好的选择。</p><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>Floyed算法 在使用上是有约束条件的，初始路径之间的距离不能出现负值，即如果如果把每个地点之间距离看成一个有向图，则该有向图顶点之间的权值不能为负。其实如果一个图中带有“负权回路”那么这个图则没有最短路径。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Floyed-算法&quot;&gt;&lt;a href=&quot;#Floyed-算法&quot; class=&quot;headerlink&quot; title=&quot;Floyed 算法&quot;&gt;&lt;/a&gt;Floyed 算法&lt;/h1&gt;&lt;p&gt;做一个 Floyed算法 的笔记，往往在算法前面加上一个英文名字就感觉很高大上，有一
      
    
    </summary>
    
    
      <category term="算法algorithm" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95algorithm/"/>
    
  </entry>
  
  <entry>
    <title>堆排序-HeapSort</title>
    <link href="http://yoursite.com/2017/12/04/%E5%A0%86%E6%8E%92%E5%BA%8F-HeapSort/"/>
    <id>http://yoursite.com/2017/12/04/堆排序-HeapSort/</id>
    <published>2017-12-04T01:43:02.000Z</published>
    <updated>2017-12-04T06:04:44.723Z</updated>
    
    <content type="html"><![CDATA[<h1 id="堆排序-HeapSort"><a href="#堆排序-HeapSort" class="headerlink" title="堆排序-HeapSort"></a>堆排序-HeapSort</h1><h2 id="what"><a href="#what" class="headerlink" title="what"></a>what</h2><p>首先我们来了解一些枯燥概念。这往往是必须的(TT)。</p><h3 id="堆-heap"><a href="#堆-heap" class="headerlink" title="堆 heap"></a>堆 heap</h3><ul><li>概念&amp;公式</li></ul><p>要了解堆排序，首先就要知道什么是堆！<strong>堆是顺序存储的完全二叉树</strong>(反正百度是这么说的)~ 翻译过来意思也就是堆实际就是逻辑上的完全二叉树，堆又分为 大根堆 和 小根堆 ，这个中文翻译很前卫… 分别有以下的特点</p><p>大根堆：每个节点的关键字(存储元素)都<strong>不小于</strong>其孩子节点的关键字,写成公式长这样</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ri &gt;= R2i+1 且 Ri &gt;= R2i+2 (i = 0,1,2...n)</span><br></pre></td></tr></table></figure><p>小根堆：每个节点的关键字(存储元素)都<strong>不大于</strong>其孩子节点的关键字     </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ri &lt;= R2i+1 且 Ri &lt;= R2i+2 (i = 0,1,2...n)</span><br></pre></td></tr></table></figure><p><em>公式中的 i 就是顺序存储结构中的位置，可以把它理解为数组中的索引</em>。</p><ul><li>理解&amp;总结</li></ul><p>你可能还是有点乱，<strong>简单一句话，堆就是把一个数组按照每个元素的索引，变成一颗逻辑上的完全二叉树，例如一个元素在数组中的索引是 i ，该元素的左孩子在数组中的索引就是 2i+1，右孩子在数组中的索引就是 2i+2，父节点的索引就是 (i-1)/2,而这颗完全二叉树的每个节点元素与其子节点元素之间还要满足一定的大小关系</strong>！</p><p><img src="http://p0bl99g4r.bkt.clouddn.com/sort.png" alt=""></p><p>如图，是一个整型无序数组变为大根堆后的逻辑形态，每个节点元素都比其子节点大。</p><h2 id="how"><a href="#how" class="headerlink" title="how"></a>how</h2><p>“堆排序” 这三个字你应该意识到，排序时一定会用到上面的堆，具体来说是大根堆。大根堆要如何实现排序？</p><h3 id="堆排序-heap-sort"><a href="#堆排序-heap-sort" class="headerlink" title="堆排序 heap-sort"></a>堆排序 heap-sort</h3><ul><li>大根堆的特点</li></ul><p>你可能没注意到<strong>大根堆的一大特点：根节点是最大的</strong>！ 也就是 索引为0 的元素是最大的。</p><ul><li>思路</li></ul><p>根据大根堆特点，可以总结一下思路。首先我们将一个数组 arrary[0…n] 调整为大根堆后，在交换 array[0] 和 array[n]。然后调整 array[0…n-1] 为大根堆，在交换 array[0] 和 array[n-1]，反复重复直到交换了 array[0] 和 array[1] 结束。 </p><ul><li>思路归纳</li></ul><p>根据上面的思路，可以归纳为两个操作：</p><p>1）根据初始数组构造初始堆(构建一个完全二叉树，保证所有父节点比孩子节点大，即大顶堆)。<br>2）每次交换第一个和最后一个元素，输出最后一个元素(此时为最大值)，把剩下的元素构造为大顶堆，直到输出完数组中最后一个元素后，这个数组已经从小到大排列了。</p><p><em>注意，这里说的输出最后一个元素的意思是，在下一次调整数组为大顶堆不包括该元素！</em></p><h3 id="初始化堆"><a href="#初始化堆" class="headerlink" title="初始化堆"></a>初始化堆</h3><p><strong>我们建造大根堆的过程就是要保证每个节点的子节点都比该节点小的过程，若节点的一个子节点比该节点大则节点与该节点交换，若两个子节点均比该节点大，则交换更大的那个节点</strong>。</p><ul><li><strong>错误思路</strong></li></ul><p>初始化堆这里我踩了一点坑，所以拿出来说一说。一开始我想从根节点(索引为0)开始递增构建大根堆</p><p><img src="http://p0bl99g4r.bkt.clouddn.com/sort2.png" alt=""></p><p>如图，从根节点开始循环递增会出现最大的元素无法到到达根节点的尴尬局面。这肯定不是一个大根堆。</p><ul><li><strong>正确思路</strong></li></ul><p><strong>从中间的节点(索引n/2)开始递减构建大根堆</strong>，可以有效的解决上面的问题</p><p><img src="http://p0bl99g4r.bkt.clouddn.com/sort3.png" alt=""></p><p>如图在从中间(索引)遍历完每个节点后均保证了其子节点元素都比该元素小，构建大顶堆成功。</p><h3 id="交换元素与调整"><a href="#交换元素与调整" class="headerlink" title="交换元素与调整"></a>交换元素与调整</h3><p>按照思路归纳中的步骤，初始化大根堆后，会交换根节点与最后一个元素，输出最后一个元素，可这时剩下元素组成的二叉树可能就不是大根堆了，所以还要将剩余元素变为大根堆，过程如下：</p><p><img src="http://p0bl99g4r.bkt.clouddn.com/sort4.png" alt=""></p><p>其实每次对剩余元素大根堆化的过程，与初始化大根堆是一样的，只不过传入的数组不包括上次交换的最后一个元素而已。到此，整个堆排序的过程也就介绍完了。</p><h3 id="Java代码"><a href="#Java代码" class="headerlink" title="Java代码"></a>Java代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 使用变治法的堆排序</span><br><span class="line"> *</span><br><span class="line"> * 分两步走：</span><br><span class="line"> * 第一步：将一个数组变为一个大根堆</span><br><span class="line"> * 第二步: 将该大根堆的根节点与最后一个元素进行交换，再将最后最后一个元素输出(此时最后一个元素是最大的元素)</span><br><span class="line"> */</span><br><span class="line">public class SeparateAndConquer &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取一个节点的左孩子在数组中位置</span><br><span class="line">     * @param parent 该左孩子</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    private static int getLeftChild(int parent)&#123;</span><br><span class="line">        return 2*parent+1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     *</span><br><span class="line">      * @param array 目标数组</span><br><span class="line">     * @param parent 节点在数组中的位置</span><br><span class="line">     * @param length 数组规模</span><br><span class="line">     */</span><br><span class="line">   public static &lt;AnyType extends Comparable&lt;? super AnyType&gt;&gt; void buildHeap(AnyType[] array, int parent, int length)&#123;</span><br><span class="line"></span><br><span class="line">       //保存当前父节点</span><br><span class="line">        AnyType temp = array[parent];</span><br><span class="line">       //先获得左孩子位置</span><br><span class="line">       int child = getLeftChild(parent);</span><br><span class="line"></span><br><span class="line">       while (child &lt; length)&#123;</span><br><span class="line">            //如果存在右孩子，并且右孩子值大于左孩子值，则选取右孩子节点</span><br><span class="line">            if (child + 1 &lt; length &amp;&amp; array[child].compareTo(array[child+1]) &lt; 0)&#123;</span><br><span class="line">                child++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            //如果父亲结点值大于孩子节点的值，则直接结束</span><br><span class="line">            if (temp.compareTo(array[child]) &gt; 0)&#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                //否则选取孩子节点的值赋给父节点</span><br><span class="line">                array[parent] = array[child];</span><br><span class="line">                //选取孩子节点的左孩子节点，继续向下筛选</span><br><span class="line">                parent = child;</span><br><span class="line">                child = 2 * child + 1;</span><br><span class="line">            &#125;</span><br><span class="line">       &#125;</span><br><span class="line"> </span><br><span class="line">       array[parent] = temp;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   public static &lt;AnyType extends Comparable&lt;? super AnyType&gt;&gt; void heapSort(AnyType[] array)&#123;</span><br><span class="line">        //首先将数组初始化为堆</span><br><span class="line">       for (int i = array.length/2; i &gt;= 0; i--)&#123;</span><br><span class="line">           buildHeap(array,i,array.length);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       //从最后一个元素开始循环(进行n-1次循环)，完成排序</span><br><span class="line">       for (int i = array.length - 1; i &gt; 0; i--)&#123;</span><br><span class="line">           //将最后一个元素与第一个元素交换</span><br><span class="line">           AnyType temp = array[i];</span><br><span class="line">           array[i] = array[0];</span><br><span class="line">           array[0] = temp;</span><br><span class="line">           //每次交换后，还要剩下的将最小的元素放回到最后一个位置，最大的元素放回到第一个位置</span><br><span class="line">           buildHeap(array,0,i);</span><br><span class="line">           System.out.format(&quot;第 %d 趟: \t&quot;, array.length - i);</span><br><span class="line">           printArray(array);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   public static &lt;AnyType extends Comparable&lt;? super AnyType&gt;&gt; void printArray(AnyType[] array)&#123;</span><br><span class="line">       for (int i = 0; i &lt; array.length;i++)&#123;</span><br><span class="line">           System.out.print(array[i]+&quot; &quot;);</span><br><span class="line">       &#125;</span><br><span class="line">       System.out.println();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">       Integer[] array = &#123;3,5,4,36,21&#125;;</span><br><span class="line">       System.out.println(&quot;使用堆排序前&quot;);</span><br><span class="line">       SeparateAndConquer.printArray(array);</span><br><span class="line">       SeparateAndConquer.heapSort(array);</span><br><span class="line">       System.out.println(&quot;使用堆排序后&quot;);</span><br><span class="line">       SeparateAndConquer.printArray(array);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">使用堆排序前</span><br><span class="line">3 5 4 36 21 </span><br><span class="line">第 1 趟: 21 5 4 3 36 </span><br><span class="line">第 2 趟: 5 3 4 21 36 </span><br><span class="line">第 3 趟: 4 3 5 21 36 </span><br><span class="line">第 4 趟: 3 4 5 21 36 </span><br><span class="line">使用堆排序后</span><br><span class="line">3 4 5 21 36</span><br></pre></td></tr></table></figure><h2 id="about"><a href="#about" class="headerlink" title="about"></a>about</h2><p>说完了怎么实现，再来分析一下堆排序算法</p><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>经验表明，<strong>堆排序是个十分稳定的算法</strong>。堆排序给出了迄今为止最佳的大O运行时间。在第一步初始化堆阶段时间复杂度为 O(N)，第二步在执行 N 次交换并调整大根堆所用时间复杂度为 O(NlogN)，综合下来时间复杂度为 O(N)。</p><h3 id="算法稳定性"><a href="#算法稳定性" class="headerlink" title="算法稳定性"></a>算法稳定性</h3><p>堆排序是一种不稳定的排序方法。<br>因为在堆的调整过程中，关键字进行比较和交换所走的是该结点到叶子结点的一条路径，因此对于相同的关键字就可能出现排在后面的关键字被交换到前面来的情况。 </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;堆排序-HeapSort&quot;&gt;&lt;a href=&quot;#堆排序-HeapSort&quot; class=&quot;headerlink&quot; title=&quot;堆排序-HeapSort&quot;&gt;&lt;/a&gt;堆排序-HeapSort&lt;/h1&gt;&lt;h2 id=&quot;what&quot;&gt;&lt;a href=&quot;#what&quot; cla
      
    
    </summary>
    
    
      <category term="算法algorithm" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95algorithm/"/>
    
  </entry>
  
  <entry>
    <title>世界你好</title>
    <link href="http://yoursite.com/2017/12/01/hello-world/"/>
    <id>http://yoursite.com/2017/12/01/hello-world/</id>
    <published>2017-12-01T07:35:59.657Z</published>
    <updated>2017-12-02T11:31:34.922Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h1><p>程序员的职业病？尝试一个新事物就要写个”Hello World”嘚瑟一下。</p><h1 id="That’s-Fun"><a href="#That’s-Fun" class="headerlink" title="That’s Fun"></a>That’s Fun</h1><p>第一次尝试用 github + hexo 搭建自己的博客，简直不要太爽！打今儿起也不再死板的用 github 记笔记了，也潮流一次！感叹互联网技术为我们带来的便捷，一个前端小白都可以搭建自己喜好风格的博客。用 hexo 写博客是一件很享受和放松的事情，最重要还可以装装B…hhhh</p><h1 id="To-Me"><a href="#To-Me" class="headerlink" title="To Me"></a>To Me</h1><p>最后送给自己一句话：<strong>坚持会让所有的幸福如期而至</strong>！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Hello-World&quot;&gt;&lt;a href=&quot;#Hello-World&quot; class=&quot;headerlink&quot; title=&quot;Hello World&quot;&gt;&lt;/a&gt;Hello World&lt;/h1&gt;&lt;p&gt;程序员的职业病？尝试一个新事物就要写个”Hello World”嘚瑟
      
    
    </summary>
    
    
      <category term="hello world" scheme="http://yoursite.com/tags/hello-world/"/>
    
  </entry>
  
</feed>
